<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L..z、℃的博客</title>
  
  <subtitle>Be unfazed by defeat.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0202zc.github.io/"/>
  <updated>2020-03-30T03:15:27.746Z</updated>
  <id>http://0202zc.github.io/</id>
  
  <author>
    <name>0202zc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="http://0202zc.github.io/2020/03/30/algorithm/algorithm-single-number/"/>
    <id>http://0202zc.github.io/2020/03/30/algorithm/algorithm-single-number/</id>
    <published>2020-03-30T03:04:08.000Z</published>
    <updated>2020-03-30T03:15:27.746Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. Single Number</a><br><a id="more"></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><a href="https://leetcode-cn.com/problems/single-number/solution/hua-jie-suan-fa-136-zhi-chu-xian-yi-ci-de-shu-zi-b/" target="_blank" rel="noopener">解题思路</a></h1><ul><li><p>标签：位运算</p></li><li><p>本题根据题意，线性时间复杂度 $O(n)$，很容易想到使用 Hash 映射来进行计算，遍历一次后结束得到结果，但是在空间复杂度上会达到 $O(n)$，需要使用较多的额外空间</p></li><li>既满足时间复杂度又满足空间复杂度，就要提到位运算中的异或运算 XOR，主要因为异或运算有以下几个特点：<ul><li>一个数和 0 做 XOR 运算等于本身： a ⊕ 0 = a</li><li>一个数和其本身做 XOR 运算等于 0： a ⊕ a = 0</li><li>XOR 运算满足交换律和结合律： a ⊕ b ⊕ a = (a ⊕ a) ⊕ b = 0 ⊕ b = b</li></ul></li><li>故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字</li><li>时间复杂度：$O(n)$，空间复杂度：$O(1)$。</li></ul><p><img data-src="https://pic.leetcode-cn.com/7d1bd50370f8f2b60d7215ca12f2f5ac4f3cca801f68e4ef1053e8e3180ce74b-frame_00001.png" style="zoom:80%;"></p><p><img data-src="https://pic.leetcode-cn.com/ab397765b568b8547a9c4ef4b256a92e64b7cab698aa0cb656bb8285131524aa-frame_00002.png" alt=""></p><p><img data-src="https://pic.leetcode-cn.com/c7c3577c968692e02c0eb9baa8cb699575bb2338bd6023ced8e00508767ea8ec-frame_00003.png" style="zoom:80%;"></p><p><img data-src="https://pic.leetcode-cn.com/1b03b163501fecf12048ef8224a7c2c694af2289b5e071633f1fa7ef28b12b79-frame_00004.png" style="zoom:80%;"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        ans ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;136. Single Number&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://0202zc.github.io/2020/03/30/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://0202zc.github.io/2020/03/30/位运算/</id>
    <published>2020-03-30T01:46:22.000Z</published>
    <updated>2020-03-30T01:53:07.783Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.cnblogs.com/yrjns/p/11246163.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/yrjns/p/11246163.html" target="_blank" rel="noopener">位运算（&amp;、|、^、~、&gt;&gt;、&lt;&lt;）</a></a><br><a id="more"></a></p><h2 id="1-位运算概述"><a href="#1-位运算概述" class="headerlink" title="1. 位运算概述"></a>1. 位运算概述</h2><p>从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。</p><p>口说无凭，举一个简单的例子来看下CPU是如何进行计算的，比如这行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure><p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">35</span>:  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">47</span>:  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">————————————————————</span><br><span class="line"><span class="number">82</span>:  <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所以，相比在代码中直接使用(+、-、*、/)运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。</p><h2 id="2-位运算概览"><a href="#2-位运算概览" class="headerlink" title="2. 位运算概览"></a>2. 位运算概览</h2><table><thead><tr><th>符号</th><th>描述</th><th style="text-align:left">运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td style="text-align:left">两个位都为1时，结果才为1</td></tr><tr><td>\</td><td></td><td style="text-align:left">或</td><td>两个位都为0时，结果才为0</td></tr><tr><td>^</td><td>异或</td><td style="text-align:left">两个位相同为0，相异为1</td></tr><tr><td>~</td><td>取反</td><td style="text-align:left">0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td style="text-align:left">各二进位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td style="text-align:left">各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><h2 id="3-按位与运算符（-amp-）"><a href="#3-按位与运算符（-amp-）" class="headerlink" title="3. 按位与运算符（&amp;）"></a>3. 按位与运算符（&amp;）</h2><p>定义：参加运算的两个数据，按二进制位进行“与”运算。</p><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>&amp;<span class="number">0</span>=<span class="number">0</span>  <span class="number">0</span>&amp;<span class="number">1</span>=<span class="number">0</span>  <span class="number">1</span>&amp;<span class="number">0</span>=<span class="number">0</span>  <span class="number">1</span>&amp;<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：两位同时为<strong>1</strong>，结果才为<strong>1</strong>，否则结果为<strong>0</strong>。</p><p>例如：<code>3&amp;5</code> 即 0000 0011&amp; 0000 0101 = 0000 0001，因此 3&amp;5 的值得1。</p><p>注意：负数按<strong>补码</strong>形式参加按位与运算。</p><p>与运算的用途：</p><p><strong>1）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><p><strong>2）取一个数的指定位</strong></p><p>比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&amp;Y=0000 1110）即可得到X的指定位。</p><p><strong>3）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((a &amp; 1) == 0)</code>代替<code>if (a % 2 == 0)</code>来判断a是不是偶数。</p><h2 id="4-按位或运算符（-）"><a href="#4-按位或运算符（-）" class="headerlink" title="4. 按位或运算符（|）"></a>4. 按位或运算符（|）</h2><p>定义：参加运算的两个对象，按二进制位进行“或”运算。</p><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>|<span class="number">0</span>=<span class="number">0</span>  <span class="number">0</span>|<span class="number">1</span>=<span class="number">1</span>  <span class="number">1</span>|<span class="number">0</span>=<span class="number">1</span>  <span class="number">1</span>|<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。</p><p>例如：<code>3|5</code>即 0000 0011| 0000 0101 = 0000 0111，因此，<code>3|5</code>的值得7。　</p><p>注意：负数按<strong>补码</strong>形式参加按位或运算。</p><p>或运算的用途：</p><p><strong>1）常用来对一个数据的某些位设置为1</strong></p><p>比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。</p><h2 id="5-异或运算符（-）"><a href="#5-异或运算符（-）" class="headerlink" title="5. 异或运算符（^）"></a>5. 异或运算符（^）</h2><p>定义：参加运算的两个数据，按二进制位进行“异或”运算。</p><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>^<span class="number">0</span>=<span class="number">0</span>  <span class="number">0</span>^<span class="number">1</span>=<span class="number">1</span>  <span class="number">1</span>^<span class="number">0</span>=<span class="number">1</span>  <span class="number">1</span>^<span class="number">1</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p><p>异或的几条性质:</p><p>1、交换律</p><p>2、结合律 (a^b)^c == a^(b^c)</p><p>3、对于任何数x，都有 x^x=0，x^0=x</p><p>4、自反性: a^b^b=a^0=a;</p><p>异或运算的用途：</p><p><strong>1）翻转指定位</strong></p><p>比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。</p><p><strong>2）与0相异或值不变</strong></p><p>例如：1010 1110 ^ 0000 0000 = 1010 1110</p><p><strong>3）交换两个数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b)&#123;</span><br><span class="line">        a ^= b;</span><br><span class="line">        b ^= a;</span><br><span class="line">        a ^= b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-取反运算符"><a href="#6-取反运算符" class="headerlink" title="6. 取反运算符 (~)"></a>6. 取反运算符 (~)</h2><p>定义：参加运算的一个数据，按二进制进行“取反”运算。<br>运算规则：　</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">1</span> = <span class="number">0</span></span><br><span class="line">~<span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。</p><p>异或运算的用途：</p><p><strong>1）使一个数的最低位为零</strong></p><p>使a的最低位为0，可以表示为：<code>a &amp; ~1</code>。~1的值为 1111 1111 1111 1110，再按”与”运算，最低位一定为0。因为“ ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p><h2 id="7-左移运算符（-lt-lt-）"><a href="#7-左移运算符（-lt-lt-）" class="headerlink" title="7. 左移运算符（&lt;&lt;）"></a>7. 左移运算符（&lt;&lt;）</h2><p>定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p><p>设 a=1010 1110，<code>a = a&lt;&lt; 2</code> 将a的二进制位左移2位、右补0，即得a=1011 1000。</p><p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h2 id="8-右移运算符（-gt-gt-）"><a href="#8-右移运算符（-gt-gt-）" class="headerlink" title="8.右移运算符（&gt;&gt;）"></a>8.右移运算符（&gt;&gt;）</h2><p>定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p><p>例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p><p>操作数每右移一位，相当于该数除以2。</p><h2 id="10-复合赋值运算符"><a href="#10-复合赋值运算符" class="headerlink" title="10.复合赋值运算符"></a>10.复合赋值运算符</h2><p>位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;=`    例：`a&amp;=b  `相当于   `a=a&amp;b</span><br><span class="line">|=`    例：`a|=b  `相当于   `a=a|b</span><br><span class="line">&gt;&gt;=`   例：`a&gt;&gt;=b  `相当于   `a=a&gt;&gt;b</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;=</code>   例：<code>a&lt;&lt;=b</code>   相当于   `a=a&lt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^=`    例：`a^=b  `相当`于  a=a^b</span><br></pre></td></tr></table></figure><p>运算规则：和前面讲的复合赋值运算符的运算规则相似。</p><p><strong>不同长度的数据进行位运算：</strong>如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。</p><p>以“与运算”为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行“与运算“，右端对齐后，左边不足的位依下面三种情况补足，</p><p>1）如果整型数据为正数，左边补16个0。</p><p>2）如果整型数据为负数，左边补16个1。</p><p>3）如果整形数据为无符号数，左边也补16个0。</p><p>如：<code>long a=123</code>；<code>int b=1</code>；计算a &amp; b。</p><p>如：<code>long a=123</code>；<code>int b=-1</code>；计算a &amp; b。</p><p>如：<code>long a=123</code>；<code>unsigned int b=1</code>；计算a &amp; b。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://www.cnblogs.com/yrjns/p/11246163.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/yrjns/p/11246163.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;位运算（&amp;amp;、|、^、~、&amp;gt;&amp;gt;、&amp;lt;&amp;lt;）&lt;/a&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>移动零</title>
    <link href="http://0202zc.github.io/2020/03/16/algorithm/algorithm-move-zeros/"/>
    <id>http://0202zc.github.io/2020/03/16/algorithm/algorithm-move-zeros/</id>
    <published>2020-03-16T01:23:33.000Z</published>
    <updated>2020-03-16T01:33:35.388Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. Move Zeroes</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 $0$ 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [0,1,0,3,12]<br><strong>输出:</strong> [1,3,12,0,0]</p></blockquote><p><strong>说明:</strong></p><pre><code>1. 必须在原数组上操作，不能拷贝额外的数组。2. 尽量减少操作次数。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法：双指针</strong><br>用两个指针i, j从头到尾依次遍历，遇到零元素就记录位置，遇到非零元素就进行替换零的操作<br>当一个指针i进行完一次遍历，此时非零元素已经全部移动到前面的位置，只需要将剩余位置上的元素置为零即可</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;   <span class="comment">//遇到非零元素进行替换零</span></span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else 继续查找非零元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余位置上的元素置为零</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; numsSize)&#123;</span><br><span class="line">        nums[j++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;283. Move Zeroes&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数</title>
    <link href="http://0202zc.github.io/2020/03/15/algorithm/algorithm-find-the-duplicate-number/"/>
    <id>http://0202zc.github.io/2020/03/15/algorithm/algorithm-find-the-duplicate-number/</id>
    <published>2020-03-15T15:42:16.000Z</published>
    <updated>2020-03-30T01:35:08.744Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/find-the-duplicate-number" target="_blank" rel="noopener">287. Find the Duplicate Number</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含 $n + 1$ 个整数的数组 <code>nums</code>，其数字都在 $1$ 到 $n$ 之间（包括 $1$ 和 $n$），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,3,4,2,2]<br><strong>输出:</strong> 2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [3,1,3,4,2]<br><strong>输出:</strong> 3</p></blockquote><p><strong>说明：</strong></p><blockquote><p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 $O(1)$ 的空间。<br>时间复杂度小于 $O(n^2)$ 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">解题思路</a></h3><p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。</p><p><strong>方法：二分查找</strong><br><strong>思路：</strong>这道题要求我们查找的数是一个整数，并且给出了这个整数的范围（在 $1$ 和 $n$ 之间，包括 $1$ 和 $n$），并且给出了一些限制，于是可以使用二分查找法定位在一个区间里的整数。</p><p>这个问题应用二分法与绝大多数其它问题应用二分法的不同点是：正着思考是容易的，即思考哪边区间存在重复数是容易的，因为依然是有抽屉原理做保证。我们依然通过一个具体的例子来分析应该如何编写代码。</p><p>以 <code>[1, 2, 2, 3, 4, 5, 6, 7]</code> 为例，一共 8 个数，<code>n + 1 = 8</code>，<code>n = 7</code>，根据题目意思，每个数都在 <code>1</code> 和 <code>7</code> 之间。</p><p>例如：区间 <code>[1, 7]</code> 的中位数是 <code>4</code>，遍历整个数组，统计小于等于 <code>4</code> 的整数的个数，至多应该为 <code>4</code> 个。换句话说，整个数组里小于等于 <code>4</code> 的整数的个数如果严格大于 <code>4</code> 个，就说明重复的数存在于区间 <code>[1, 4]</code>，它的反面是：重复的数存在于区间 <code>[5, 7]</code>。</p><p>于是，二分法的思路是先猜一个数（有效范围 <code>[left, right]</code>里的中间数 <code>mid</code>），然后统计原始数组中<strong>小于或等于</strong>这个中间数的元素的个数 <code>cnt</code>，如果 <code>cnt</code> <strong>严格大于</strong> <code>mid</code>，（注意我加了着重号的部分“小于或等于”、“严格大于”）依然根据抽屉原理，重复元素就应该在区间 <code>[left, mid]</code> 里。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = numsSize - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= mid)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据抽屉原理，严格小于 4 的数的个数如果大于等于 4 个，</span></span><br><span class="line">        <span class="comment">// 此时重复元素一定出现在 [1, 3] 区间里</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; mid)</span><br><span class="line">            <span class="comment">// 重复的元素一定出现在 [left, mid - 1] 区间里</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// if 分析正确了以后，else 搜索的区间就是 if 的反面</span></span><br><span class="line">            <span class="comment">// [mid, right]</span></span><br><span class="line">            <span class="comment">// 注意：此时需要调整中位数的取法为上取整</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：$O(NlogN)$，二分法的时间复杂度为 $O(logN)$，在二分法的内部，执行了一次 <code>for</code> 循环，时间复杂度为 $O(N)$，故时间复杂度为 $O(NlogN)$。<br>空间复杂度：$O(1)$，使用了一个 <code>cnt</code> 变量，因此空间复杂度为 $O(1)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-number&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;287. Find the Duplicate Number&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转数组</title>
    <link href="http://0202zc.github.io/2020/03/15/algorithm/algorithm-search-rotate-array-lcci/"/>
    <id>http://0202zc.github.io/2020/03/15/algorithm/algorithm-search-rotate-array-lcci/</id>
    <published>2020-03-15T02:38:52.000Z</published>
    <updated>2020-03-15T03:11:36.966Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/" target="_blank" rel="noopener">面试题 10.03. Search Rotate Array LCCI</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5<br><strong>输出:</strong> 8（元素5在该数组中的索引）</p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong>arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11<br><strong>输出：</strong>-1 （没有找到）</p></blockquote><p><strong>提示:</strong></p><blockquote><p>arr 长度范围在[1, 1000000]之间</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/solution/er-fen-fa-by-armeria-program/" target="_blank" rel="noopener"><strong>二分法</strong></a><br>对于能判断升序区间的情况，根据目标值的大小移动边界。<br>对于不能判断升序区间的情况，需要逐步清除重复值。</p><p>没有重复值的最优情况时间复杂度是$O(log N)$，全部或几乎全部是重复值的最差情况时间复杂度是$O(N)$。</p><!--                                     `nums[left] <= target`                                ┌─  `&& target <= nums[mid]`   ──>  `right = mid`                                              │   （目标在左边的升序区间中）      （右边界移动到mid）  ┌─  nums[left] < nums[mid] ─┼  │     （左边区间升序）       │  │                           └─    否则目标在右半边        ──>  `left = mid + 1`  │                                                             （左边界移动到mid+1）  │                 │                                 `nums[left] <= target`    │                           ┌─  `|| target <= nums[mid]`   ──>  `right = mid`                │                           │    （目标在左半边）              （右边界移动到mid） ─┼─  nums[left] > nums[mid] ─┼       │     （左边不是升序）       │  │                           └─    否则目标在右半边        ──>  `left = mid + 1`   │                                                             （左边界移动到mid+1）  │                 │                               │                           ┌─   `nums[left] != target`    ──>  `left++`                  │                           │     （左值不等于目标              （需要逐一清理重复值）          └─ nums[left] == nums[mid] ─┼         说明还没找到）      （可能是已经找到了目标    │        也可能是遇到了重复值）  └─   `nums[left] == target`    ──>  `right = left`                                    （左值等于目标                （将右边界移动到left，循环结束）                                      已经找到最左边的目标值） --><p><img data-src="/images/algorithm/Search-Rotate-Array-Lcci.jpg" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> arrSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = arrSize - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;                                         <span class="comment">// 循环结束条件left==right</span></span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;                              <span class="comment">// 如果左值小于中值，说明左边区间升序               </span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;     <span class="comment">// 如果目标在左边的升序区间中，右边界移动到mid</span></span><br><span class="line">                    right = mid;                                       </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                               <span class="comment">// 否则目标在右半边，左边界移动到mid+1</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;                                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;                       <span class="comment">// 如果左值大于中值，说明左边不是升序，右半边升序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target || target &lt;= nums[mid]) &#123;     <span class="comment">// 如果目标在左边，右边界移动到mid</span></span><br><span class="line">                    right = mid;                                       </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                               <span class="comment">// 否则目标在右半边，左边界移动到mid+1</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;                                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;                      <span class="comment">// 如果左值等于中值，可能是已经找到了目标，也可能是遇到了重复值</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] != target) &#123;                            <span class="comment">// 如果左值不等于目标，说明还没找到，需要逐一清理重复值。</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                               <span class="comment">// 如果左值等于目标，说明已经找到最左边的目标值 </span></span><br><span class="line">                    right = left;                                      <span class="comment">// 将右边界移动到left，循环结束</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (nums[left] == target) ? left : <span class="number">-1</span>;                     <span class="comment">// 返回left，或者-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/search-rotate-array-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 10.03. Search Rotate Array LCCI&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>反转链表 II</title>
    <link href="http://0202zc.github.io/2020/03/12/algorithm/algorithm-reverse-linked-list-ii/"/>
    <id>http://0202zc.github.io/2020/03/12/algorithm/algorithm-reverse-linked-list-ii/</id>
    <published>2020-03-12T09:48:25.000Z</published>
    <updated>2020-03-28T06:52:07.059Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse Linked List II</a><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <code>m = 2</code>, <code>n = 4</code><br><strong>输出:</strong> <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></p></blockquote><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>用四个指针分别指向第 $(m - 1)$、$m$、$n$、$(n + 1)$ 个元素</li><li>从第 $m$ 个元素到第 $n$ 个元素断链，将其逆置，得到新链表<code>newLink</code>（设置头结点以便操作）</li><li>再将原链表衔接起来</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverse</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = head;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseBetween</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || m &gt; n)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">H</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    H-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">start</span> = <span class="title">H</span>, *<span class="title">end</span> = <span class="title">H</span>, *<span class="title">preStart</span> = <span class="title">start</span>, *<span class="title">rearEnd</span> = <span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m) &#123;</span><br><span class="line">            preStart = start;</span><br><span class="line">            start = start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        end = end-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    rearEnd = end-&gt;next;</span><br><span class="line">    end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    t = start;</span><br><span class="line">    preStart-&gt;next = reverse(start);</span><br><span class="line">    t-&gt;next = rearEnd;</span><br><span class="line">    <span class="keyword">return</span> H-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>实现思路 ：以1-&gt;2-&gt;3-&gt;4-&gt;5, m = 2, n=4 为例:</p><ul><li>定位到要反转部分的头节点 2，head = 2；前驱结点 1，pre = 1；</li><li>当前节点的下一个节点3调整为前驱节点的下一个节点 1-&gt;3-&gt;2-&gt;4-&gt;5,</li><li>当前结点仍为2， 前驱结点依然是1，重复上一步操作。。。</li><li>1-&gt;4-&gt;3-&gt;2-&gt;5.</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseBetween</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> = <span class="title">dummy</span>, *<span class="title">nxt</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) </span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    head = pre-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; i++)&#123;</span><br><span class="line">        nxt = head-&gt;next;</span><br><span class="line">        head-&gt;next = nxt-&gt;next;</span><br><span class="line">        nxt-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;92. Reverse Linked List II&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法集（改）</title>
    <link href="http://0202zc.github.io/2020/03/07/%E7%AE%97%E6%B3%95%E9%9B%86(%E6%94%B9)/"/>
    <id>http://0202zc.github.io/2020/03/07/算法集(改)/</id>
    <published>2020-03-07T03:08:09.000Z</published>
    <updated>2020-03-14T02:23:25.407Z</updated>
    
    <content type="html"><![CDATA[<p>对算法集.doc的整理，好像都是真题（一部分算法题，一部分是填空、改错等）<br><a id="more"></a></p><h1 id="筛选法求素数"><a href="#筛选法求素数" class="headerlink" title="筛选法求素数"></a>筛选法求素数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWIDTH 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> sieve[SIZE];</span><br><span class="line"><span class="keyword">int</span> i, n, printcol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">sieve[i] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//存放100以内的素数标识</span></span><br><span class="line"></span><br><span class="line">sieve[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//1表示不是素数</span></span><br><span class="line">printcol = <span class="number">0</span>; <span class="comment">//行计数</span></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= SIZE; n++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sieve[n - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, n);</span><br><span class="line"><span class="keyword">if</span> (++printcol &gt;= PWIDTH) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">printcol = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = n; i &lt;= SIZE; i = i + n) &#123;</span><br><span class="line"><span class="comment">//i的倍数(i += n)全为合数</span></span><br><span class="line">sieve[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串交换"><a href="#字符串交换" class="headerlink" title="字符串交换"></a>字符串交换</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">char</span> **q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *temp;</span><br><span class="line">temp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str1 = <span class="string">"aaaa"</span>, *str2 = <span class="string">"bbb"</span>;</span><br><span class="line">swap(&amp;str1, &amp;str2);</span><br><span class="line"><span class="built_in">puts</span>(str1);</span><br><span class="line"><span class="built_in">puts</span>(str2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k, a[N + <span class="number">1</span>], *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, p = a; p &lt;= a + N; i++, p++) &#123;</span><br><span class="line">*p = i;</span><br><span class="line">&#125;   <span class="comment">//填充序号</span></span><br><span class="line">p = a + <span class="number">1</span>; <span class="comment">//取值</span></span><br><span class="line">k = N; <span class="comment">//统计剩余人数</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; k != <span class="number">1</span>; p++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &gt; a + N) &#123;</span><br><span class="line">p = a + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">//若越界，返回数组首部，开始下一轮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (j % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">k--;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//判断是否为3</span></span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="comment">//判断是否被推出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最后剩下的数字是：%d\n"</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求第k小"><a href="#求第k小" class="headerlink" title="求第k小"></a>求第k小</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[MAXN] = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;, n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入n值：\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, search(a, <span class="number">10</span>, n));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low, high, i, j, t;</span><br><span class="line">k--;</span><br><span class="line">low = <span class="number">0</span>;</span><br><span class="line">high = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">i = low;</span><br><span class="line">j = high;</span><br><span class="line">t = a[low];</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; t &lt;= a[j]) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">a[i] = a[j];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; t &gt; a[i]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = a[i];</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; j);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下开始进行二分查找，找到第k个位置</span></span><br><span class="line"><span class="keyword">if</span> (i == k) &#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">low = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (low &lt; high);</span><br><span class="line"><span class="keyword">return</span> a[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将字符串中的数字提取到数组中"><a href="#将字符串中的数字提取到数组中" class="headerlink" title="将字符串中的数字提取到数组中"></a>将字符串中的数字提取到数组中</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_int</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">char</span> *pc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"ues11tc2015jsj320#"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; find_int(arr, s); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_int</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">char</span> *pc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pc[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'0'</span> &lt;= pc[i] &amp;&amp; pc[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line">sum = sum * <span class="number">10</span> + pc[i] - <span class="string">'0'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line">arr[j++] = sum;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输入20个数（浮点-整型），逆序存放到单链表中"><a href="#输入20个数（浮点-整型），逆序存放到单链表中" class="headerlink" title="输入20个数（浮点+整型），逆序存放到单链表中"></a>输入20个数（浮点+整型），逆序存放到单链表中</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">float</span> y;</span><br><span class="line">&#125; data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line">node *L;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">Creatlist</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">node *r;</span><br><span class="line">r = Creatlist(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r) &#123;</span><br><span class="line"><span class="keyword">if</span> (r-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, r-&gt;data.x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1f "</span>, r-&gt;data.y);</span><br><span class="line">&#125;</span><br><span class="line">r = r-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">Creatlist</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, f;</span><br><span class="line">node *L, *p;</span><br><span class="line">L = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入第%d个数字的标志位："</span>, i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f); <span class="comment">//若标志位0，则输入整型，否则输入浮点型</span></span><br><span class="line">p = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">p-&gt;flag = f;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数据:"</span>);</span><br><span class="line"><span class="keyword">if</span> (f == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;data.x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;p-&gt;data.y);</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = L;</span><br><span class="line">L = p;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求最高分分数学生的编号"><a href="#求最高分分数学生的编号" class="headerlink" title="求最高分分数学生的编号"></a>求最高分分数学生的编号</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125; stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HighScore</span><span class="params">(stu *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stu arr[N];</span><br><span class="line">HighScore(arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HighScore</span><span class="params">(stu *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">stu *r, q;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入学生的编号和分数: \n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>, &amp;p[i].num, &amp;p[i].score);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 直接进行大小比较</span></span><br><span class="line"><span class="comment">int num = p[0].num;</span></span><br><span class="line"><span class="comment">max = p[0].score;</span></span><br><span class="line"><span class="comment">for(i = 1; i &lt; N; i++) &#123;</span></span><br><span class="line"><span class="comment">if(max &lt; p[i].score) &#123;</span></span><br><span class="line"><span class="comment">max = p[i].score;</span></span><br><span class="line"><span class="comment">num = p[i].num;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("最大：%d, %d\n", num, max);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">r = &amp;p[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[j].score &lt; p[i].score) &#123;</span><br><span class="line">r = &amp;p[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//一轮遍历找出余下数据中的最小者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换数据</span></span><br><span class="line">q.num = r-&gt;num;</span><br><span class="line">q.score = r-&gt;score;</span><br><span class="line"></span><br><span class="line">r-&gt;num = p[i].num;</span><br><span class="line">r-&gt;score = p[i].score;</span><br><span class="line"></span><br><span class="line">p[i].num = q.num;</span><br><span class="line">p[i].score = q.score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max = p[N - <span class="number">1</span>].score;</span><br><span class="line"><span class="keyword">for</span> (i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i].score == max) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, p[i].num, p[i].score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符数组逆置"><a href="#字符数组逆置" class="headerlink" title="字符数组逆置"></a>字符数组逆置</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line"><span class="keyword">char</span> p;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">p = *(str + i);</span><br><span class="line">*(str + i) = *(str + len - i - <span class="number">1</span>);</span><br><span class="line">*(str + len - i - <span class="number">1</span>) = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2个字符串是否相等"><a href="#2个字符串是否相等" class="headerlink" title="2个字符串是否相等"></a>2个字符串是否相等</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>], str2[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> *p, *q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入两个字符串，中间用空格隔开\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, str1, str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %s"</span>, str1, str2);</span><br><span class="line">getchar();</span><br><span class="line">p = str1;</span><br><span class="line">q = str2;</span><br><span class="line"><span class="keyword">if</span> (*p != *q) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n两个字符串不相等\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> ((*p == *q) &amp;&amp; (*p != <span class="string">'\0'</span>) &amp;&amp; (*q != <span class="string">'\0'</span>)) &#123;</span><br><span class="line">p++;</span><br><span class="line">q++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*p == <span class="string">'\0'</span>) &amp;&amp; (*q == <span class="string">'\0'</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n两个字符串相等\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n两个字符串不相等\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="传地址"><a href="#传地址" class="headerlink" title="传地址"></a>传地址</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (*t-- = <span class="number">3</span>) - <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">&#125; <span class="comment">//t得到p的地址1，地址1中内容被赋值为3，函数返回值为2，t--移动到地址0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr + <span class="number">1</span>;  <span class="comment">//p得到数组的地址1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, func(p) + *p); <span class="comment">//p依旧在地址1 其值为3 | func(p) == 2，*p == 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="地址理解"><a href="#地址理解" class="headerlink" title="地址理解"></a>地址理解</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;arr[<span class="number">1</span>];</span><br><span class="line">p[<span class="number">1</span>] = *p - <span class="number">1</span> + (p[<span class="number">-1</span>] = <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一个交错级数求和"><a href="#一个交错级数求和" class="headerlink" title="一个交错级数求和"></a>一个交错级数求和</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数值x及项数n：\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, sum(x, n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">double</span> a, b, s;</span><br><span class="line">s = <span class="number">1.0</span>;</span><br><span class="line">a = b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">a = a * x;</span><br><span class="line">b = b * i;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">s = s + a / b;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = s - a / b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="去掉字符串中的字母数字和重复项"><a href="#去掉字符串中的字母数字和重复项" class="headerlink" title="去掉字符串中的字母数字和重复项"></a>去掉字符串中的字母数字和重复项</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">81</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *s = <span class="string">"UE&amp;&amp;&amp;stc2018##@%"</span>;</span><br><span class="line">del(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((*str) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="string">'a'</span> &lt;= *str &amp;&amp; *str &lt;= <span class="string">'z'</span>) || (<span class="string">'A'</span> &lt;= *str &amp;&amp; *str &lt;= <span class="string">'Z'</span>) || (<span class="string">'0'</span> &lt;= *str &amp;&amp; *str &lt;= <span class="string">'9'</span>)) &#123;</span><br><span class="line"><span class="comment">//arr[i]=*str;</span></span><br><span class="line">str++;</span><br><span class="line"><span class="comment">//i++;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (*str == *(str + <span class="number">1</span>)) &#123;</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line">arr[i++] = *str++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对算法集.doc的整理，好像都是真题（一部分算法题，一部分是填空、改错等）&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>回文链表</title>
    <link href="http://0202zc.github.io/2020/03/02/algorithm/algorithm-palindrome-linked-list/"/>
    <id>http://0202zc.github.io/2020/03/02/algorithm/algorithm-palindrome-linked-list/</id>
    <published>2020-03-02T03:38:10.000Z</published>
    <updated>2020-03-02T03:38:27.440Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数，检查输入的链表是否是回文的。</p><p><strong>示例 1：</strong></p><blockquote><p>输入： 1-&gt;2<br>输出： <code>false</code> </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入： 1-&gt;2-&gt;2-&gt;1<br>输出： <code>true</code> </p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1、找中点的同时，将前半部倒序；<br>2、比较。<br>时间复杂度：$O(1)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">L</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//找中点</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同时对前面进行反转（头插法）</span></span><br><span class="line">        head-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        head = slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//slow指向后半部分头结点，head指向前半部分头结点</span></span><br><span class="line">    <span class="keyword">if</span>(fast)</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    head = L-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前半部分和后半部分进行比较</span></span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val != slow-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;234. Palindrome Linked List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>二进制链表转整数</title>
    <link href="http://0202zc.github.io/2020/03/01/algorithm/algoritm-convert-binary-number-in-a-linked-list-to-integer/"/>
    <id>http://0202zc.github.io/2020/03/01/algorithm/algoritm-convert-binary-number-in-a-linked-list-to-integer/</id>
    <published>2020-03-01T05:20:47.000Z</published>
    <updated>2020-03-01T05:20:51.451Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">1290. Convert Binary Number in a Linked List to Integer</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个单链表的引用结点 <code>head</code>。链表中每个结点的值不是 <code>0</code> 就是 <code>1</code>。已知此链表是一个整数数字的二进制表示形式。</p><p>请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/graph-1.png" alt=""></p><blockquote><p><strong>输入：</strong><code>head = [1,0,1]</code><br><strong>输出：</strong><code>5</code><br><strong>解释：</strong>二进制数 (101) 转化为十进制数 (5)</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><code>head = [0]</code><br><strong>输出：</strong><code>0</code></p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1]</code><br><strong>输出：</strong><code>1</code></p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]</code><br><strong>输出：</strong><code>18880</code></p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong><code>head = [0,0]</code><br><strong>输出：</strong><code>0</code></p></blockquote><p>提示：</p><ul><li>链表不为空。</li><li>链表的结点总数不超过 <code>30</code>。</li><li>每个结点的值不是 <code>0</code> 就是 <code>1</code>。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用<strong>位运算</strong>，<code>result &lt;&lt; 1</code> 就相当于 <code>result * 2</code>, <code>result |= 1（result |= 0）</code> 相当于 <code>result++</code>（不变）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ans = ans * <span class="number">2</span> + cur-&gt;val;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1290. Convert Binary Number in a Linked List to Integer&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>环路检测</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm/algorithm-linked-list-cycle-lcci/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm/algorithm-linked-list-cycle-lcci/</id>
    <published>2020-02-29T04:29:05.000Z</published>
    <updated>2020-02-29T04:35:16.761Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">面试题 02.08. Linked List Cycle LCCI</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong><code>head = [3,2,0,-4]</code>, <code>pos = 1</code><br><strong>输出：</strong>tail connects to node index 1<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1,2]</code>, <code>pos = 0</code><br><strong>输出：</strong>tail connects to node index 0<br><strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1]</code>, <code>pos = -1</code><br><strong>输出：</strong>no cycle<br><strong>解释：</strong>链表中没有环。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>经典的快慢指针问题，这里给出C的解法。</p><blockquote><ol><li>设置快慢指针</li><li>找到第一次相遇【快慢指针相遇】</li><li>再出发慢指针【从头结点出发的慢指针与快指针】</li><li>相遇即所求</li></ol></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 如果相遇了就break</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fast到了链表尾部,说明链表无环</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 慢指针从头开始, 快慢指针再一次相遇就是在环的起点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 02.08. Linked List Cycle LCCI&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>重排链表</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm/algorithm-reorder-list/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm/algorithm-reorder-list/</id>
    <published>2020-02-29T03:19:36.000Z</published>
    <updated>2020-02-29T03:19:49.244Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. Reorder List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><hr><p>给定一个单链表 $L：L_0→L_1→…→Ln-1→L_n$ ，<br>将其重新排列后变为： $L_0→L_n→L_1→Ln-1→L_2→Ln-2→…$</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4</code>, 重新排列为 <code>1-&gt;4-&gt;2-&gt;3</code>.</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, 重新排列为 <code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</p></blockquote><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, 重新排列为 <code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</p></blockquote><p>通过观察，可以将重排链表分解为以下三个步骤：</p><ol><li>首先重新排列后，链表的中心节点会变为最后一个节点。所以需要先找到链表的中心节点：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. 链表的中间结点</a></li><li>可以按照中心节点将原始链表划分为左右两个链表。<ol><li>按照中心节点将原始链表划分为左右两个链表，左链表：<code>1-&gt;2-&gt;3</code> 右链表：<code>4-&gt;5</code>。</li><li>将右链表反转，就正好是重排链表交换的顺序，右链表反转：<code>5-&gt;4</code>。反转链表：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></li></ol></li><li>合并两个链表，将右链表插入到左链表，即可重新排列成：<code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用快慢指针,找出链表的中心节点</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过递归反转链表</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">p</span>;</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = head;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 合并两个链表，将右链表插入到左链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(struct ListNode* left, struct ListNode* right)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">leftTemp</span>, *<span class="title">rightTemp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge的循环时候条件应为: 当右链表为空的时候,就结束循环</span></span><br><span class="line">    <span class="comment">// 原因是: </span></span><br><span class="line">    <span class="comment">//     1.你取了中心节点的next为右链表的head, 那么两者的长度一定是  左链表 &gt; 右链表</span></span><br><span class="line">    <span class="comment">//     2. 当原始链表为:  奇数 左链表=右链表+1 ; 偶数 左链表=右链表+2</span></span><br><span class="line">    <span class="comment">// 所以: 只用判断右链表的节点是否为空就可以了,而不用判断左链表. 左链表的next肯定有值.</span></span><br><span class="line">    <span class="keyword">while</span>(right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//1. 保存next节点</span></span><br><span class="line">        leftTemp = left-&gt;next;</span><br><span class="line">        rightTemp = right-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将右链表的第一个节点插入到左链表中</span></span><br><span class="line">        <span class="comment">// 左链表：1-&gt;2-&gt;3 右链表：5-&gt;4 </span></span><br><span class="line">        <span class="comment">// 合并后的左链表：1-&gt;5-&gt;2-&gt;3</span></span><br><span class="line">        left-&gt;next = right;</span><br><span class="line">        right-&gt;next = leftTemp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 移动left和right指针</span></span><br><span class="line">        <span class="comment">// 左链表变为：2-&gt;3 右链表变为：4</span></span><br><span class="line">        left = leftTemp;</span><br><span class="line">        right = rightTemp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用快慢指针,找出链表的中心节点。</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5,中心节点为3</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">middle</span> = <span class="title">middleNode</span>(<span class="title">head</span>);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将原始链表按照中心链表分割为两个链表，并将右链表反转</span></span><br><span class="line">    <span class="comment">// 2.1 原始链表：1-&gt;2-&gt;3-&gt;4-&gt;5 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">left</span> = <span class="title">head</span>, *<span class="title">right</span> = <span class="title">middle</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    middle-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 反转右链表</span></span><br><span class="line">    <span class="comment">//原始右链表：4-&gt;5 反转后：5-&gt;4</span></span><br><span class="line">    right = reverseList(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 合并两个链表，将右链表插入到左链表</span></span><br><span class="line">    <span class="comment">// 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5 合并后：1-&gt;5-&gt;2-&gt;4-&gt;3</span></span><br><span class="line">    mergeList(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reorder-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;143. Reorder List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>链表的中间结点</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm/algorithm-middle-of-the-linked-list/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm/algorithm-middle-of-the-linked-list/</id>
    <published>2020-02-29T01:56:03.000Z</published>
    <updated>2020-02-29T03:08:32.007Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. Middle of the Linked List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong><code>[1,2,3,4,5]</code><br><strong>输出：</strong>此列表中的结点 <code>3</code> (序列化形式：[3,4,5])<br>返回的结点值为 <code>3</code> 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 <code>ListNode</code> 类型的对象 <code>ans</code>，这样：<br><code>ans.val = 3</code>, <code>ans.next.val = 4</code>, <code>ans.next.next.val = 5</code>, 以及 <code>ans.next.next.next = NULL</code>.</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><code>[1,2,3,4,5,6]</code><br><strong>输出：</strong>此列表中的结点 <code>4</code> (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 <code>3</code> 和 <code>4</code>，我们返回第二个结点。</p></blockquote><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>先求出链表的长度 <code>length</code>，再进行计数遍历，遍历到 <code>length / 2</code> 为止，返回该结点。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">LinkLength</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">         head = head-&gt;next;</span><br><span class="line">         len++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> len;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> len = LinkLength(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>设置<strong>快慢指针</strong> <code>fast</code>，<code>slow</code>。其中 <code>fast</code> 的步长为 $2$，<code>slow</code> 的步长为 $1$，那么在相同时间的前提下 <code>fast</code> 走过的链表长度就是 <code>slow</code> 走过长度的<strong>两倍</strong>。当 <code>fast</code> 抵达链表末尾时，<code>slow</code> 恰好指向链表的中间结点，此时 <code>return slow</code>。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;876. Middle of the Linked List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="http://0202zc.github.io/2020/02/16/algorithm/algorithm-remove-nth-node-from-end-of-list/"/>
    <id>http://0202zc.github.io/2020/02/16/algorithm/algorithm-remove-nth-node-from-end-of-list/</id>
    <published>2020-02-16T04:28:04.000Z</published>
    <updated>2020-02-16T06:45:57.183Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，删除链表的倒数第 $n$ 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><blockquote><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong>n = 2</strong>.</p></blockquote><blockquote><p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.<br>说明：</p></blockquote><p>给定的 $n$ 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>快慢指针，快指针先走n步，然后快慢一起走，直到快指针走到最后，要注意的是可能是要删除第一个节点，这个时候可以直接返回<code>head -&gt; next</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head -&gt; next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast)&#123;</span><br><span class="line">        <span class="keyword">return</span> head -&gt; next;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast -&gt; next)&#123;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow -&gt; next = slow -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h3><h4 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><blockquote><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong>k = 2</strong>.</p></blockquote><blockquote><p>返回链表 <strong>4-&gt;5</strong>.</p></blockquote><h5 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h5><p>与上面思路相同，使用快慢指针同步移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">getKthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; fast != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol><li>先得到链表<code>head</code>的长度<code>len</code> –&gt; 用来动态申请数组<code>returnArray</code></li><li>遍历链表，把其中的元素赋值给数组<code>returnArray</code></li><li>数组内部进行逆置</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, i=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">int</span> *returnArray = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        returnArray[i++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = returnArray[i];</span><br><span class="line">        returnArray[i] = returnArray[len - i - <span class="number">1</span>];</span><br><span class="line">        returnArray[len - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    (*returnSize) = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;19. Remove Nth Node From End of List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>有序循环数组查找值</title>
    <link href="http://0202zc.github.io/2020/02/12/algorithm/algorithm-ordering-and-circulate/"/>
    <id>http://0202zc.github.io/2020/02/12/algorithm/algorithm-ordering-and-circulate/</id>
    <published>2020-02-12T06:01:34.000Z</published>
    <updated>2020-02-12T06:40:00.936Z</updated>
    
    <content type="html"><![CDATA[<p>有序循环数组查找<strong>指定值</strong><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个有序循环数组array[]，不知其升序还是降序，也不知其起点在哪里。请编程寻找指定元素。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先通过中间值和最后一个或者第一个元素比较，找出局部有序范围，再通过<strong>二分查找</strong>局部有序段</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sortArrFindOne</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == target)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; arr[high]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target &amp;&amp; target &lt;= arr[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(arr, mid, high, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArrFindOne(arr, low, mid, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] &lt;= target &amp;&amp; target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(arr, low, mid, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArrFindOne(arr, mid, high, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>找局部有序（二分递归查找）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span>  + low;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(arr, mid + <span class="number">1</span>, high, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(arr, low, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有序循环数组查找&lt;strong&gt;指定值&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>反转字符串中的单词 III</title>
    <link href="http://0202zc.github.io/2020/02/10/algorithm/algorithm-reverse-words-in-a-string-iii/"/>
    <id>http://0202zc.github.io/2020/02/10/algorithm/algorithm-reverse-words-in-a-string-iii/</id>
    <published>2020-02-10T11:08:43.000Z</published>
    <updated>2020-02-10T12:26:24.900Z</updated>
    
    <content type="html"><![CDATA[<p>From LeetCode <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii" target="_blank" rel="noopener">557. Reverse Words in a String III</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: “Let’s take LeetCode contest”<br>输出: “s’teL ekat edoCteeL tsetnoc”<br><strong>注意：</strong>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h4><p>第一眼看上去是反转字符串，而反转字符串的形式有所不同——并不是整体反转，而是单个单词进行反转，所有单词相对位置不变。<br>(我第一次提交的时候没有注意到，因此有了以下代码)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">    temp = s[i];</span><br><span class="line">    s[i] = s[len-i<span class="number">-1</span>];</span><br><span class="line">    s[len-i<span class="number">-1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此代码是反转整个字符串，与线性表的反转类似【见<a href="https://0202zc.github.io/2020/01/18/algorithm-reverse-linerlist/">就地逆置线性表元素</a>】</p><blockquote><p>输入：”Let’s take LeetCode contest”<br>输出：<font color="#CD5C5C">“tsetnoc edoCteeL ekat s’teL”</font><br>预期：<font color="#008000">“s’teL ekat edoCteeL tsetnoc”</font></p></blockquote><h4 id="正确解题思路"><a href="#正确解题思路" class="headerlink" title="正确解题思路"></a>正确解题思路</h4><ul><li>记录s的长度len</li><li>若s为空或只有一个字符，则直接返回</li><li>否则<ul><li>使用r记录翻转后的字符串，用start指向每一个单词的第一个字母，end指向该单词的最后一个字符（遇到空格或者结束符就停下）</li><li>将start到end之间的字符复制到r中</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>来源：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/cyu-yan-by-kdurant/" target="_blank" rel="noopener">LeetCode - kdurant</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> || len == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * r = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="keyword">char</span> *start = s, *end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++, s++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">' '</span> || *s == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(end = s - <span class="number">1</span>; end &gt;= start; end--)&#123;</span><br><span class="line">                r[index++] = *end;</span><br><span class="line">            &#125;</span><br><span class="line">            r[index++] = (*s == <span class="string">' '</span>) ? <span class="string">' '</span> : (*s = <span class="string">'\0'</span>);</span><br><span class="line">            start = s + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(n)$, 空间复杂度$O(n)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string-iii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;557. Reverse Words in a String III&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://0202zc.github.io/2020/02/09/algorithm/algorithm-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://0202zc.github.io/2020/02/09/algorithm/algorithm-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2020-02-09T03:10:32.000Z</published>
    <updated>2020-03-27T02:52:24.573Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 3. Longest Substring Without Repeating Characters<br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<br><strong>示例 1:</strong></p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题主要用到思路是：滑动窗口</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 <code>abcabcbb</code>，进入这个队列（窗口）为 <code>abc</code> 满足题目要求，当再进入 <code>a</code>，队列变成了 <code>abca</code>，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p>时间复杂度：$O(n)$</p><p><img data-src="https://pic.leetcode-cn.com/d7a5c09ca134fed8250408fb1bbde0032ae4ecc45a1be3133e5c1855bcb2bbe7-1.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/c94cc222f6d272a20c72e9eb23bf664f8967f38bd6c53d0b396c82e2951b27b5-2.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/c10a1b15727ca49bf991690c40eb5db94a9199a81a8162f86a7f0f283ad8198b-3.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/d5aba4bfea1d0b0d6fc31fb6cefd8b2e5489bcf7e1b77b81cc74cea3ec7c5853-4.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/215d944bde59087836aa4f5aad4514177fd1acc9707386413e40678a8406262e-5.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/3acbd78605394f8dbf3ce96f25867e73851837224ef65596ad354500b0e3a181-6.jpg" alt=""></p><p><em>图片来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-cshi-xian-/" target="_blank" rel="noopener">无重复字符的最长子串 c++实现三种解法 多重循环，hashmap优化，桶优化</a></em></p><h4 id="滑动窗口题目"><a href="#滑动窗口题目" class="headerlink" title="滑动窗口题目"></a>滑动窗口题目</h4><ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank">30. 串联所有单词的子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. 至多包含两个不同字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank">239. 滑动窗口最大值</a></li><li><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range/" target="_blank">632. 最小区间</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-subsequence/" target="_blank">727. 最小窗口子序列</a></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j, k, max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//j 作为外部循环变量，遍历字符串的每一个元素</span></span><br><span class="line">    <span class="comment">//i 初始指向当前检测到的重复元素的下一个元素索引</span></span><br><span class="line">    <span class="comment">//k 用于遍历从 i 到 j 的子串</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = i; k &lt; j; k++)</span><br><span class="line">            <span class="keyword">if</span>(s[k] == s[j]) &#123;</span><br><span class="line">                i = k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; max)</span><br><span class="line">            max = j - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 3. Longest Substring Without Repeating Characters&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>操作系统、计算机网络、数据库系统概论等相关问题</title>
    <link href="http://0202zc.github.io/2020/02/05/os-network-db-questions/"/>
    <id>http://0202zc.github.io/2020/02/05/os-network-db-questions/</id>
    <published>2020-02-05T02:33:46.000Z</published>
    <updated>2020-03-17T02:42:48.677Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统、计算机网络、数据库系统概论等相关问题<br><a id="more"></a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="1-中断和陷入有什么异同？"><a href="#1-中断和陷入有什么异同？" class="headerlink" title="1. 中断和陷入有什么异同？"></a>1. 中断和陷入有什么异同？</h3><ol><li>外中断时指来自处理机和内存外部的中断，如I/O中断、定时器中断、外部信号中断等。狭义上也叫中断；</li><li>内中断主要指在处理机和内存内部产生的中断，也称陷入，如校验错、页面失效、溢出、除数为零等；</li><li>中断和陷阱的主要区别：<br>  (1) 陷入通常由处理机正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。<br>  (2) 陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。<br>  (3) CPU 在执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应陷阱。</li></ol><h3 id="2-父子进程是否可以并发运行？"><a href="#2-父子进程是否可以并发运行？" class="headerlink" title="2. 父子进程是否可以并发运行？"></a>2. 父子进程是否可以并发运行？</h3><p>可以</p><h3 id="3-在没有程序运行时，-CPU在做什么？"><a href="#3-在没有程序运行时，-CPU在做什么？" class="headerlink" title="3. 在没有程序运行时， CPU在做什么？"></a>3. 在没有程序运行时， CPU在做什么？</h3><p>只要计算机打开着，CPU 一定都在不停处理进程。在 Windows 系统下至少 rundll32.exe 这个程序是持续运行的。在 Linux 下 kernel 也是会持续运行的。运行进程个数为零的时候有没有呢？有，那就是计算机关机的时候。</p><h3 id="4-设备驱动器是否属于操作系统，它的作用是什么？"><a href="#4-设备驱动器是否属于操作系统，它的作用是什么？" class="headerlink" title="4. 设备驱动器是否属于操作系统，它的作用是什么？"></a>4. 设备驱动器是否属于操作系统，它的作用是什么？</h3><p>不是，驱动程序是另外安装的软件，是操作系统控制并且和硬件之间通讯的桥梁（程序）</p><h3 id="5-线程、进程、程序和任务的区别？"><a href="#5-线程、进程、程序和任务的区别？" class="headerlink" title="5. 线程、进程、程序和任务的区别？"></a>5. 线程、进程、程序和任务的区别？</h3><ol><li>任务是最抽象的， 是一个一般性的术语， 指<u>由软件完成的一个活动</u>。一个任务既可以是一个进程，也可以是一个线程。简而言之，它指的是一系列共同达到某一目的的操  作。例如，读取数据并将数据放入内存中。这个任务可以作为一个进程来实现，也可以作为一个线程（或作为一个中断任务）来实现。   </li><li>进程常常被定义为程序的执行。可以把一个进程看成是一个<u>独立的程序</u>，在内存中有其完备的数据空间和代码空间。<strong>一个进程所拥有的数据和变量只属于它自己</strong>。  </li><li>线程则是某一进程中一路单独运行的程序。也就是说，线程存在于进程之中。一个进程由一个或多个线程构成，各线程共享相同的代码和全局数据，<strong>但各有其自己的堆栈</strong>。由于堆栈是每个线程一个，所以<strong>局部变量对每一线程来说是私有的</strong>。由于所有线程共享同样的代码和全局数据，它们比进程更紧密，比单独的进程间更趋向于相互作用，线程间的相互作用更容易些，因为它们本身就有某些供通信用的共享内存：进程的全局数据进程的全局数据进程的全局数据进程的全局数据。</li><li>程序只是<u>一组指令的有序集合</u>，它本身没有任何运行的含义，它只是一个静态的实体。</li></ol><h3 id="6-处理中断的过程"><a href="#6-处理中断的过程" class="headerlink" title="6. 处理中断的过程"></a>6. 处理中断的过程</h3><p>请求中断 → 响应中断 → 关闭中断 → 保留断点 → 中断源识别 → 保护现场 → 中断服务子程序 → 恢复现场 → 中断返回</p><h3 id="7-分页、分段、段页式的特点，为什么要引入？"><a href="#7-分页、分段、段页式的特点，为什么要引入？" class="headerlink" title="7. 分页、分段、段页式的特点，为什么要引入？"></a>7. 分页、分段、段页式的特点，为什么要引入？</h3><ul><li>分页是为了提高内存的<strong>利用率</strong>，提高计算机性能，且分页通过<strong>硬件机制</strong>来实现，对用户完全透明。</li><li>分段是为了<strong>方便编程</strong>，信息保护和共享、动态增长及动态链接等多方面的需要。</li><li>段页式是两者的<strong>结合</strong>。</li></ul><h3 id="8-计算机系统怎样实现存储保护？"><a href="#8-计算机系统怎样实现存储保护？" class="headerlink" title="8. 计算机系统怎样实现存储保护？"></a>8. 计算机系统怎样实现存储保护？</h3><ol><li>防止地址<strong>越界</strong>（对进程所产生的地址必须加以检查，发生越界时产生中断，由操作系统<br>进行相应处理）</li><li>防止操作<strong>越权</strong>（对属于自己区域的信息，可读可写：对公共区域中允许共享的信息或获得授权可使用的信息，可读而不可修改；对未授权使用的信息，不可读，不可写）</li></ol><h3 id="9-MMU"><a href="#9-MMU" class="headerlink" title="9. MMU"></a>9. MMU</h3><p>   MMU 是 Memory Management Unit 的缩写，中文名是<strong>内存管理单元</strong>，它是中央处理器（CPU）中用来</p><ul><li>①管理虚拟存储器、物理存储器的控制线路，</li><li>②同时也负责虚拟地址映射为物理地址，</li><li>③以及提供硬件机制的内存访问授权。</li></ul><h3 id="10-多线程，真的提高了效率吗？"><a href="#10-多线程，真的提高了效率吗？" class="headerlink" title="10. 多线程，真的提高了效率吗？"></a>10. 多线程，真的提高了效率吗？</h3><p>多线程效率，我认为未必会高，而且有时候相反会低。<br>多线程并不是为了提高效率，而是不必等待，可以<strong>并行执行</strong>多条数据。 </p><ul><li>可以这么想：我们通过 xp 系统复制文件。你可以复制一份文件 —— 这叫是单线程。但是你要等这个复制完了才能复制另一份文件，而且不能多复制，这样很难受。所以你可以选择多复制文件，这就是多线程。但复制多份文件用的时间未必会比一份一份文件所用时间少。只是它合理利用了时间进行了多个操作。 </li><li>如果是买票系统，就会用到多线程。买票是同时进行的，如果一个用户一个用户等下去不是办法，所以可以多个用户同时买票，效率也就提高了。这里的效率不是执行的效率  而是时间的合理利用，多个线程同时进行。</li></ul><h3 id="11-中断的作用"><a href="#11-中断的作用" class="headerlink" title="11. 中断的作用"></a>11. 中断的作用</h3><p>中断是计算机系统结构一个重要的组成部分。在中断机制中的硬件部分(中断装置)的作用就是<strong>在 CPU 每执行完一条指令后，判别是否有事件发生</strong>。如果没有事件发生，CPU继续执行；若有事件发生，中断装置①<strong>中断</strong>原先占用 CPU 的程序的执行，②把被中断程序的<strong>断点保存</strong>起来，③让操作系统的处理服务程序占用 CPU 对事件进行<strong>处理</strong>，④处理完后，再让被中断的程序<strong>继续</strong>占用 CPU 执行下去。</p><h3 id="12-DMA-的优先级为什么比-CPU-的优先级高？"><a href="#12-DMA-的优先级为什么比-CPU-的优先级高？" class="headerlink" title="12. DMA 的优先级为什么比 CPU 的优先级高？"></a>12. DMA 的优先级为什么比 CPU 的优先级高？</h3><p>因为 DMA 请求得不到<strong>及时响应</strong>，I/O 传输数据可能会丢失。</p><h3 id="13-虚拟内存容量由什么决定？"><a href="#13-虚拟内存容量由什么决定？" class="headerlink" title="13. 虚拟内存容量由什么决定？"></a>13. 虚拟内存容量由什么决定？</h3><p>虚拟存储区的容量与物理主存大小无关，而受限于<strong>计算机的地址结构和可用磁盘容量</strong>。</p><h3 id="14-RAID-的工作原理"><a href="#14-RAID-的工作原理" class="headerlink" title="14. RAID 的工作原理"></a>14. RAID 的工作原理</h3><ul><li>RAID（独立磁盘冗余阵列（Redundant Array of Independent Disks））通过条带化存储和奇偶校验两个措施来实现其冗余和容错的目标。条带化存储意味着<strong>可以一次写入一个数据块的方式将文件写入多个磁盘</strong>。条带化存储技术<strong>将数据分开写入多个驱动器</strong>，从而提高数据传输速率并缩短磁盘处理总时间。这种系统非常<u>适用于交易处理、但可靠性却很差</u>，因为系统的可靠性等于最差的单个驱动器的可靠性 <em>【木桶效应】</em>。</li><li>奇偶校验通过在传输后对所有数据进行冗余校验可以确保数据的<strong>有效性</strong>。利用奇偶校验，当 RAID 系统的一个磁盘发生故障时，其它磁盘能够重建该故障磁盘。在这两种情况中，这些功能对于操作系统都是透明的。由磁盘阵列控制器（DAC）进行条带化存储和奇偶校验控制。</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-计算机网络和分布式计算机系统的区别？"><a href="#1-计算机网络和分布式计算机系统的区别？" class="headerlink" title="1. 计算机网络和分布式计算机系统的区别？"></a>1. 计算机网络和分布式计算机系统的区别？</h3><p>两者在计算机硬件连接、系统拓朴结构和通信控制等方面基本都是一样的，它们都具有<strong>通信</strong>和<strong>资源共享</strong>的功能。<br>区别关键在于：</p><ul><li>分布式计算机系统是在分布式计算机操作系统支持下，进行分布式数据库处理的，也就是说各互联的计算机可以<strong>互相协调工作</strong>，共同完成一项任务，多台计算机上<strong>并行</strong>运行，且具有<strong>透明性</strong>——用户不知道数据、资源的具体位置，整个网络中所有计算机就像是一台计算机一样；</li><li>而计算机网络却不具备这种功能，计算机网络系统中的各计算机通常是各自<strong>独立</strong>进行工作的。</li></ul><h3 id="2-波特和比特的区别？"><a href="#2-波特和比特的区别？" class="headerlink" title="2. 波特和比特的区别？"></a>2. 波特和比特的区别？</h3><ul><li>波特是<strong>码元传输的速率单位</strong>，说明每秒传多少个码元。码元传输速率也称为码元速率、调制速率、波形速率或符号速率。</li><li>比特是<strong>信息量的单位</strong>，与码元的传输速率“波特”是两个完全不同的概念。</li></ul><p>但是，信息的传输速率“比特/秒”与码元的传输速率“波特”在数量上却有一定的关系。</p><h3 id="3-TCP-IP网络协议核心以及如何引出over-everything"><a href="#3-TCP-IP网络协议核心以及如何引出over-everything" class="headerlink" title="3. TCP/IP网络协议核心以及如何引出over everything"></a>3. TCP/IP网络协议核心以及如何引出over everything</h3><p>TCP/IP（传输控制协议/网间协议）是一种网络通信协议，它规范了网络上的所有通信设备，尤其是一个主机与另一个主机之间的数据往来格式以及传送方式。TCP/IP是INTERNET的基础协议，也是一种电脑数据打包和寻址的标准方法。<br>核心是OSI模型，共七层：第 7 层应用层，第 6 层表示层，第 5 层会话层，第 4 层传输层，第 3 层网络层，第 2 层数据链路层，第 1 层物理层，从第七层传到第一层，接受方则相反。上三层总称应用层，用来控制软件方面。下四层总称数据流层，用来管理硬件。 </p><blockquote><p>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>链路层<br>物理层</p></blockquote><p>everything over IP：everything 均以 IP 为基础，以后的网络中的设备都用 IP（现在的电话网络就不是）。【over：以…为基础】<br>IP over everything：在现在的电通信网过渡到光通信网的过程中，IP、ATM、WDM 会配合使用，渐渐过渡，即是 IP over everything。【over：凌驾于…之上】</p><h3 id="4-电路交换与分组交换区别"><a href="#4-电路交换与分组交换区别" class="headerlink" title="4. 电路交换与分组交换区别"></a>4. 电路交换与分组交换区别</h3><ol><li><p>电路交换是以<strong>电路</strong>为目的的交换方式，即通信双方要通过电路建立联系，建立后没挂断则电路一直保持，实时性高。</p><p>而分组交换是把信息分为若干<strong>分组</strong>，每个分组有分组头含有选路和控制信息，可以到达收信方，但是不能即时通信。</p></li><li><p>分组交换通信双方不是固定占有一条通信线路，而是在<strong>不同的时间</strong>一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。</p><p>电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。</p></li><li><p>分组交换由于数据进入交换结点后要经历<strong>存储</strong>、<strong>转发</strong>这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量越大，造成的时延就越大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。</p><p>电路交换连接建立后，物理通路被通信双方<strong>独占</strong>，即使通信线路空闲，也不能供其他用户使用，因而<strong>信道利用率低</strong>。</p><p>若要传送的<strong>数据量很大</strong>，且其传送时间远大于呼叫时间，则采用<u>电路交换</u>较为合适；<br>当端到端的通路有<strong>很多段的链路</strong>组成时，采用<u>分组交换</u>传送数据较为合适；<br>从提高整个网络的<strong>信道利用率</strong>上看，<u>报文交换</u>和<u>分组交换</u>优于电路交换，其中<u>分组交换</u>比报文交换的<strong>时延小</strong>，尤其适合于计算机之间的<strong>突发式的数据通信</strong>。</p></li></ol><h3 id="5-IPv4-和-IPv6-的区别"><a href="#5-IPv4-和-IPv6-的区别" class="headerlink" title="5. IPv4 和 IPv6 的区别"></a>5. IPv4 和 IPv6 的区别</h3><ol><li>IPv6 地址长度为 $128$ bit，地址增大了 $296$ 倍；</li><li>灵活的 IP 报文头部格式。使用一系列固定格式的扩展头部取代了 IPv4 中可变长度的选项字段。IPv6 中选项部分的出现方式也有所变化，使路由器可以简单路过选项而不做任何处理，加快了报文<strong>处理速度</strong>；</li><li>IPv6 简化了报文头部格式，字段只有 $7$ 个，加快报文转发，提高了<strong>吞吐量</strong>；</li><li>提高<strong>安全性</strong>。身份认证和隐私权是 IPv6 的关键特性；</li><li>支持更多的服务类型；</li><li>允许协议继续演变，增加新的功能，使之适应未来技术的发展。</li></ol><h3 id="6-TCP-的拥塞控制与流量控制的功能和区别？"><a href="#6-TCP-的拥塞控制与流量控制的功能和区别？" class="headerlink" title="6. TCP 的拥塞控制与流量控制的功能和区别？"></a>6. TCP 的拥塞控制与流量控制的功能和区别？</h3><ol><li>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够<strong>承受现有的网络负荷</strong>。拥塞控制是一个<strong>全局性</strong>的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制：指点对点通信量的控制，是端到端的问题。流量控制所要做的就是<u>抑制发送端发送数据的速率，以便使接收端来得及接收</u>。</li></ol><h3 id="7-集线器，路由器和交换机有什么区别"><a href="#7-集线器，路由器和交换机有什么区别" class="headerlink" title="7. 集线器，路由器和交换机有什么区别."></a>7. 集线器，路由器和交换机有什么区别.</h3><p>   <strong>集线器</strong>工作在第一层（即物理层），它没有智能处理能力，对它来说，数据只是电流而已，<br>   当一个端口的电流传到集线器中时，它只是简单地将电流传送到其他端口，至于其他端口连接的计算机接收不接收这些数据，它就不管了。<br>   <strong>交换机</strong>工作在第二层（即数据链路层），它要比集线器智能一些，对它来说，网络上的数据就是 MAC 地址的集合，它能分辨出帧中的源 MAC 地址和目的 MAC 地址，因此可以在任意两个端口间建立联系，但是交换机并不懂得 IP 地址，它只知道 MAC 地址。<br>   <strong>路由器</strong>工作在第三层（即网络层），它比交换机还要“聪明”一些，它能理解数据中的 IP 地址，如果它接收到一个数据包，就检查其中的 IP地址，如果目标地址是本地网络的就不理会，如果是其他网络的，就将数据包转发出本地网络。</p><h3 id="8-P2P-网络编程的特点"><a href="#8-P2P-网络编程的特点" class="headerlink" title="8. P2P 网络编程的特点"></a>8. P2P 网络编程的特点</h3><p>   P2P（对等网络，是一种有别于传统 C/S 客户/服务器式的分布式网络）直接将人们联系起来，让人们通过互联网直接交互。P2P 使得网络上的沟通变得容易、更直接共享和交互，真正地消除中间商。P2P 就是人可以直接连接到其他用户的计算机、交换文件，而不是像过去那样连接到服务器去浏览与下载。</p><h3 id="9-DNS-的递归查询与迭代查询"><a href="#9-DNS-的递归查询与迭代查询" class="headerlink" title="9. DNS 的递归查询与迭代查询"></a>9. DNS 的递归查询与迭代查询</h3><ol><li>递归查询：<br>  一般<strong>客户机和服务器之间</strong>属递归查询，即当客户机向 DNS 服务器发出请求后，若 DNS 服务器本身不能解析，则会向另外的 DNS 服务器发出查询请求，得到结果后转交给客户机。</li><li>迭代查询(反复查询)：<br>  一般 <strong>DNS 服务器之间</strong>属迭代查询，如：若 DNS2 不能响应 DNS1 的请求，则它会将 DNS3 的 IP 给 DNS2，以便其再向 DNS3 发出请求。</li></ol><h3 id="10-ARP-协议的过程"><a href="#10-ARP-协议的过程" class="headerlink" title="10. ARP 协议的过程"></a>10. ARP 协议的过程</h3><p>   ARP 协议是“Address Resolution Protocol”（地址解析协议）的缩写。在局域网中，网络中实际传输的是“<strong>帧</strong>”，帧里面是有目标主机的 MAC 地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的 MAC 地址。但这个目标 MAC 地址是如何获得的呢？它就是通过地址解析协议 ARP 获得的。所谓“地址解析”就是主机在发送帧<strong>前</strong>将目标 IP 地址转换成目标 MAC 地址的过程。 ARP 协议的基本功能就是<strong>通过目标设备的 IP 地址，查询目标设备的 MAC 地址</strong>，以保证通信的顺利进行。</p><h3 id="11-计算机网络的接入类型都有哪些？"><a href="#11-计算机网络的接入类型都有哪些？" class="headerlink" title="11. 计算机网络的接入类型都有哪些？"></a>11. 计算机网络的接入类型都有哪些？</h3><p>   局域网、城域网、广域网和互联网四种</p><h3 id="12-中继器，集线器，交换机，网桥，网关，路由器的功能作用，区别到底是什么？"><a href="#12-中继器，集线器，交换机，网桥，网关，路由器的功能作用，区别到底是什么？" class="headerlink" title="12. 中继器，集线器，交换机，网桥，网关，路由器的功能作用，区别到底是什么？"></a>12. 中继器，集线器，交换机，网桥，网关，路由器的功能作用，区别到底是什么？</h3><p>   <img data-src="https://img-blog.csdn.net/20160430230505309" alt=""></p><ol><li><p>物理层：<strong>中继器（Repeater）</strong>和<strong>集线器（Hub）</strong>。用于连接物理特性相同的网段，这些网段，只是位置不同而已。Hub 的端口没有物理和逻辑地址。</p></li><li><p>逻辑链路层：<strong>网桥（Bridge）</strong>和<strong>交换机（Switch）</strong>。用于连接同一逻辑网络中、物理层规范不同的网段，这些网段的拓扑结构和其上的数据帧格式，都可以不同。Bridge和Switch的端口具有物理地址，但没有逻辑地址。</p></li><li><p>网络层：<strong>路由器（Router）</strong>。用于连接不同的逻辑网络。Router的每一个端口都有唯一的物理地址和逻辑地址。</p></li><li><p>应用层：<strong>网关（Gateway）</strong>。用于互连网络上，使用不同协议的应用程序之间的数据通信，目前尚无硬件产品。</p></li></ol><ul><li>中继器：物理层， 适用于完全相同的两类网络的互连，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。</li><li><p>集线器：物理层，基本功能信息分发，它把一个端口接收的所有信号向所有端口分发出去。一些集线器在分发之前将弱信号重新生成。</p><p>中继器与集线器的区别：区别在于<strong>集线器能够提供多端口服务</strong>，也称为多口中继器。</p></li><li><p>网桥：数据链路层， 网桥（Bridge）像一个聪明的中继器， 网桥是一种对帧进行转发的技术，根据 MAC 分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来。【将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”。】</p></li><li><p>交换机：数据链路层，是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。可以理解为高级的网桥，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：交换机常常用来连接独立的计算机，而网桥连接的目标是 LAN，所以交换机的端口较网桥多。</p></li><li><p>路由器：网络层，用于连接多个逻辑上分开的网络，几个使用不同协议和体系结构的网络；具有判断网络地址和选择路径的功能，过滤和分隔网络信息流。路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效地传送到目的站点。 路由器的基本功能是，把数据（IP报文）传送到正确的网络。</p></li><li><p>网关：网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于广域网互连，也可以用于局域网互连。 通过字面意思解释就是网络的关口。从技术角度来解释，就是连接两个不同网络的接口，比如局域网的共享上网服务器就是局域网和广域网的接口。</p><p>来源：<a href="https://blog.csdn.net/qq_25606103/article/details/51288459?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">中继器、集线器、网桥、交换机、路由器、网关的超全总结</a></p></li></ul><h2 id="数据库系统概论"><a href="#数据库系统概论" class="headerlink" title="数据库系统概论"></a>数据库系统概论</h2><h3 id="1-数据库安全性与操作系统安全性的关系？"><a href="#1-数据库安全性与操作系统安全性的关系？" class="headerlink" title="1. 数据库安全性与操作系统安全性的关系？"></a>1. 数据库安全性与操作系统安全性的关系？</h3><p>安全性问题不是数据库系统所独有的，所有计算机系统都有这个问题。只是在数据库系统中大量<strong>数据集中存放</strong>，而且为许多最终用户直接共享，从而使安全性问题更为突出。系统安全保护措施是否有效是数据库系统的主要指标之一。数据库的安全性和计算机系统的安全性，包括操作系统，网络系统的安全性是紧密联系、相互支持的。</p><h3 id="2-SQL-主键约束和唯一约束有什么区别呢？"><a href="#2-SQL-主键约束和唯一约束有什么区别呢？" class="headerlink" title="2. SQL 主键约束和唯一约束有什么区别呢？"></a>2. SQL 主键约束和唯一约束有什么区别呢？</h3><p>主键不能为空而唯一可以为空相同的，就是都<strong>不允许重复</strong>。</p><h3 id="3-什么是基本表？什么是视图？两者的区别和联系是什么？"><a href="#3-什么是基本表？什么是视图？两者的区别和联系是什么？" class="headerlink" title="3. 什么是基本表？什么是视图？两者的区别和联系是什么？"></a>3. 什么是基本表？什么是视图？两者的区别和联系是什么？</h3><ul><li>表是实实在在得保存数据的实体，写入的数据都保存在表中；而<strong>视图是不保存数据的</strong>，也没有数据。<strong>视图就是一条语句</strong>，实际上视图从表中去数据，只是给我们的感觉好像直接从表中取得一样。</li><li>表可以建立各种触发器，可以建立索引，可以建立主健、约束等；但是视图不能建立这些对象( 视图可以建立替代触发器)。</li><li>表和视图可以更新，但是视图的更新受到约束。比如，<code>GROUP BY</code> 和表连接生成的视图不能更新表是实实在在的保存数据的实体，写入的数据都保存在表中；而视图是不保存数据的，也没有数据。</li></ul><h3 id="4-数据库索引"><a href="#4-数据库索引" class="headerlink" title="4. 数据库索引"></a>4. 数据库索引</h3><p>目的：提供多种存储路径，加快查找速度。<br>建立索引需要考虑的问题： 1. 没有查询、统计的需要则不建；2. 数据增删改频繁，系统会花费许多时间来维护索引，从而降低了查询效率。</p><h3 id="5-哪些视图是可以更新、哪些是不可以更新的"><a href="#5-哪些视图是可以更新、哪些是不可以更新的" class="headerlink" title="5. 哪些视图是可以更新、哪些是不可以更新的"></a>5. 哪些视图是可以更新、哪些是不可以更新的</h3><ol><li>简单视图<br>就是由一个表生成出来的视图，这种情况你更新她就和更新表一样。</li><li>二次加工出来的简单视图<br>仍然是一个表出来的视图，但是视图中存在通过函数或计算二次加工出来的其他字段。更新的时候只要不更新这些加工出来的字段也是可以更新的。</li><li>组合视图<br>通过表之间关联联合等出来的复杂视图。这种视图更新的时候要注意你所更新的列要来自同一个表，也是可以更新的。</li><li>静态视图<br>这种视图等同于表可以直接更新，但是更新的数据尽在视图中反映出来，不反映到原表。</li><li>其他视图<br>通过表函数等其他生成的更为复杂的视图，一般不可更新。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统、计算机网络、数据库系统概论等相关问题&lt;br&gt;
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="计算机网络" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="数据库" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="操作系统" scheme="http://0202zc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OS" scheme="http://0202zc.github.io/tags/OS/"/>
    
      <category term="计算机网络" scheme="http://0202zc.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="数据库" scheme="http://0202zc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>复试英语口语</title>
    <link href="http://0202zc.github.io/2020/02/02/English-speaking-test/"/>
    <id>http://0202zc.github.io/2020/02/02/English-speaking-test/</id>
    <published>2020-02-02T10:03:15.000Z</published>
    <updated>2020-02-02T10:49:37.811Z</updated>
    
    <content type="html"><![CDATA[<p>~2020.02.02~<br><a id="more"></a></p><h4 id="1-self-introduction-自我介绍"><a href="#1-self-introduction-自我介绍" class="headerlink" title="(1). self-introduction (自我介绍)"></a>(1). self-introduction (自我介绍)</h4><p>Good morning, my dear teachers and professors. I am very happy to introduce myself. I am 陈琪, a 22-year-old boy graduated from <u>Chongqing University of Posts and Telecommunications</u>. My major was <u>Computer Science and Technology</u>. And I am very kind-hearted as well and ready to help others especially when they are in troubles. Owing to my kindness I made a lot of friends in university. In my spare time I like sports such as Ping-pong .I also took some part-time jobs as a family tutor. One of my students got his mark improved through our joint effort and I was very proud of that.This is all for my self-introduction. If I am lucky enough to get the chance, I will devote all myself to my major and focus all of my energy on it.</p><h4 id="2-reasons-for-my-choice-考研原因"><a href="#2-reasons-for-my-choice-考研原因" class="headerlink" title="(2). reasons for my choice (考研原因)"></a>(2). reasons for my choice (考研原因)</h4><p>Firstly, I think my major is very <strong>practical and useful</strong>. Through four years’study in university I find the knowledge I have <strong>mastered</strong> is not enough to <strong>solve some specific problems</strong>. So I decide to further my education.<br>Secondly,I can broaden my horizon and enrich the knowledge in this field through the postgraduate education. It is an indispensable step for my self-development in the future as well. </p><h4 id="3-plans-in-the-postgraduate-study-研究生期间你的计划"><a href="#3-plans-in-the-postgraduate-study-研究生期间你的计划" class="headerlink" title="(3). plans in the postgraduate study (研究生期间你的计划)"></a>(3). plans in the postgraduate study (研究生期间你的计划)</h4><p>Because my dream is to be a scientist , so i want to further my study when i become postgraduate. May be i will be a teacher in the university  at first.That’s my simple plan.</p><h4 id="4-about-hometown-介绍你的家乡"><a href="#4-about-hometown-介绍你的家乡" class="headerlink" title="(4). about hometown (介绍你的家乡)"></a>(4). about hometown (介绍你的家乡)</h4><p>I come from ZiGong of Sichuan province,which is famous for its salt industry and dinosaur fossils.<br>Known as home of dinosaur. What’s more? It is also a city of lights. Every year,there are a lot of tourist traveling here.</p><h4 id="5-about-family-你的家庭"><a href="#5-about-family-你的家庭" class="headerlink" title="(5). about family (你的家庭)"></a>(5). about family (你的家庭)</h4><p>I have a happy family .In my family, there are five members: grandfather, father, mother.My family is just like a hand, and each of us like a finger.<br>Mother worker, Father teacher. They love me ,we live harmoniously.</p><h4 id="6-about-university-你的大学"><a href="#6-about-university-你的大学" class="headerlink" title="(6). about university (你的大学)"></a>(6). about university (你的大学)</h4><p>My university is Chongqing university of Post and Telecommunication .it has digital libraries and labs. My university is famous for its 3G research and it is located in a small mountain which is beautiful and full of cherry blossom.There a fresh airs and warm atmosphere.</p><h4 id="7-plans-after-graduation-毕业后有什么打算"><a href="#7-plans-after-graduation-毕业后有什么打算" class="headerlink" title="(7). plans after graduation (毕业后有什么打算)"></a>(7). plans after graduation (毕业后有什么打算)</h4><p>After my graduation, I want to find a job in Chengdu and make good use of the theories I will have learned from this university.I want to become a teacher of university or a scientist .if possible ,After graduation, I want to further my study for a Doctor’s degree. Then I’ll work for a research institute. What satisfies me most is to make contributions for the whole earth.</p><h4 id="8-What-is-your-greatest-strength-你最突出的优点是什么？"><a href="#8-What-is-your-greatest-strength-你最突出的优点是什么？" class="headerlink" title="(8).What is your greatest strength? (你最突出的优点是什么？)"></a>(8).What is your greatest strength? (你最突出的优点是什么？)</h4><p>I am good at math and programming, because i can solve a problem by myself independent and improve in a short time without others’ help.</p><h4 id="要求重复询问"><a href="#要求重复询问" class="headerlink" title="要求重复询问"></a>要求重复询问</h4><p>Sorry, I did not catch/follow your meaning. Pardon, please.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;~2020.02.02~&lt;br&gt;
    
    </summary>
    
      <category term="English" scheme="http://0202zc.github.io/categories/English/"/>
    
    
      <category term="English" scheme="http://0202zc.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>C语言中变量存储位置</title>
    <link href="http://0202zc.github.io/2020/02/01/C-variable-storage-2/"/>
    <id>http://0202zc.github.io/2020/02/01/C-variable-storage-2/</id>
    <published>2020-02-01T06:28:06.000Z</published>
    <updated>2020-02-01T06:44:12.011Z</updated>
    
    <content type="html"><![CDATA[<p>局部变量、静态局部变量、静态全局变量…<br><a id="more"></a></p><h3 id="一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？"><a href="#一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？" class="headerlink" title="一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？"></a>一、C语言中，常量存储在哪儿？<code>static</code>全局变量和<code>static</code>局部变量存储在哪儿？</h3><p>全局变量（外部变量）的说明之前再冠以<code>static</code>就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于</p><blockquote><p><strong>非静态全局变量的作用域是整个源程序，</strong><br><strong>当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的，</strong><br><strong>而静态全局变量则限制了其作用域。</strong><br><strong>即只在定义该变量的源文件内有效，</strong></p></blockquote><p>在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</p><h3 id="二、static全局变量与普通的全局变量有什么区别？"><a href="#二、static全局变量与普通的全局变量有什么区别？" class="headerlink" title="二、static全局变量与普通的全局变量有什么区别？"></a>二、<code>static</code>全局变量与普通的全局变量有什么区别？</h3><ul><li><strong><code>static</code>全局变量只初始化一次</strong>，防止在其他文件单元中被是引用。</li></ul><h3 id="三、static局部变量与普通的局部变量有什么区别？"><a href="#三、static局部变量与普通的局部变量有什么区别？" class="headerlink" title="三、static局部变量与普通的局部变量有什么区别？"></a>三、<code>static</code>局部变量与普通的局部变量有什么区别？</h3><ul><li><strong><code>static</code>局部变量只被初始化一次</strong>，下一次依据上一次结果值。</li></ul><h3 id="四、局部变量、静态局部变量、静态全局变量存储位置"><a href="#四、局部变量、静态局部变量、静态全局变量存储位置" class="headerlink" title="四、局部变量、静态局部变量、静态全局变量存储位置"></a>四、局部变量、静态局部变量、静态全局变量存储位置</h3><table><thead><tr><th>变量类型</th><th>存储位置</th></tr></thead><tbody><tr><td>局部变量</td><td>静态区（全局区）</td></tr><tr><td>局部静态变量</td><td>静态区（全局区）的常量区</td></tr><tr><td>全局静态变量</td><td>静态区（全局区）</td></tr></tbody></table><h3 id="五、各存储区的定义"><a href="#五、各存储区的定义" class="headerlink" title="五、各存储区的定义"></a>五、各存储区的定义</h3><ol><li><p><strong>栈区（stack）</strong> —— 由编译器自动分配释放，存放<u>函数的参数值，局部变量的值</u>等，其操作方式类似于数据结构中的栈。</p></li><li><p><strong>堆区（heap）</strong> —— 一般由程序员分配释放。若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p></li><li><p><strong>全局区（静态区）（static）</strong> —— <u>全局变零和静态变量</u>的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，- <em>程序结束后由系统释放</em>。</p></li><li><p><strong>文字常量区</strong> —— <u>常量字符串</u>就是放在这里的。- <em>程序结束后由系统释放</em>。</p></li><li><p><strong>程序代码区</strong> —— <u>存放函数体的二进制代码</u>。</p></li></ol><h3 id="六、NOTES"><a href="#六、NOTES" class="headerlink" title="六、NOTES"></a>六、NOTES</h3><ol><li><p><strong>栈</strong>，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。</p></li><li><p><strong>堆</strong>，就是那些由<code>new</code>分配的内存块，他们的释放编译器不去管，由应用程序控制，一般一个<code>new</code>就要对应一个<code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p></li><li><p><strong>自由存储区</strong>，就是那些由<code>malloc</code>分配的内存块，它和堆十分相似，不过它是用<code>free</code>来结束自己的生命。</p></li><li><p><strong>全局/静态存储区</strong>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，<em>在C++里面没有这个区分</em>，它们共同占用一块内存区。</p></li><li><p><strong>常量存储区</strong>，这是一块比较特殊的存储区，它们存放的是常量，<strong>不允许被修改</strong>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;局部变量、静态局部变量、静态全局变量…&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C语言效率问题</title>
    <link href="http://0202zc.github.io/2020/01/31/C-efficiency/"/>
    <id>http://0202zc.github.io/2020/01/31/C-efficiency/</id>
    <published>2020-01-31T15:13:35.000Z</published>
    <updated>2020-04-08T11:22:27.135Z</updated>
    
    <content type="html"><![CDATA[<p>来源：UESTC考研群<br><a id="more"></a></p><ul><li><p>编译器可以将代码编译为汇编语言，然后转换为机器语言，并且编译器可以在编译时进行优化，例如gcc可以进行五级优化</p></li><li><p>采用宏去定义一些函数，提高效率 比如#define MAX(x,y) ((x)&gt;(y)?(x):(y))</p></li><li><p>可以使用位操作来替代乘法除法 比如计算机网络中进行CRC检验</p></li><li><p>可以在程序效率低的地方嵌入汇编语言提高程序效率</p></li><li><p>可以使用指针直接操作内存，提高效率</p></li><li><p>可以使用内联函数（C99标准添加，之前宏定义）</p></li><li><p>可以使用寄存器变量（register），提高变量存取速度</p></li><li><p>复合的赋值运算符的使用，比如i -= 1效率大于i = i - 1，可以提高程序的编译效率</p></li><li><p>自增自减运算符的使用，比如i++和i–</p></li></ul><hr><h1 id="1-从C语言执行效率方面，简述C语言采取了哪些措施提高执行效率。"><a href="#1-从C语言执行效率方面，简述C语言采取了哪些措施提高执行效率。" class="headerlink" title="1. 从C语言执行效率方面，简述C语言采取了哪些措施提高执行效率。"></a>1. 从C语言执行效率方面，简述C语言采取了哪些措施提高执行效率。</h1><p>① 使⽤<strong>指针</strong>：有些程序⽤其他语言也可以实现，但C能够更有效地实现；有些程序⽆法⽤其它语言实现，如直接访问硬件，但C却可以。正因为指针可以拥有类似于汇编的寻址方式，所以可以使程序更高效。</p><p>② 使⽤<strong>宏函数</strong>：宏函数仅仅作为预先写好的代码嵌⼊到当前程序，不会产生函数调⽤，所以仅仅是占⽤了空间，而使程序可以高效运行。在频繁调⽤同⼀个宏函数的时候，该现象尤其突出。函数和宏函数的区别就在于，宏函数占⽤了⼤量的空间，而函数占⽤了时间。<br>宏函数的例⼦：</p><p>③ 使⽤<strong>位操作</strong>：位操作可以减少除法和取模的运算。在计算机程序中数据的位是可以操作的最⼩数据单位，理论上可以⽤”位运算”来完成所有的运算和操作。灵活的位操作可以有效地提高程序运行的效率。</p><p>④ 循环嵌套中将<strong>较长循环设为内置循环</strong>，<strong>较短循环设为外置循环</strong>，以减少CPU跨切循环层的次数，提高程序的运行效率。(操作系统页⾯置换相关，减少页⾯置换次数)</p><p>⑤ 将汇编指令嵌⼊到 C 语言程序中，汇编语言是效率最高的计算机语言，因此为了获得程序的高效率，可以在C语言程序中嵌⼊汇编，从而充分利⽤高级语言和汇编语言各⾃的特点。</p><p>⑥ 在C语言程序中可以调⽤系统API，接近底层，从而提高程序的运行效率。</p><p>⑦ ⼀般情况下,C语言源程序中的每⼀行代码。都要参加编译。但有时候出于对程序代码优化的考虑。希望只对其中⼀部分内容进行编译。此时就需要在程序中加上条件，让编译器只对满⾜条件的代码进行编译，将不满<br>⾜条件的代码舍弃，这就是条件编译</p><h1 id="2-请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。"><a href="#2-请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。" class="headerlink" title="2.请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。"></a>2.请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。</h1><blockquote><p>（注：这⾥⾯还有个⼩题，float如何四舍五⼊转化成int）</p></blockquote><p>算术运算式中，低类型能够转换为高类型。<br>赋值表达式中，右边表达式的值⾃动隐式转换为左边变量的类型，并赋值给它。<br>函数调⽤中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。<br>函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋给调⽤函数。</p><h1 id="3-数组越界会产生什么后果？"><a href="#3-数组越界会产生什么后果？" class="headerlink" title="3. 数组越界会产生什么后果？"></a>3. 数组越界会产生什么后果？</h1><p>越界访问有可能把数据放到已经存储了重要数据的内存单元，也就是改写了本来不许改写的数据，如果这个数据是系统的重要内容，有可能导致系统运行紊乱甚⾄是崩溃。当然如果这个数据并不重要，那么越界访问的后果就不明显或者是没有影响。避免的办法是对数组的下标严格检测，判断数组下标是否越界。⽤指针访问数组时要注意判断指针的指向是否已超过数组下标的最⼤值。</p><h1 id="4-值传递和地址传递"><a href="#4-值传递和地址传递" class="headerlink" title="4. 值传递和地址传递"></a>4. 值传递和地址传递</h1><p>值传递过程中，被调函数的形参作为被调函数的局部变量处理，即在内存的堆栈中开辟空间以存放由主调函数放进来的实参的值，从而成为了实参的⼀个拷贝。值传递的特点是被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。而在地址传递过程中，被调函数的形参虽然也作为局部变量在堆栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><h1 id="5-C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？"><a href="#5-C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？" class="headerlink" title="5. C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？"></a>5. C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？</h1><table><thead><tr><th>变量类型</th><th>存储区域</th></tr></thead><tbody><tr><td>常量</td><td>常量区</td></tr><tr><td>静态局部变量</td><td>全局数据区</td></tr><tr><td>静态全局变量</td><td>全局数据区</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：UESTC考研群&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
