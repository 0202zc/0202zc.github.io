<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lloyd的博客</title>
  
  <subtitle>Be unfazed by defeat.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0202zc.github.io/"/>
  <updated>2021-07-06T14:13:37.648Z</updated>
  <id>http://0202zc.github.io/</id>
  
  <author>
    <name>Lloyd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://0202zc.github.io/2021/07/06/my-subscription%20%E9%82%AE%E4%BB%B6%E8%AE%A2%E9%98%85%E8%BD%AF%E4%BB%B6/"/>
    <id>http://0202zc.github.io/2021/07/06/my-subscription 邮件订阅软件/</id>
    <published>2021-07-06T13:44:30.464Z</published>
    <updated>2021-07-06T14:13:37.648Z</updated>
    
    <content type="html"><![CDATA[<p>title: my-subscription 邮件订阅软件<br>date: 2021-07-06 22:13:36<br>tags: [SpringBoot, MyBatis, Nginx, Python, Redis]<br>categories: 项目<br>comments: true</p><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>仓库地址：<a href="https://gitee.com/kkm09/my-subscription" target="_blank" rel="noopener">https://gitee.com/kkm09/my-subscription</a></p><ul><li>业务流程：用户访问页面，提交需要订阅的内容和时间（可自行定义服务），程序调度爬虫适时进行邮件推送。</li><li>本项目采用前后端分离架构。后端业务处理基于 SpringBoot + MyBatis，爬虫基于Python编写；前端使用 Ace Admin 作为模板</li><li>使用 Redis 作为缓存</li><li>采用 Nginx 搭建服务器，托管前端代码</li><li>面向人群：<ul><li>不能及时或不想自己手动获取信息</li><li>网络上信息获取需求不能满足（例如没有现成的需求信息的推送服务）</li></ul></li></ul><h4 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h4><h5 id="Requirement"><a href="#Requirement" class="headerlink" title="Requirement"></a>Requirement</h5><ul><li><code>Java 1.8</code></li><li><code>MySQL 5.7</code></li><li><code>Nginx: latest stable version</code></li><li><code>Python 3.6</code></li><li><code>Redis: latest stable version</code></li></ul><h5 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h5><ol><li>git clone 项目 <code>my-subscription</code> 到本地</li><li>新建数据库 <code>db_mail_send</code>，选择 <code>utf8mb4</code> 编码，运行 <code>config/database/</code> 中的.sql文件进行导入</li><li>配置 Nginx，参考 <code>config/nginx/conf</code> 中的文件，将 <code>html/ace-master</code> 文件夹以移动到本地 nginx 的 <code>html</code> 目录下</li><li>配置 Redis，配置应与 <code>application.yml</code> 设置一致（自定义）</li><li>运行 Tomcat 服务器，启动项目</li><li>启动 Python 调度：控制台执行命令：<code>python (该文件所在的目录路径)/process_util.py</code></li></ol><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><ol><li>所有Python文件位于 <code>crawlers/**</code>：</li></ol><ul><li><code>stable</code> 文件夹为爬虫的稳定版本，<code>beta</code> 为测试版本，<code>beta/customize</code> 为用户自定义文件存放位置</li><li>database_util.py：数据库工具文件，注意修改登录配置信息</li><li>mail_assist.py：邮件发送工具文件，根据内容进行信息配置，需要开通smtp服务</li><li>spider_hot.py：管理员编写的爬虫文件，整合了<code>weibo_spider.py</code>（微博热搜）、<code>zhihu_spider.py</code>（知乎热搜）、<code>covid19_spider.py</code>（国内新冠疫情每日新增信息）</li><li>spider_customize.py：用户自定义爬虫调度工具文件，扫描文件的路径根据实际情况修改</li><li>process_util.py：总调度文件，在每日的8点、12点、20点启动程序，可按需修改</li></ul><ol start="2"><li><p>html/ace-master文件夹中，修改过的文件以”*-copy.html”结尾</p></li><li><p>修改后端代码（IDEA项目文件夹：MySubcription）</p><ul><li>根据个人情况修改applicaiton.yml中的内容</li><li>用户自定义上传的文件路径位于 <code>com/lzc/util/FileUtils.java</code> 的常量 <code>FILEPATH</code>，根据情况修改</li></ul></li></ol><h4 id="参与贡献"><a href="#参与贡献" class="headerlink" title="参与贡献"></a>参与贡献</h4><ol><li>Fork 本仓库</li><li>新建 dev 分支</li><li>提交代码</li><li>新建 Pull Request</li></ol><h4 id="项目展示"><a href="#项目展示" class="headerlink" title="项目展示"></a>项目展示</h4><p>服务订阅：<a href="http://106.52.58.41/form-wizard-copy.html" target="_blank" rel="noopener">http://106.52.58.41/form-wizard-copy.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;title: my-subscription 邮件订阅软件&lt;br&gt;date: 2021-07-06 22:13:36&lt;br&gt;tags: [SpringBoot, MyBatis, Nginx, Python, Redis]&lt;br&gt;categories: 项目&lt;br&gt;comm
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在线生成红黑树</title>
    <link href="http://0202zc.github.io/2020/08/02/generate-Red-Black-Tree-online/"/>
    <id>http://0202zc.github.io/2020/08/02/generate-Red-Black-Tree-online/</id>
    <published>2020-08-01T16:09:09.000Z</published>
    <updated>2020-08-01T16:09:20.923Z</updated>
    
    <content type="html"><![CDATA[<p>转载自CSDN博客<a href="https://www.cnblogs.com/bbvi/p/5576201.html" target="_blank" rel="noopener">在线生成红黑树（含变形步骤）</a><br><a id="more"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>在线生成红黑树（含变形步骤）<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>增加节点<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>方式一：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"随机增加一个节点"</span> <span class="attr">title</span>=<span class="string">"随机增加一个节点"</span> <span class="attr">onclick</span>=<span class="string">"AddRandom()"</span> /&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>方式二：<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"numbertext"</span> <span class="attr">title</span>=<span class="string">""</span> <span class="attr">placeholder</span>=<span class="string">"请用,(单字节)分割数字,0-999之间的数字"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"一个一个节点增加"</span> <span class="attr">title</span>=<span class="string">"增加一个节点"</span> <span class="attr">onclick</span>=<span class="string">"AddOneNumber()"</span> /&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>删除节点<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"deleteNumberText"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入需要删除的节点"</span> /&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"删除"</span> <span class="attr">onclick</span>=<span class="string">"DeleteNumber()"</span> /&gt;</span> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>参考：  http://www.cnblogs.com/skywang12345/p/3603935.html <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">legend</span>&gt;</span>红黑树<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"currentView"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"stepView"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--我的博客： http://www.cnblogs.com/bbvi/ --&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var NodeColor = &#123; Black: "black", Red: "red" &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var RBNode = function (_date, _paret, _color) &#123;</span></span><br><span class="line"><span class="undefined">            this.Data = _date;</span></span><br><span class="line"><span class="undefined">            this.Parent = _paret;</span></span><br><span class="line"><span class="undefined">            this.Color = _color;</span></span><br><span class="line"><span class="undefined">            this.LeftNode = null;</span></span><br><span class="line"><span class="undefined">            this.RightNode = null;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var RedBlackBinaryTree = function () &#123;</span></span><br><span class="line"><span class="undefined">            this.RootNode = null;//根节点</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.Insert = function (insertValue) &#123;</span></span><br><span class="line"><span class="undefined">                if (this.RootNode == null) &#123;</span></span><br><span class="line"><span class="undefined">                    this.RootNode = new RBNode(insertValue, null, NodeColor.Black);</span></span><br><span class="line"><span class="undefined">                &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                    var newNode = insert.call(this, insertValue);</span></span><br><span class="line"><span class="undefined">                    insertFixUp.call(this, newNode);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function insert(key) &#123;</span></span><br><span class="line"><span class="undefined">                ClearStepView();//清空分解步骤</span></span><br><span class="line"><span class="undefined">                var node = this.RootNode;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                var newNode = new RBNode(key, null, NodeColor.Red);</span></span><br><span class="line"><span class="undefined">                while (true) &#123;</span></span><br><span class="line"><span class="undefined">                    if (key &gt; node.Data) &#123;</span></span><br><span class="line"><span class="undefined">                        if (node.RightNode == null) &#123;</span></span><br><span class="line"><span class="undefined">                            newNode.Parent = node;</span></span><br><span class="line"><span class="undefined">                            node.RightNode = newNode;</span></span><br><span class="line"><span class="undefined">                            break;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                        node = node.RightNode;</span></span><br><span class="line"><span class="undefined">                    &#125; else if (key &lt; node.Data) &#123;</span></span><br><span class="line"><span class="undefined">                        if (node.LeftNode == null) &#123;</span></span><br><span class="line"><span class="undefined">                            newNode.Parent = node;</span></span><br><span class="line"><span class="undefined">                            node.LeftNode = newNode;</span></span><br><span class="line"><span class="undefined">                            break;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                        node = node.LeftNode;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        break;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                return newNode;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function insertFixUp(node) &#123;</span></span><br><span class="line"><span class="undefined">                var parentNode = node.Parent;</span></span><br><span class="line"><span class="undefined">                if (parentNode != null &amp;&amp; NodeColor.Red == parentNode.Color) &#123;</span></span><br><span class="line"><span class="undefined">                    var gprentNode = parentNode.Parent;</span></span><br><span class="line"><span class="undefined">                    if (parentNode == gprentNode.LeftNode) &#123;</span></span><br><span class="line"><span class="undefined">                        var uncleNode = gprentNode.RightNode;</span></span><br><span class="line"><span class="undefined">                        if (uncleNode != null &amp;&amp; NodeColor.Red == uncleNode.Color) &#123;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "insertCaseA1", node.Data);//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            parentNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            uncleNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            gprentNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "insertSolutionA1");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            insertFixUp.call(this, gprentNode);</span></span><br><span class="line"><span class="undefined">                        &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                            if (parentNode.RightNode == node) &#123;</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "insertCaseB1", node.Data);//记录分解步骤</span></span><br><span class="line"><span class="undefined">                                leftRotation.call(this, parentNode);</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "insertSolutionB1");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                                insertFixUp.call(this, parentNode);</span></span><br><span class="line"><span class="undefined">                            &#125; else if (parentNode.LeftNode == node) &#123;</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "insertCase3", node.Data);//记录分解步骤</span></span><br><span class="line"><span class="undefined">                                parentNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                                gprentNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                                rightRotation.call(this, gprentNode);</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "insertSolution3");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            &#125;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        var uncleNode = gprentNode.LeftNode;</span></span><br><span class="line"><span class="undefined">                        if (uncleNode != null &amp;&amp; NodeColor.Red == uncleNode.Color) &#123;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "insertCaseA1", node.Data);//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            parentNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            uncleNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            gprentNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "insertSolutionA1");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            insertFixUp.call(this, gprentNode);</span></span><br><span class="line"><span class="undefined">                        &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                            if (parentNode.LeftNode == node) &#123;</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "insertCase4", node.Data);//记录分解步骤</span></span><br><span class="line"><span class="undefined">                                rightRotation.call(this, parentNode);</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "insertSolution4");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                                insertFixUp.call(this, parentNode);</span></span><br><span class="line"><span class="undefined">                            &#125; else if (parentNode.RightNode == node) &#123;</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "insertCase5", node.Data);//记录分解步骤</span></span><br><span class="line"><span class="undefined">                                parentNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                                gprentNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                                leftRotation.call(this, gprentNode);</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "insertSolution5");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            &#125;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                this.RootNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function leftRotation(node) &#123;</span></span><br><span class="line"><span class="undefined">                var temp = node.RightNode;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                node.RightNode = temp.LeftNode;</span></span><br><span class="line"><span class="undefined">                if (temp.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                    temp.LeftNode.Parent = node;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                temp.Parent = node.Parent;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (node.Parent == null) &#123;</span></span><br><span class="line"><span class="undefined">                    this.RootNode = temp;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                else &#123;</span></span><br><span class="line"><span class="undefined">                    if (node.Parent.LeftNode == node) &#123;</span></span><br><span class="line"><span class="undefined">                        node.Parent.LeftNode = temp;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        node.Parent.RightNode = temp;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                temp.LeftNode = node;</span></span><br><span class="line"><span class="undefined">                node.Parent = temp;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function rightRotation(node) &#123;</span></span><br><span class="line"><span class="undefined">                var temp = node.LeftNode;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                node.LeftNode = temp.RightNode;</span></span><br><span class="line"><span class="undefined">                if (temp.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                    temp.RightNode.Parent = node;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                temp.Parent = node.Parent;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (node.Parent == null) &#123;</span></span><br><span class="line"><span class="undefined">                    this.RootNode = temp;</span></span><br><span class="line"><span class="undefined">                &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                    if (node == node.Parent.RightNode) &#123;</span></span><br><span class="line"><span class="undefined">                        node.Parent.RightNode = temp;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        node.Parent.LeftNode = temp;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                temp.RightNode = node;</span></span><br><span class="line"><span class="undefined">                node.Parent = temp;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.Remove = function (key) &#123;</span></span><br><span class="line"><span class="undefined">                var node = search.call(this, this.RootNode, key);</span></span><br><span class="line"><span class="undefined">                if (node == null) &#123;</span></span><br><span class="line"><span class="undefined">                    return;</span></span><br><span class="line"><span class="undefined">                &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                    remove.call(this, node);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function remove(node) &#123;</span></span><br><span class="line"><span class="undefined">                ClearStepView();//清空分解步骤</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="undefined">                var child, parent, nodeColor;</span></span><br><span class="line"><span class="undefined">                if (node.LeftNode != null &amp;&amp; node.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                    CreateStepView(this.RootNode, "deleteCase8", node.Data);//记录分解步骤</span></span><br><span class="line"><span class="undefined">                    var tempNode = findMin(node.RightNode);</span></span><br><span class="line"><span class="undefined">                    if (node.Parent == null) &#123;</span></span><br><span class="line"><span class="undefined">                        this.RootNode = tempNode;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        if (node.Parent.LeftNode == node) &#123;</span></span><br><span class="line"><span class="undefined">                            node.Parent.LeftNode = tempNode;</span></span><br><span class="line"><span class="undefined">                        &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                            node.Parent.RightNode = tempNode;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    child = tempNode.RightNode;</span></span><br><span class="line"><span class="undefined">                    parent = tempNode.Parent;</span></span><br><span class="line"><span class="undefined">                    nodeColor = tempNode.Color;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    if (parent.Data == node.Data) &#123;</span></span><br><span class="line"><span class="undefined">                        parent = tempNode;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        if (child != null) &#123;</span></span><br><span class="line"><span class="undefined">                            child.Parent = parent;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                        parent.LeftNode = child;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                        tempNode.RightNode = node.RightNode;</span></span><br><span class="line"><span class="undefined">                        node.RightNode.Parent = tempNode;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    tempNode.Parent = node.Parent;</span></span><br><span class="line"><span class="undefined">                    tempNode.Color = node.Color;</span></span><br><span class="line"><span class="undefined">                    tempNode.LeftNode = node.LeftNode</span></span><br><span class="line"><span class="undefined">                    node.LeftNode.Parent = tempNode;</span></span><br><span class="line"><span class="undefined">                    </span></span><br><span class="line"><span class="undefined">                    CreateStepView(this.RootNode, "deleteSolution8");//记录分解步骤</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    if (nodeColor == NodeColor.Black) &#123;</span></span><br><span class="line"><span class="undefined">                        removeFixUp.call(this, child, parent);</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                    CreateStepView(this.RootNode, "deleteCase9", node.Data);//记录分解步骤</span></span><br><span class="line"><span class="undefined">                    if (node.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                        child = node.LeftNode;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        child = node.RightNode;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    parent = node.Parent;</span></span><br><span class="line"><span class="undefined">                    nodeColor = node.Color;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    if (child != null) &#123;</span></span><br><span class="line"><span class="undefined">                        child.Parent = parent;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    if (parent != null) &#123;</span></span><br><span class="line"><span class="undefined">                        if (parent.LeftNode != null &amp;&amp; parent.LeftNode.Data == node.Data) &#123;</span></span><br><span class="line"><span class="undefined">                            parent.LeftNode = child;</span></span><br><span class="line"><span class="undefined">                        &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                            parent.RightNode = child;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        this.RootNode = child;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    CreateStepView(this.RootNode, "deleteSolution9");//记录分解步骤</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    if (nodeColor == NodeColor.Black) &#123;</span></span><br><span class="line"><span class="undefined">                        removeFixUp.call(this, child, parent)</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                node = null;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function removeFixUp(node, parentNode) &#123;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="undefined">                var otherNode;</span></span><br><span class="line"><span class="undefined">                while ((node == null || node.Color == NodeColor.Black) &amp;&amp; (node != this.RootNode)) &#123;</span></span><br><span class="line"><span class="undefined">                    if (parentNode.LeftNode == node) &#123;</span></span><br><span class="line"><span class="undefined">                        otherNode = parentNode.RightNode;</span></span><br><span class="line"><span class="undefined">                        if (otherNode.Color == NodeColor.Red) &#123;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteCase1");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            otherNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            parentNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                            leftRotation.call(this, parentNode);</span></span><br><span class="line"><span class="undefined">                            otherNode = parentNode.RightNode;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteSolution1");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                        if ((otherNode.LeftNode == null || otherNode.LeftNode.Color == NodeColor.Black) &amp;&amp;</span></span><br><span class="line"><span class="undefined">                           (otherNode.RightNode == null || otherNode.RightNode.Color == NodeColor.Black)) &#123;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteCase3");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            otherNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                            node = parentNode;</span></span><br><span class="line"><span class="undefined">                            parentNode = node.Parent;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteSolution3");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                        &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                            if (otherNode.RightNode == null || otherNode.RightNode.Color == NodeColor.Black) &#123;</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "deleteCase4");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                                otherNode.LeftNode.Color == NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                                otherNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                                rightRotation.call(this, otherNode);</span></span><br><span class="line"><span class="undefined">                                otherNode = parentNode.RightNode;</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "deleteSolution4");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteCase6");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            otherNode.Color = parentNode.Color;</span></span><br><span class="line"><span class="undefined">                            parentNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            otherNode.RightNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            leftRotation.call(this, parentNode);</span></span><br><span class="line"><span class="undefined">                            node = this.RootNode;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteSolution6");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            break;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                        otherNode = parentNode.LeftNode;</span></span><br><span class="line"><span class="undefined">                        if (otherNode.Color == NodeColor.Red) &#123;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteCase2");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            otherNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            parentNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                            rightRotation.call(this, parentNode);</span></span><br><span class="line"><span class="undefined">                            otherNode = parentNode.LeftNode;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteSolution2");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                        if ((otherNode.LeftNode == null || otherNode.LeftNode.Color == NodeColor.Black) &amp;&amp;</span></span><br><span class="line"><span class="undefined">                            (otherNode.RightNode == null || otherNode.RightNode.Color == NodeColor.Black)) &#123;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteCase3");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            otherNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                            node = parentNode;</span></span><br><span class="line"><span class="undefined">                            parentNode = node.parent;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteSolution3");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                        &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                            if (otherNode.LeftNode == null || otherNode.LeftNode.Color == NodeColor.Black) &#123;</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "deleteCase5");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                                otherNode.RightNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                                otherNode.Color = NodeColor.Red;</span></span><br><span class="line"><span class="undefined">                                leftRotation.call(this, otherNode);</span></span><br><span class="line"><span class="undefined">                                otherNode = parentNode.LeftNode;</span></span><br><span class="line"><span class="undefined">                                CreateStepView(this.RootNode, "deleteSolution5");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            &#125;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteCase7");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            otherNode.Color = parentNode.Color;</span></span><br><span class="line"><span class="undefined">                            parentNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            otherNode.LeftNode.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                            rightRotation.call(this, parentNode);</span></span><br><span class="line"><span class="undefined">                            node = this.RootNode;</span></span><br><span class="line"><span class="undefined">                            CreateStepView(this.RootNode, "deleteSolution7");//记录分解步骤</span></span><br><span class="line"><span class="undefined">                            break;</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                if (node != null) &#123;</span></span><br><span class="line"><span class="undefined">                    node.Color = NodeColor.Black;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.Search = function (key) &#123;</span></span><br><span class="line"><span class="undefined">                return search.call(this, this.RootNode, key);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function search(node, key) &#123;</span></span><br><span class="line"><span class="undefined">                if (node == null) &#123;</span></span><br><span class="line"><span class="undefined">                    return null;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (node.Data &gt; key) &#123;</span></span><br><span class="line"><span class="undefined">                    return search(node.LeftNode, key);</span></span><br><span class="line"><span class="undefined">                &#125; else if (node.Data &lt; key) &#123;</span></span><br><span class="line"><span class="undefined">                    return search(node.RightNode, key);</span></span><br><span class="line"><span class="undefined">                &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                    return node;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.FindMin = function () &#123;</span></span><br><span class="line"><span class="undefined">                return findMin(this.RootNode);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function findMin(node) &#123;</span></span><br><span class="line"><span class="undefined">                if (node.LeftNode == null) &#123;</span></span><br><span class="line"><span class="undefined">                    return node;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                return findMin(node.LeftNode);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.FindMax = function () &#123;</span></span><br><span class="line"><span class="undefined">                return findMax(this.RootNode)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function findMax(node) &#123;</span></span><br><span class="line"><span class="undefined">                if (node.RightNode == null) &#123;</span></span><br><span class="line"><span class="undefined">                    return node;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">                return findMax(node.RightNode);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.SearchRange = function (minKey, maxKey) &#123;</span></span><br><span class="line"><span class="undefined">                return searchRange(minKey, maxKey, this.RootNode, []);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function searchRange(minKey, maxKey, node, nodeList) &#123;</span></span><br><span class="line"><span class="undefined">                if (node == null) &#123;</span></span><br><span class="line"><span class="undefined">                    return nodeList;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (node.Data &gt; minKey) &#123;</span></span><br><span class="line"><span class="undefined">                    searchRange(minKey, maxKey, node.LeftNode, nodeList);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (node.Data &gt;= minKey &amp;&amp; node.Data &lt; maxKey) &#123;</span></span><br><span class="line"><span class="undefined">                    nodeList.push(node.Data);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (node.Data &lt; maxKey) &#123;</span></span><br><span class="line"><span class="undefined">                    searchRange(minKey, maxKey, node.RightNode, nodeList);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                return nodeList;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.LevelOrder = function (action) &#123;</span></span><br><span class="line"><span class="undefined">                levelOrder(this.RootNode, action);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function levelOrder(node, action) &#123;</span></span><br><span class="line"><span class="undefined">                var stack = [];</span></span><br><span class="line"><span class="undefined">                stack.push(node);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                while (stack.length &gt; 0) &#123;</span></span><br><span class="line"><span class="undefined">                    var temp = stack.pop();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    action(temp);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    if (temp.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                        stack.push(temp.LeftNode);</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                    if (temp.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                        stack.push(temp.RightNode);</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.PreOrder = function (action) &#123;</span></span><br><span class="line"><span class="undefined">                treeOrder(this.RootNode, action, null, null);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.InOrder = function (action) &#123;</span></span><br><span class="line"><span class="undefined">                treeOrder(this.RootNode, null, action, null);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            this.PostOrder = function (action) &#123;</span></span><br><span class="line"><span class="undefined">                treeOrder(this.RootNode, null, null, action);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            function treeOrder(node, preOrderAction, inOrderAction, postOrderAction) &#123;</span></span><br><span class="line"><span class="undefined">                if (preOrderAction) &#123;</span></span><br><span class="line"><span class="undefined">                    preOrderAction(node);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (node.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                    treeOrder(node.LeftNode, preOrderAction, inOrderAction, postOrderAction);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (inOrderAction) &#123;</span></span><br><span class="line"><span class="undefined">                    inOrderAction(node);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (node.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                    treeOrder(node.RightNode, preOrderAction, inOrderAction, postOrderAction);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">                if (postOrderAction) &#123;</span></span><br><span class="line"><span class="undefined">                    postOrderAction(node);</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var height = 50;//节点之间的高</span></span><br><span class="line"><span class="undefined">        var width = 15;//节点之间的宽</span></span><br><span class="line"><span class="undefined">        var tops = 40;//根节点离顶部的距离</span></span><br><span class="line"><span class="undefined">        var foot = 40;//树离底部距离</span></span><br><span class="line"><span class="undefined">        var spacing = 30;//树分别离两边的间距</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var tree = new RedBlackBinaryTree();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function AddOneNumber() &#123;</span></span><br><span class="line"><span class="undefined">            var numbertext = document.getElementById("numbertext").value;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            var oneNums = numbertext.match(/[1-9][0-9]&#123;0,2&#125;\,?/);</span></span><br><span class="line"><span class="undefined">            document.getElementById("numbertext").value = numbertext.replace(/[1-9][0-9]&#123;0,2&#125;\,?/, "");</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            var num = (oneNums + "").match(/[1-9][0-9]&#123;0,2&#125;/);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (!!num) &#123;</span></span><br><span class="line"><span class="undefined">                AddNumber(parseInt(num));</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function AddRandom() &#123;</span></span><br><span class="line"><span class="undefined">            AddNumber(Math.floor(Math.random() * (1000)));</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function AddAllNumber() &#123;</span></span><br><span class="line"><span class="undefined">            while (true) &#123;</span></span><br><span class="line"><span class="undefined">                AddOneNumber();</span></span><br><span class="line"><span class="undefined">                var numbertext = document.getElementById("numbertext").value;</span></span><br><span class="line"><span class="undefined">                if (!/[1-9][0-9]&#123;0,2&#125;/.test(numbertext)) &#123;</span></span><br><span class="line"><span class="undefined">                    break;</span></span><br><span class="line"><span class="undefined">                &#125;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function AddNumber(number) &#123;</span></span><br><span class="line"><span class="undefined">            tree.Insert(number);</span></span><br><span class="line"><span class="undefined">            RenewView(tree);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function DeleteNumber() &#123;</span></span><br><span class="line"><span class="undefined">            var deleteNumberText = document.getElementById("deleteNumberText").value;</span></span><br><span class="line"><span class="undefined">            if (!deleteNumberText.match(/^[1-9][0-9]&#123;0,2&#125;$/)) &#123;</span></span><br><span class="line"><span class="undefined">                alert("请正确输入1-999的整数");</span></span><br><span class="line"><span class="undefined">                return false;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            var number = parseInt(deleteNumberText);</span></span><br><span class="line"><span class="undefined">            var isExist = tree.Search(number);</span></span><br><span class="line"><span class="undefined">            if (!isExist)</span></span><br><span class="line"><span class="undefined">            &#123;</span></span><br><span class="line"><span class="undefined">                alert("不存在此节点");</span></span><br><span class="line"><span class="undefined">                return false;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            tree.Remove(number);</span></span><br><span class="line"><span class="undefined">            document.getElementById("deleteNumberText").value = '';</span></span><br><span class="line"><span class="undefined">            RenewView(tree);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function RenewView(_tree) &#123;</span></span><br><span class="line"><span class="undefined">            var currentView = document.getElementById("currentView");</span></span><br><span class="line"><span class="undefined">            currentView.innerHTML = '';</span></span><br><span class="line"><span class="undefined">            CreateTreeView(_tree.RootNode, currentView);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function CreateTreeView(rootNode, hostDocument) &#123;</span></span><br><span class="line"><span class="undefined">            var size = SetCanvasWidthHeight(rootNode);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            var canvas = document.createElement("canvas");</span></span><br><span class="line"><span class="undefined">            canvas.style.backgroundColor = "antiquewhite";</span></span><br><span class="line"><span class="undefined">            canvas.style.display = "block";</span></span><br><span class="line"><span class="undefined">            canvas.height = size.height;</span></span><br><span class="line"><span class="undefined">            canvas.width = size.width;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            var context = canvas.getContext("2d");</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            hostDocument.appendChild(canvas);</span></span><br><span class="line"><span class="undefined">            SetPoint(rootNode);</span></span><br><span class="line"><span class="undefined">            PreOrder(rootNode, SetPreOrder, context, canvas.width);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function PreOrder(node, action, context, canvasWidth) &#123;</span></span><br><span class="line"><span class="undefined">            action(node, context, canvasWidth);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (node.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                PreOrder(node.LeftNode, action, context, canvasWidth);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (node.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                PreOrder(node.RightNode, action, context, canvasWidth);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function SetCanvasWidthHeight(rootNode) &#123;</span></span><br><span class="line"><span class="undefined">            var level = Level(rootNode);</span></span><br><span class="line"><span class="undefined">            return &#123;</span></span><br><span class="line"><span class="undefined">                height: height * level + tops + foot,</span></span><br><span class="line"><span class="undefined">                width: Math.pow(2, level + 1) * width + spacing * 2</span></span><br><span class="line"><span class="undefined">            &#125;;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function SetPreOrder(node, context, canvasWidth) &#123;</span></span><br><span class="line"><span class="undefined">            var container = drawArc(</span></span><br><span class="line"><span class="undefined">                context,</span></span><br><span class="line"><span class="undefined">                node.Data,</span></span><br><span class="line"><span class="undefined">                canvasWidth / 2 + width * node.nodePoint,</span></span><br><span class="line"><span class="undefined">                (node.nodeLevel * height + parseInt(tops)),</span></span><br><span class="line"><span class="undefined">                node.Color);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (node.Parent != null) &#123;</span></span><br><span class="line"><span class="undefined">                var line = linkNode(</span></span><br><span class="line"><span class="undefined">                    context,</span></span><br><span class="line"><span class="undefined">                    (canvasWidth / 2 + width * node.Parent.nodePoint),</span></span><br><span class="line"><span class="undefined">                    (node.Parent.nodeLevel * height + parseInt(tops)),</span></span><br><span class="line"><span class="undefined">                    (node.Data, canvasWidth / 2 + width * node.nodePoint),</span></span><br><span class="line"><span class="undefined">                    (node.nodeLevel * height + parseInt(tops)));</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        //生产节点</span></span><br><span class="line"><span class="undefined">        function drawArc(context, number, x, y, color) &#123;</span></span><br><span class="line"><span class="undefined">            //圆</span></span><br><span class="line"><span class="undefined">            context.beginPath();</span></span><br><span class="line"><span class="undefined">            context.fillStyle = color;</span></span><br><span class="line"><span class="undefined">            context.arc(x, y, 15, (Math.PI / 180) * 0, (Math.PI / 180) * 360, false);</span></span><br><span class="line"><span class="undefined">            context.fill();</span></span><br><span class="line"><span class="undefined">            context.closePath();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            //数字</span></span><br><span class="line"><span class="undefined">            var textX = x;</span></span><br><span class="line"><span class="undefined">            var textY = y + 5;</span></span><br><span class="line"><span class="undefined">            if (number &lt; 10) &#123;</span></span><br><span class="line"><span class="undefined">                textX -= 5;</span></span><br><span class="line"><span class="undefined">            &#125; else if (number &gt; 9 &amp;&amp; number &lt; 100) &#123;</span></span><br><span class="line"><span class="undefined">                textX -= 8;</span></span><br><span class="line"><span class="undefined">            &#125; else &#123;</span></span><br><span class="line"><span class="undefined">                textX -= 12;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            context.fillStyle = "white";</span></span><br><span class="line"><span class="undefined">            context.font = "bold 15px Arial";</span></span><br><span class="line"><span class="undefined">            context.fillText(number + "", textX, textY);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        //链接节点</span></span><br><span class="line"><span class="undefined">        function linkNode(context, fatherNodeX, fatherNodeY, childrenNodeX, childrenNodeY) &#123;</span></span><br><span class="line"><span class="undefined">            drawLine(context, fatherNodeX, fatherNodeY + 15, childrenNodeX, childrenNodeY - 15);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        //生产线</span></span><br><span class="line"><span class="undefined">        function drawLine(context, x, y, toX, toY) &#123;</span></span><br><span class="line"><span class="undefined">            context.moveTo(x, y);</span></span><br><span class="line"><span class="undefined">            context.lineTo(x, y);</span></span><br><span class="line"><span class="undefined">            context.lineTo(toX, toY);</span></span><br><span class="line"><span class="undefined">            context.stroke();</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var maxLevel;</span></span><br><span class="line"><span class="undefined">        var level;</span></span><br><span class="line"><span class="undefined">        function Level(rootNode) &#123;</span></span><br><span class="line"><span class="undefined">            maxLevel = 0;</span></span><br><span class="line"><span class="undefined">            level = 0;</span></span><br><span class="line"><span class="undefined">            return levels(rootNode);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function levels(node) &#123;</span></span><br><span class="line"><span class="undefined">            if (node.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                level++;</span></span><br><span class="line"><span class="undefined">                levels(node.LeftNode);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            maxLevel = Math.max(maxLevel, level);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (node.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                level++;</span></span><br><span class="line"><span class="undefined">                levels(node.RightNode);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            level--;</span></span><br><span class="line"><span class="undefined">            return maxLevel;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function SetPoint(rootNode) &#123;</span></span><br><span class="line"><span class="undefined">            var thisMaxLevel = Level(rootNode);</span></span><br><span class="line"><span class="undefined">            var childQuanty = Math.pow(2, thisMaxLevel);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            rootNode.nodeLevel = 0;</span></span><br><span class="line"><span class="undefined">            rootNode.nodePoint = 0;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (rootNode.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                setPointsLeft(rootNode.LeftNode, -1 * childQuanty / 2, 0, thisMaxLevel - 1);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (rootNode.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                setPointsRight(rootNode.RightNode, childQuanty / 2, 0, thisMaxLevel - 1);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function setPointsLeft(node, point, levels, thisMaxLevel) &#123;</span></span><br><span class="line"><span class="undefined">            ++levels;</span></span><br><span class="line"><span class="undefined">            node.nodeLevel = levels;</span></span><br><span class="line"><span class="undefined">            node.nodePoint = point;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (node.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                setPointsLeft(node.LeftNode, point - Math.pow(2, thisMaxLevel - levels), levels, thisMaxLevel);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (node.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                setPointsLeft(node.RightNode, point + Math.pow(2, thisMaxLevel - levels), levels, thisMaxLevel);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function setPointsRight(node, point, levels, thisMaxLevel) &#123;</span></span><br><span class="line"><span class="undefined">            ++levels;</span></span><br><span class="line"><span class="undefined">            node.nodeLevel = levels;</span></span><br><span class="line"><span class="undefined">            node.nodePoint = point;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (node.LeftNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                setPointsRight(node.LeftNode, point - Math.pow(2, thisMaxLevel - levels), levels, thisMaxLevel);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (node.RightNode != null) &#123;</span></span><br><span class="line"><span class="undefined">                setPointsRight(node.RightNode, point + Math.pow(2, thisMaxLevel - levels), levels, thisMaxLevel);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var stepRemark = &#123;</span></span><br><span class="line"><span class="undefined">            "insertCaseA1": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况A1",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertSolutionA1": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况A1的解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                        "(01) 将“父节点”设为黑色",</span></span><br><span class="line"><span class="undefined">                        "(02) 将“叔叔节点”设为黑色",</span></span><br><span class="line"><span class="undefined">                        "(03) 将“祖父节点”设为“红色",</span></span><br><span class="line"><span class="undefined">                        "(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertCaseB1": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况2",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertSolutionB1": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况2的解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                        "(01) 将“父节点”作为“新的当前节点”",</span></span><br><span class="line"><span class="undefined">                        "(02) 以“新的当前节点”为支点进行左旋",</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertCase3": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况3",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertSolution3": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况3的解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                        "(01) 将“父节点”设为“黑色”",</span></span><br><span class="line"><span class="undefined">                        "(02) 将“祖父节点”设为“红色”",</span></span><br><span class="line"><span class="undefined">                        "(03) 以“祖父节点”为支点进行右旋"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertCase4": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况4",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertSolution4": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况4的解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                        "(01) 将“父节点”作为“新的当前节点”",</span></span><br><span class="line"><span class="undefined">                        "(02) 以“新的当前节点”为支点进行右旋",</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertCase5": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况5",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "insertSolution5": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "插入节点情况5的解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                        "(01) 将“父节点”设为“黑色”",</span></span><br><span class="line"><span class="undefined">                        "(02) 将“祖父节点”设为“红色”",</span></span><br><span class="line"><span class="undefined">                        "(03) 以“祖父节点”为支点进行左旋"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase1": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况1",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "被删节点是“黑+黑”节点，被删除的节点是左节点，被删节点的兄弟节点是红色。(此时被删节点的父节点和x的兄弟节点的子节点都是黑节点)。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution1": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况1解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将x的兄弟节点设为“黑色”。",</span></span><br><span class="line"><span class="undefined">                    "(02) 将x的父节点设为“红色”。",</span></span><br><span class="line"><span class="undefined">                    "(03) 对x的父节点进行左旋。",</span></span><br><span class="line"><span class="undefined">                    "(04) 左旋后，重新设置x的兄弟节点。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase2": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况2",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "被删节点是“黑+黑”节点，被删除的节点是右节点，被删节点的兄弟节点是红色。(此时被删节点的父节点和x的兄弟节点的子节点都是黑节点)。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution2": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况2解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将被删节点的兄弟节点设为“黑色”。",</span></span><br><span class="line"><span class="undefined">                    "(02) 将被删节点的父节点设为“红色”。",</span></span><br><span class="line"><span class="undefined">                    "(03) 对被删节点的父节点进行右旋。",</span></span><br><span class="line"><span class="undefined">                    "(04) 右旋后，重新设置x的兄弟节点。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase3": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况3",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "被删节点是“黑+黑”节点，被删节点的兄弟节点是黑色，被删节点的兄弟节点的两个孩子都是黑色。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution3": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况3解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将被删节点的兄弟节点设为“红色”。",</span></span><br><span class="line"><span class="undefined">                    "(02) 设置“被删节点的父节点”为“新的被删节点节点”。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase4": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况4",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "将被删节点是“黑+黑”节点，被删节点的兄弟节点是黑色；将被删节点的兄弟节点的左孩子是红色，右孩子是黑色的。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution4": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况4解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将被删节点兄弟节点的左孩子设为“黑色”。",</span></span><br><span class="line"><span class="undefined">                    "(02) 将被删节点兄弟节点设为“红色”。",</span></span><br><span class="line"><span class="undefined">                    "(03) 对被删节点的兄弟节点进行右旋。",</span></span><br><span class="line"><span class="undefined">                    "(04) 右旋后，重新设置被删节点的兄弟节点。",</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase5": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况5",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "被删节点是“黑+黑”节点，被删节点的兄弟节点是黑色；被删节点的兄弟节点的左孩子是黑色，右孩子是红色的。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution5": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况5解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将被删节点兄弟节点的右孩子设为“黑色”。",</span></span><br><span class="line"><span class="undefined">                    "(02) 将被删节点兄弟节点设为“红色”。",</span></span><br><span class="line"><span class="undefined">                    "(03) 对被删节点的兄弟节点进行左旋。",</span></span><br><span class="line"><span class="undefined">                    "(04) 左旋后，重新设置被删节点的兄弟节点。",</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase6": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况6",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "被删节点是“黑+黑”节点，被删节点的兄弟节点是黑色；被删节点的兄弟节点的右孩子是红色的，被删节点的兄弟节点的左孩子任意颜色。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution6": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况6解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将被删节点父节点颜色 赋值给 被删节点的兄弟节点。",</span></span><br><span class="line"><span class="undefined">                    "(02) 将被删节点父节点设为“黑色”。",</span></span><br><span class="line"><span class="undefined">                    "(03) 将被删节点兄弟节点的右子节点设为“黑色”。",</span></span><br><span class="line"><span class="undefined">                    "(04) 对被删节点的父节点进行左旋。",</span></span><br><span class="line"><span class="undefined">                    "(05) 设置“被删节点”为“根节点”。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase7": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况7",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "被删节点是“黑+黑”节点，被删节点的兄弟节点是黑色；被删节点的兄弟节点的左孩子是红色的，被删节点的兄弟节点的右孩子任意颜色。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution7": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况7解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将被删节点父节点颜色 赋值给 被删节点的兄弟节点。",</span></span><br><span class="line"><span class="undefined">                    "(02) 将被删节点父节点设为“黑色”。",</span></span><br><span class="line"><span class="undefined">                    "(03) 将被删节点兄弟节点的左子节设为“黑色”。",</span></span><br><span class="line"><span class="undefined">                    "(04) 对被删节点的父节点进行右旋。",</span></span><br><span class="line"><span class="undefined">                    "(05) 设置“被删节点”为“根节点”。"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase8": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况8",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "被删节点有两个子节点"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution8": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况8解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将被删节点右节点的子孙节点中找出小的节点，替换被删节点。",</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteCase9": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况9",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "被删节点只有一个子节点或无子节点"</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined">            "deleteSolution9": &#123;</span></span><br><span class="line"><span class="undefined">                "title": "删除节点情况9解决方案",</span></span><br><span class="line"><span class="undefined">                "remark": [</span></span><br><span class="line"><span class="undefined">                    "(01) 将唯一的子节点替换被删节点。",</span></span><br><span class="line"><span class="undefined">                ]</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">                </span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function ClearStepView() &#123;</span></span><br><span class="line"><span class="undefined">            var stepView = document.getElementById("stepView");</span></span><br><span class="line"><span class="undefined">            stepView.innerHTML = '';</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function CreateStepView(_tree, step, currentNumber) &#123;</span></span><br><span class="line"><span class="undefined">            var fieldset = document.createElement("fieldset");</span></span><br><span class="line"><span class="undefined">            var legend = document.createElement("legend");</span></span><br><span class="line"><span class="undefined">            var ul = document.createElement("ul");</span></span><br><span class="line"><span class="undefined">            var canvas = document.createElement("canvas");</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            legend.innerHTML = stepRemark[step].title;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            if (!!currentNumber) &#123;</span></span><br><span class="line"><span class="undefined">                var li = document.createElement("li");</span></span><br><span class="line"><span class="undefined">                li.innerHTML = "当前节点：" + currentNumber;</span></span><br><span class="line"><span class="undefined">                ul.appendChild(li);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            for (var i = 0; i &lt; stepRemark[step].remark.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">                var li = document.createElement("li");</span></span><br><span class="line"><span class="undefined">                li.innerHTML = stepRemark[step].remark[i];</span></span><br><span class="line"><span class="undefined">                ul.appendChild(li);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            fieldset.appendChild(legend);</span></span><br><span class="line"><span class="undefined">            fieldset.appendChild(ul);</span></span><br><span class="line"><span class="undefined">            fieldset.appendChild(canvas);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            var stepView = document.getElementById("stepView");</span></span><br><span class="line"><span class="undefined">            stepView.appendChild(fieldset);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            CreateStepTreeView(_tree, canvas);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        function CreateStepTreeView(rootNode, canvas) &#123;</span></span><br><span class="line"><span class="undefined">            var size = SetCanvasWidthHeight(rootNode);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            canvas.style.backgroundColor = "antiquewhite";</span></span><br><span class="line"><span class="undefined">            canvas.style.display = "block";</span></span><br><span class="line"><span class="undefined">            canvas.height = size.height;</span></span><br><span class="line"><span class="undefined">            canvas.width = size.width;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            var context = canvas.getContext("2d");</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">            SetPoint(rootNode);</span></span><br><span class="line"><span class="undefined">            PreOrder(rootNode, SetPreOrder, context, canvas.width);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自CSDN博客&lt;a href=&quot;https://www.cnblogs.com/bbvi/p/5576201.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在线生成红黑树（含变形步骤）&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>位示图信息转换磁盘信息</title>
    <link href="http://0202zc.github.io/2020/07/24/os-bitmap-disk-transform/"/>
    <id>http://0202zc.github.io/2020/07/24/os-bitmap-disk-transform/</id>
    <published>2020-07-24T09:55:00.000Z</published>
    <updated>2020-07-24T10:08:45.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="位示图与磁盘内部信息如何进行转换？"><a href="#位示图与磁盘内部信息如何进行转换？" class="headerlink" title="位示图与磁盘内部信息如何进行转换？"></a>位示图与磁盘内部信息如何进行转换？</h2><a id="more"></a><p>n个柱面，编号0～n-1；共m个磁头，编号0～m-1；每个磁道内的k个信息块从1开始编号，1～k。</p><p>x：逻辑磁盘块号<br>a：任意逻辑磁盘块的柱面号<br>b：磁头号<br>c：磁道内块号</p><p>则：</p><p>$ x = k × m × a + k × b + c $</p><p>$ a = (x - 1) / (k × m) $</p><p>$ b = ((x - 1) mod (k × m)) / k $</p><p>$ c = ((x - 1) mod (k × m)) mod k + 1 $</p><p>正常情况下，可以理解为：位示图的一个位置对应一个磁盘块，一个磁盘块就是一个扇区（最小单位），所以位示图一个块对应一个扇区。</p><p><strong>注：汤子瀛的《操作系统第四版》里明确说明一个扇区称为一个盘块（或数据块）</strong></p><hr><h2 id="磁盘块与扇区大小问题"><a href="#磁盘块与扇区大小问题" class="headerlink" title="磁盘块与扇区大小问题"></a>磁盘块与扇区大小问题</h2><p>既然磁盘块是一个虚拟概念。是操作系统自己＂杜撰＂的。软件的概念，不是真实的。所以大小由操作系统决定，操作系统可以配置一个块多大。</p><p>一个块大小=一个扇区大小*2的n次方。</p><p>N是可以修改的。</p><p>顿时我思考：为什么磁盘块大小必须是扇区大小的整数倍呢？</p><p>因为，磁盘驱动器，磁盘附带的硬件设备，与磁盘读写数据，操作系统也要靠它。<br>它读取磁盘数据就是扇区的大小。</p><p>一个扇区是512字节。有些硬盘厂商会提供4k大小扇区。这是物理结构。磁盘定下来的结构就是没法修改的</p><blockquote><p>转自博客园<a href="https://www.cnblogs.com/wangtao_20/p/4791265.html" target="_blank" rel="noopener">《思考与总结:扇区和磁盘块的区别是什么》</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;位示图与磁盘内部信息如何进行转换？&quot;&gt;&lt;a href=&quot;#位示图与磁盘内部信息如何进行转换？&quot; class=&quot;headerlink&quot; title=&quot;位示图与磁盘内部信息如何进行转换？&quot;&gt;&lt;/a&gt;位示图与磁盘内部信息如何进行转换？&lt;/h2&gt;
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://0202zc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OS" scheme="http://0202zc.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode 笔记】动态规划</title>
    <link href="http://0202zc.github.io/2020/04/08/algorithm/leetcode-dynamic-programming/"/>
    <id>http://0202zc.github.io/2020/04/08/algorithm/leetcode-dynamic-programming/</id>
    <published>2020-04-08T12:04:11.000Z</published>
    <updated>2020-04-11T01:08:43.499Z</updated>
    
    <content type="html"><![CDATA[<p>转自CSDN博文<a href="https://blog.csdn.net/kkm09/article/details/105354607" target="_blank" rel="noopener">《【LeetCode 笔记】动态规划》</a><br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一篇博文便涉水：<a href="https://blog.csdn.net/m0_37907797/article/details/103231054" target="_blank" rel="noopener">《为什么你学不过动态规划？告别动态规划，谈谈我的经验》</a></p><p>从中摘出来的中心思想方法：</p><blockquote><p>第一步：定义数组元素的<strong>含义</strong><br>第二步：找出数组元素之间的<strong>关系式</strong>【状态转移方程】<br>第三步：找出<strong>初始值</strong>。</p></blockquote><p>其中第二步极其类似于<strong>第二数学归纳法</strong></p><p>文中讲解了3道例题，依次为：</p><ul><li><a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">70. 爬楼梯</a>【一维dp】</li><li><a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener">62. 不同路径</a>【二维dp】</li><li><a href="https://leetcode-cn.com/problems/minimum-path-sum" target="_blank" rel="noopener">64. 最小路径和</a>【二维dp】</li><li><a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener">72. 编辑距离</a>【二维dp】</li></ul><blockquote><p>注：有时候用动态规划解决问题不如指针的方法来得好，如题目<a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a><br>双指针方法几乎不多占内存，而基于数组的动态规划反而需要一部分内存；但是二者的执行时间相同。<br><img data-src="https://img-blog.csdnimg.cn/20200407204607809.png" width="70%"><br>有些题目可以<strong>对空间进行优化</strong>，即不使用额外dp数组，通过分析，可以在不影响未来值计算的情况下，就地记录信息。</p></blockquote><hr><h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h1><p><img data-src="https://img-blog.csdnimg.cn/20200406234041186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trbTA5,size_16,color_FFFFFF,t_70" alt="题目描述 53"><br><strong>解题思路：</strong></p><p>想到了一次的正序遍历，但是结果求出的是非连续序列的最大和：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(max(dp[i - <span class="number">1</span>], nums[i]), dp[i - <span class="number">1</span>] + nums[i]);</span><br></pre></td></tr></table></figure></p><p>官方题解：</p><blockquote><p>在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题可以通过动态规划（DP）在线性时间内解决。<br>有两种标准 DP 方法适用于数组：</p><ol><li>常数空间，沿数组移动并在原数组修改。</li><li>线性空间，首先沿 left-&gt;right 方向移动，然后再沿 right-&gt;left 方向移动。 合并结果。</li></ol><ul><li>我们在这里使用第一种方法，因为可以修改数组跟踪<strong>当前位置的最大和</strong>。</li><li>下一步是在知道当前位置的最大和后更新<strong>全局最大和</strong>。</li></ul><p><img data-src="https://img-blog.csdnimg.cn/20200407095810761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trbTA5,size_16,color_FFFFFF,t_70" width="70%"></p></blockquote><p>简而言之，就是检测<code>max(nums[i], nums[i - 1] + nums[i])</code>：</p><ul><li>if(max &lt;= nums[i])，则不作改变，i++;</li><li>if(max &gt; nums[i])，则更新 nums[i] = nums[i - 1] + nums[i];<br>这就是与非连续子数组最大的不同：遇到负数【间断点】，<strong>不保留之前的最大和</strong>【即实现了非连续】；且不管正数负数，<strong>只要前后之和大于当前值就进行更新</strong></li><li>最后一步检测<code>max(nums[i], nums[i + 1])</code></li></ul><blockquote><p>上图的第二行<code>current max sum</code>指的是局部连续子区间内的最大和，最后一行是全局的最大和</p></blockquote><ol><li><p>定义数组元素含义<br> 定义<code>dp[numsSize]</code>记录局部最大和，<code>dp[i]</code>表示当前局部最大和</p></li><li><p>定义状态转移方程<br> 要取最大值，则要看 是加了之后变大，还是原来就比较大，肯定不能是加了一个数之后反而变小了。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br></pre></td></tr></table></figure></li><li><p>初始化<br> dp[0] = nums[0];</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[numsSize];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        dp[i] = max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)&#123;  <span class="comment">//局部区间从后向前检测</span></span><br><span class="line">        dp[i] = max(dp[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[numsSize - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//另一种思路，非负数才值得留下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>], sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; <span class="number">0</span>)</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum = nums[i];</span><br><span class="line">        res = max(res, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a>121. 买卖股票的最佳时机</h1><p><strong>解题思路：</strong></p><p><img data-src="https://img-blog.csdnimg.cn/20200407201408779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trbTA5,size_16,color_FFFFFF,t_70" width="60%"></p><p>1.定义数组元素含义</p><ul><li>用<code>dp[i]</code>来表示<strong>能买入的最低价的下标</strong></li><li>用<code>profit[i]</code>来表示<strong>当前值与目前最低价之差</strong>【收益】</li></ul><p>2.定义状态转移方程</p><ul><li>如果当前价格小于前一个价格，则对买入价格进行更新</li><li><p>否则，继续记录目前最低买入价下标，计算当前价格收益</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(prices[i] &lt;= prices[dp[i - <span class="number">1</span>]])&#123;</span><br><span class="line">    dp[i] = i;</span><br><span class="line">    profit[i] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">    profit[i] = prices[i] - prices[dp[i]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终返回值为收益数组<code>profit</code>中最大的那个数</p></li></ul><p>3.初始化</p><ul><li>dp[0] = 0;    //prices数组第一个（prices[0]）的下标</li><li>profit[0] = 0;    //第一个没买没卖，收益为0</li></ul><p>4.最终代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>* prices, <span class="keyword">int</span> pricesSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pricesSize &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[pricesSize], profit[pricesSize];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//dp[i]记录最低价的下标</span></span><br><span class="line">    profit[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pricesSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt;= prices[dp[i - <span class="number">1</span>]])&#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            profit[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            profit[i] = prices[i] - prices[dp[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m = profit[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pricesSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; profit[i])&#123;</span><br><span class="line">            m = profit[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><hr><h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a>198. 打家劫舍</h1><p><img data-src="https://img-blog.csdnimg.cn/20200407184316240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trbTA5,size_16,color_FFFFFF,t_70" alt="题目描述"><br><strong>解题思路：</strong></p><blockquote><p>这道题和上一题相同点在于都有访问限制条件，基于这一点就可以方便书写递推表达式<br>· 同型题目：<a href="https://leetcode-cn.com/problems/the-masseuse-lcci/" target="_blank" rel="noopener">《面试题 17.16. 按摩师》</a></p></blockquote><p>1.定义数组元素含义</p><ul><li>定义<code>dp[i]</code>为当前获得的最高金额</li></ul><p>2.定义状态转移方程</p><ul><li>表达式的化简参考<a href="https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode/" target="_blank" rel="noopener">官方题解</a></li><li>根据上述化简结论（dp错位）可设dp[numsSize + 1]，其中设dp[0]为1</li><li><code>dp[i] = max(dp[i - 1], dp[i - 2] + num[i - 1])</code>【图片参考：<a href="https://leetcode-cn.com/problems/house-robber/solution/hua-jie-suan-fa-198-da-jia-jie-she-by-guanpengchn/" target="_blank" rel="noopener">画解算法</a>】</li><li>由于不可以在相邻的房屋闯入，所以在当前位置 n 房屋可盗窃的最大值，要么就是 n-1 房屋可盗窃的最大值，要么就是 n-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值</li></ul><p>3.初始化</p><ul><li>dp[0] = 0;</li><li>dp[1] = nums[0];</li></ul><p>4.代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[numsSize + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= numsSize; i++)&#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[numsSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n)$</p><blockquote><ul><li>当时自己写的时候走了很多弯路，没有让dp[0]错位，使得代码变得很复杂。</li><li>因为要对dp数组进行排序，每趟都要找dp[0, i - 2]中最大的一个数，时间复杂度达到了$O(n^2)$</li><li>现在明白了dp[2] = max(dp[0] + dp[2], dp[1])的意义：在初始情况下，选择nums[0]和nums[1]中较大的那个</li></ul><p>代码如下：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">   ...</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">2</span>; j++)&#123;    <span class="comment">//找dp[0, i - 2]中最大的一个数</span></span><br><span class="line">            m = max_num(m, dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = m + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; dp[i])</span><br><span class="line">            max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来仔细研究了一下，发现 <code>dp[1] = max(nums[0], nums[1])</code>，这样就能在后续的dp[i]（i &gt; 2）遍历中不断使用到前面的max值（dp[2]除外）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(numsSize == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numsSize == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[numsSize];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[numsSize - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="413-等差数列划分"><a href="#413-等差数列划分" class="headerlink" title="413. 等差数列划分"></a>413. 等差数列划分</h1><blockquote><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。<br><br><br>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。<br>如果满足以下条件，则称子数组(P, Q)为等差数组：<br>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。<br>函数要返回数组 A 中所有为等差数组的子数组个数。<br><br><br>如：A = [1, 2, 3, 4]<br>返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</p></blockquote><p><strong>解题思路：</strong></p><p>1.定义数组元素含义</p><pre><code>dp[i] 表示以 A[i] 为结尾的等差递增子区间的个数。</code></pre><p>2.定义状态转移方程</p><pre><code>等差数列：A[i] - A[i-1] == A[i-1] - A[i-2]</code></pre><blockquote><p>当 <code>A[i] - A[i-1] == A[i-1] - A[i-2]</code>，那么 <code>[A[i-2], A[i-1], A[i]]</code> 构成一个等差递增子区间。而且在以 <code>A[i-1]</code> 为结尾的递增子区间的后面再加上一个 <code>A[i]</code>，一样可以构成新的递增子区间。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">dp[<span class="number">3</span>] = dp[<span class="number">2</span>] + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="comment">// [0, 1, 2] 之后加一个 3</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]     <span class="comment">// 新的递增子区间</span></span><br><span class="line">dp[<span class="number">4</span>] = dp[<span class="number">3</span>] + <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="comment">// [0, 1, 2, 3] 之后加一个 4</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],    <span class="comment">// [1, 2, 3] 之后加一个 4</span></span><br><span class="line">    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]        <span class="comment">// 新的递增子区间</span></span><br></pre></td></tr></table></figure><p>综上，在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>])&#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.初始化</p><ul><li>数列至少要三个元素</li><li>dp[0] = 0, dp[1] = 0;</li></ul><p>因为递增子区间不一定以最后一个元素为结尾，可以是任意一个元素结尾，因此需要返回 <strong>dp 数组累加</strong>的结果。</p><p>4.最终代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> ASize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ASize &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dp[ASize];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; ASize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] - A[i - <span class="number">1</span>] == A[i - <span class="number">1</span>] - A[i - <span class="number">2</span>])&#123;<span class="comment">//是等差数列，累加</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//否则，重新计数</span></span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ASize; i++)&#123;</span><br><span class="line">        total += dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><hr><h1 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h1><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。<br><br><br><strong>输入:</strong> [10,9,2,5,3,7,101,18]<br><strong>输出:</strong> 4<br><strong>解释:</strong> 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br><br><br><strong>说明:</strong><br>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 $O(n^2)$ 。</p></blockquote><p><strong>解题思路：</strong></p><p>1.定义数组元素含义</p><ul><li>定义一个数组 dp 存储最长递增子序列的长度</li><li>dp[n] 表示以 S<sub>n</sub> 结尾的序列的最长递增子序列长度。</li></ul><p>2.定义状态转换方程  </p><ul><li><p>dp[n] = max{ dp[i] + 1 | S<sub>i</sub> &lt; S<sub>n</sub> &amp;&amp; i &lt; n} </p></li><li><p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {S<sub>n</sub>} 就构成了递增子序列，需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：<code>dp[n] = max{1, dp[i] + 1 | Si &lt; Sn &amp;&amp; i &lt; n}</code></p></li><li><p>对于一个长度为 $N$ 的序列，最长递增子序列并不一定会以 $S_N$ 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p><ul><li>如：nums = [1,3,6,7,9,4,10,5,6] $\Rightarrow$ dp = {1,2,3,4,5,3,6,4,5}，但dp[N]并不是最大值。</li></ul></li></ul><p><img data-src="https://img-blog.csdnimg.cn/20200409215713844.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trbTA5,size_16,color_FFFFFF,t_70#pic_center" width="70%"></p><p>3.最终代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> dp[numsSize], m;<span class="comment">//m用于记录序列长度最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        m = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;<span class="comment">//遍历nums[0, i)，与nums[i]比较，若是递增，则记录</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                m = max(dp[j] + <span class="number">1</span>, m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    m = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; m)</span><br><span class="line">            m = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(1)$</p><hr><h1 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63. 不同路径 II"></a>63. 不同路径 II</h1><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能<strong>向下或者向右移动一步</strong>。机器人试图达到网格的右下角（在下图中标记为“Finish”）。<br>现在考虑网格中<strong>有障碍物</strong>。那么从左上角到右下角将会有多少条不同的路径？<br><br>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。<br><strong>说明：</strong> m 和 n 的值均不超过 100。</p></blockquote><p><strong>解题思路：</strong></p><p>这道题和62题相比，多了一个“障碍物的要求”，实质是：遍历到<code>obstacleGrid[i][j] == 1</code>时，</p><ul><li>若是第一行或第一列，则不能继续往右或往下走，即：<code>dp[i...m-1][0] = 0</code>，<code>dp[0][j...n-1] = 0</code></li><li>其余情况只需要绕开：<code>dp[i][j] = 0</code></li></ul><p><img data-src="https://img-blog.csdnimg.cn/20200410162516578.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2trbTA5,size_16,color_FFFFFF,t_70" width="70%"></p><p>1.定义数组元素含义</p><ul><li>定义<code>dp[i][j]</code>表示走到(i, j)处总共的路径数，则返回值为<code>dp[m - 1][n - 1]</code></li></ul><p>2.定义状态转移方程</p><ul><li>根据上面分析的结论，可以得到：<ul><li>if(obstacleGrid[i][j] == 1)    dp[i][j] == 0;</li><li>if(obstacleGrid[i][j] == 0)    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</li></ul></li></ul><p>3.初始化<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//第一列，遇到障碍物的下方都不能走</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][j] != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">   dp[<span class="number">0</span>][j] = <span class="number">0</span>;   <span class="comment">//第一行，遇到障碍物的右方都不能走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.最终代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>** obstacleGrid, <span class="keyword">int</span> obstacleGridSize, <span class="keyword">int</span>* obstacleGridColSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGridSize, n = *obstacleGridColSize;</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> dp[m][n], flag = <span class="number">0</span>;<span class="comment">//flag用于判断第一行或第一列是否遇到障碍物</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">//第一列，遇到障碍物的下方都不能走</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    flag = <span class="number">0</span>;<span class="comment">//初始化flag</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][j] != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;   <span class="comment">//第一行，遇到障碍物的右方都不能走</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度：$O(n^2)$<br>空间复杂度：$O(1)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自CSDN博文&lt;a href=&quot;https://blog.csdn.net/kkm09/article/details/105354607&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《【LeetCode 笔记】动态规划》&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="http://0202zc.github.io/2020/03/30/algorithm/algorithm-single-number/"/>
    <id>http://0202zc.github.io/2020/03/30/algorithm/algorithm-single-number/</id>
    <published>2020-03-30T03:04:08.000Z</published>
    <updated>2020-04-08T11:35:14.971Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">136. Single Number</a><br><a id="more"></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><a href="https://leetcode-cn.com/problems/single-number/solution/hua-jie-suan-fa-136-zhi-chu-xian-yi-ci-de-shu-zi-b/" target="_blank" rel="noopener">解题思路</a></h1><ul><li><p>标签：位运算</p></li><li><p>本题根据题意，线性时间复杂度 $O(n)$，很容易想到使用 Hash 映射来进行计算，遍历一次后结束得到结果，但是在空间复杂度上会达到 $O(n)$，需要使用较多的额外空间</p></li><li>既满足时间复杂度又满足空间复杂度，就要提到位运算中的异或运算 XOR，主要因为异或运算有以下几个特点：<ul><li>一个数和 0 做 XOR 运算等于本身： a ⊕ 0 = a</li><li>一个数和其本身做 XOR 运算等于 0： a ⊕ a = 0</li><li>XOR 运算满足交换律和结合律： a ⊕ b ⊕ a = (a ⊕ a) ⊕ b = 0 ⊕ b = b</li></ul></li><li>故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字</li><li>时间复杂度：$O(n)$，空间复杂度：$O(1)$。</li></ul><p><img data-src="https://pic.leetcode-cn.com/7d1bd50370f8f2b60d7215ca12f2f5ac4f3cca801f68e4ef1053e8e3180ce74b-frame_00001.png" style="zoom:80%;"></p><p><img data-src="https://pic.leetcode-cn.com/ab397765b568b8547a9c4ef4b256a92e64b7cab698aa0cb656bb8285131524aa-frame_00002.png" alt=""></p><p><img data-src="https://pic.leetcode-cn.com/c7c3577c968692e02c0eb9baa8cb699575bb2338bd6023ced8e00508767ea8ec-frame_00003.png" style="zoom:80%;"></p><p><img data-src="https://pic.leetcode-cn.com/1b03b163501fecf12048ef8224a7c2c694af2289b5e071633f1fa7ef28b12b79-frame_00004.png" style="zoom:80%;"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        ans ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/single-number/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;136. Single Number&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="http://0202zc.github.io/2020/03/30/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://0202zc.github.io/2020/03/30/位运算/</id>
    <published>2020-03-30T01:46:22.000Z</published>
    <updated>2020-03-30T01:53:07.783Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://www.cnblogs.com/yrjns/p/11246163.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/yrjns/p/11246163.html" target="_blank" rel="noopener">位运算（&amp;、|、^、~、&gt;&gt;、&lt;&lt;）</a></a><br><a id="more"></a></p><h2 id="1-位运算概述"><a href="#1-位运算概述" class="headerlink" title="1. 位运算概述"></a>1. 位运算概述</h2><p>从现代计算机中所有的数据二进制的形式存储在设备中。即0、1两种状态，计算机对二进制数据进行的运算(+、-、*、/)都是叫位运算，即将符号位共同参与运算的运算。</p><p>口说无凭，举一个简单的例子来看下CPU是如何进行计算的，比如这行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">47</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure><p>计算两个数的和，因为在计算机中都是以二进制来进行运算，所以上面我们所给的int变量会在机器内部先转换为二进制在进行相加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">35</span>:  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">47</span>:  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">————————————————————</span><br><span class="line"><span class="number">82</span>:  <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>所以，相比在代码中直接使用(+、-、*、/)运算符，合理的运用位运算更能显著提高代码在机器上的执行效率。</p><h2 id="2-位运算概览"><a href="#2-位运算概览" class="headerlink" title="2. 位运算概览"></a>2. 位运算概览</h2><table><thead><tr><th>符号</th><th>描述</th><th style="text-align:left">运算规则</th></tr></thead><tbody><tr><td>&amp;</td><td>与</td><td style="text-align:left">两个位都为1时，结果才为1</td></tr><tr><td>\</td><td></td><td style="text-align:left">或</td><td>两个位都为0时，结果才为0</td></tr><tr><td>^</td><td>异或</td><td style="text-align:left">两个位相同为0，相异为1</td></tr><tr><td>~</td><td>取反</td><td style="text-align:left">0变1，1变0</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td style="text-align:left">各二进位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移</td><td style="text-align:left">各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><h2 id="3-按位与运算符（-amp-）"><a href="#3-按位与运算符（-amp-）" class="headerlink" title="3. 按位与运算符（&amp;）"></a>3. 按位与运算符（&amp;）</h2><p>定义：参加运算的两个数据，按二进制位进行“与”运算。</p><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>&amp;<span class="number">0</span>=<span class="number">0</span>  <span class="number">0</span>&amp;<span class="number">1</span>=<span class="number">0</span>  <span class="number">1</span>&amp;<span class="number">0</span>=<span class="number">0</span>  <span class="number">1</span>&amp;<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：两位同时为<strong>1</strong>，结果才为<strong>1</strong>，否则结果为<strong>0</strong>。</p><p>例如：<code>3&amp;5</code> 即 0000 0011&amp; 0000 0101 = 0000 0001，因此 3&amp;5 的值得1。</p><p>注意：负数按<strong>补码</strong>形式参加按位与运算。</p><p>与运算的用途：</p><p><strong>1）清零</strong></p><p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p><p><strong>2）取一个数的指定位</strong></p><p>比如取数 X=1010 1110 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X&amp;Y=0000 1110）即可得到X的指定位。</p><p><strong>3）判断奇偶</strong></p><p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((a &amp; 1) == 0)</code>代替<code>if (a % 2 == 0)</code>来判断a是不是偶数。</p><h2 id="4-按位或运算符（-）"><a href="#4-按位或运算符（-）" class="headerlink" title="4. 按位或运算符（|）"></a>4. 按位或运算符（|）</h2><p>定义：参加运算的两个对象，按二进制位进行“或”运算。</p><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>|<span class="number">0</span>=<span class="number">0</span>  <span class="number">0</span>|<span class="number">1</span>=<span class="number">1</span>  <span class="number">1</span>|<span class="number">0</span>=<span class="number">1</span>  <span class="number">1</span>|<span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象只要有一个为1，其值为1。</p><p>例如：<code>3|5</code>即 0000 0011| 0000 0101 = 0000 0111，因此，<code>3|5</code>的值得7。　</p><p>注意：负数按<strong>补码</strong>形式参加按位或运算。</p><p>或运算的用途：</p><p><strong>1）常用来对一个数据的某些位设置为1</strong></p><p>比如将数 X=1010 1110 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1111）即可得到。</p><h2 id="5-异或运算符（-）"><a href="#5-异或运算符（-）" class="headerlink" title="5. 异或运算符（^）"></a>5. 异或运算符（^）</h2><p>定义：参加运算的两个数据，按二进制位进行“异或”运算。</p><p>运算规则：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>^<span class="number">0</span>=<span class="number">0</span>  <span class="number">0</span>^<span class="number">1</span>=<span class="number">1</span>  <span class="number">1</span>^<span class="number">0</span>=<span class="number">1</span>  <span class="number">1</span>^<span class="number">1</span>=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p><p>异或的几条性质:</p><p>1、交换律</p><p>2、结合律 (a^b)^c == a^(b^c)</p><p>3、对于任何数x，都有 x^x=0，x^0=x</p><p>4、自反性: a^b^b=a^0=a;</p><p>异或运算的用途：</p><p><strong>1）翻转指定位</strong></p><p>比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。</p><p><strong>2）与0相异或值不变</strong></p><p>例如：1010 1110 ^ 0000 0000 = 1010 1110</p><p><strong>3）交换两个数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a != b)&#123;</span><br><span class="line">        a ^= b;</span><br><span class="line">        b ^= a;</span><br><span class="line">        a ^= b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-取反运算符"><a href="#6-取反运算符" class="headerlink" title="6. 取反运算符 (~)"></a>6. 取反运算符 (~)</h2><p>定义：参加运算的一个数据，按二进制进行“取反”运算。<br>运算规则：　</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">1</span> = <span class="number">0</span></span><br><span class="line">~<span class="number">0</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结：对一个二进制数按位取反，即将0变1，1变0。</p><p>异或运算的用途：</p><p><strong>1）使一个数的最低位为零</strong></p><p>使a的最低位为0，可以表示为：<code>a &amp; ~1</code>。~1的值为 1111 1111 1111 1110，再按”与”运算，最低位一定为0。因为“ ~”运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。</p><h2 id="7-左移运算符（-lt-lt-）"><a href="#7-左移运算符（-lt-lt-）" class="headerlink" title="7. 左移运算符（&lt;&lt;）"></a>7. 左移运算符（&lt;&lt;）</h2><p>定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</p><p>设 a=1010 1110，<code>a = a&lt;&lt; 2</code> 将a的二进制位左移2位、右补0，即得a=1011 1000。</p><p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p><h2 id="8-右移运算符（-gt-gt-）"><a href="#8-右移运算符（-gt-gt-）" class="headerlink" title="8.右移运算符（&gt;&gt;）"></a>8.右移运算符（&gt;&gt;）</h2><p>定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p><p>例如：a=a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p><p>操作数每右移一位，相当于该数除以2。</p><h2 id="10-复合赋值运算符"><a href="#10-复合赋值运算符" class="headerlink" title="10.复合赋值运算符"></a>10.复合赋值运算符</h2><p>位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;=`    例：`a&amp;=b  `相当于   `a=a&amp;b</span><br><span class="line">|=`    例：`a|=b  `相当于   `a=a|b</span><br><span class="line">&gt;&gt;=`   例：`a&gt;&gt;=b  `相当于   `a=a&gt;&gt;b</span><br></pre></td></tr></table></figure><p><code>&lt;&lt;=</code>   例：<code>a&lt;&lt;=b</code>   相当于   `a=a&lt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^=`    例：`a^=b  `相当`于  a=a^b</span><br></pre></td></tr></table></figure><p>运算规则：和前面讲的复合赋值运算符的运算规则相似。</p><p><strong>不同长度的数据进行位运算：</strong>如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。</p><p>以“与运算”为例说明如下：我们知道在C语言中long型占4个字节，int型占2个字节，如果一个long型数据与一个int型数据进行“与运算“，右端对齐后，左边不足的位依下面三种情况补足，</p><p>1）如果整型数据为正数，左边补16个0。</p><p>2）如果整型数据为负数，左边补16个1。</p><p>3）如果整形数据为无符号数，左边也补16个0。</p><p>如：<code>long a=123</code>；<code>int b=1</code>；计算a &amp; b。</p><p>如：<code>long a=123</code>；<code>int b=-1</code>；计算a &amp; b。</p><p>如：<code>long a=123</code>；<code>unsigned int b=1</code>；计算a &amp; b。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://www.cnblogs.com/yrjns/p/11246163.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/yrjns/p/11246163.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;位运算（&amp;amp;、|、^、~、&amp;gt;&amp;gt;、&amp;lt;&amp;lt;）&lt;/a&gt;&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>移动零</title>
    <link href="http://0202zc.github.io/2020/03/16/algorithm/algorithm-move-zeros/"/>
    <id>http://0202zc.github.io/2020/03/16/algorithm/algorithm-move-zeros/</id>
    <published>2020-03-16T01:23:33.000Z</published>
    <updated>2020-04-08T11:35:53.537Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. Move Zeroes</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 $0$ 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> [0,1,0,3,12]<br><strong>输出:</strong> [1,3,12,0,0]</p></blockquote><p><strong>说明:</strong></p><pre><code>1. 必须在原数组上操作，不能拷贝额外的数组。2. 尽量减少操作次数。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>方法：双指针</strong><br>用两个指针i, j从头到尾依次遍历，遇到零元素就记录位置，遇到非零元素就进行替换零的操作<br>当一个指针i进行完一次遍历，此时非零元素已经全部移动到前面的位置，只需要将剩余位置上的元素置为零即可</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;   <span class="comment">//遇到非零元素进行替换零</span></span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else 继续查找非零元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将剩余位置上的元素置为零</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; numsSize)&#123;</span><br><span class="line">        nums[j++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;283. Move Zeroes&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数</title>
    <link href="http://0202zc.github.io/2020/03/15/algorithm/algorithm-find-the-duplicate-number/"/>
    <id>http://0202zc.github.io/2020/03/15/algorithm/algorithm-find-the-duplicate-number/</id>
    <published>2020-03-15T15:42:16.000Z</published>
    <updated>2020-04-08T11:36:29.769Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/find-the-duplicate-number" target="_blank" rel="noopener">287. Find the Duplicate Number</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含 $n + 1$ 个整数的数组 <code>nums</code>，其数字都在 $1$ 到 $n$ 之间（包括 $1$ 和 $n$），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入:</strong> [1,3,4,2,2]<br><strong>输出:</strong> 2</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入:</strong> [3,1,3,4,2]<br><strong>输出:</strong> 3</p></blockquote><p><strong>说明：</strong></p><blockquote><p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 $O(1)$ 的空间。<br>时间复杂度小于 $O(n^2)$ 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/" target="_blank" rel="noopener">解题思路</a></h3><p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。</p><p><strong>方法：二分查找</strong><br><strong>思路：</strong>这道题要求我们查找的数是一个整数，并且给出了这个整数的范围（在 $1$ 和 $n$ 之间，包括 $1$ 和 $n$），并且给出了一些限制，于是可以使用二分查找法定位在一个区间里的整数。</p><p>这个问题应用二分法与绝大多数其它问题应用二分法的不同点是：正着思考是容易的，即思考哪边区间存在重复数是容易的，因为依然是有抽屉原理做保证。我们依然通过一个具体的例子来分析应该如何编写代码。</p><p>以 <code>[1, 2, 2, 3, 4, 5, 6, 7]</code> 为例，一共 8 个数，<code>n + 1 = 8</code>，<code>n = 7</code>，根据题目意思，每个数都在 <code>1</code> 和 <code>7</code> 之间。</p><p>例如：区间 <code>[1, 7]</code> 的中位数是 <code>4</code>，遍历整个数组，统计小于等于 <code>4</code> 的整数的个数，至多应该为 <code>4</code> 个。换句话说，整个数组里小于等于 <code>4</code> 的整数的个数如果严格大于 <code>4</code> 个，就说明重复的数存在于区间 <code>[1, 4]</code>，它的反面是：重复的数存在于区间 <code>[5, 7]</code>。</p><p>于是，二分法的思路是先猜一个数（有效范围 <code>[left, right]</code>里的中间数 <code>mid</code>），然后统计原始数组中<strong>小于或等于</strong>这个中间数的元素的个数 <code>cnt</code>，如果 <code>cnt</code> <strong>严格大于</strong> <code>mid</code>，（注意我加了着重号的部分“小于或等于”、“严格大于”）依然根据抽屉原理，重复元素就应该在区间 <code>[left, mid]</code> 里。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = numsSize - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= mid)</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据抽屉原理，严格小于 4 的数的个数如果大于等于 4 个，</span></span><br><span class="line">        <span class="comment">// 此时重复元素一定出现在 [1, 3] 区间里</span></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; mid)</span><br><span class="line">            <span class="comment">// 重复的元素一定出现在 [left, mid - 1] 区间里</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// if 分析正确了以后，else 搜索的区间就是 if 的反面</span></span><br><span class="line">            <span class="comment">// [mid, right]</span></span><br><span class="line">            <span class="comment">// 注意：此时需要调整中位数的取法为上取整</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：$O(NlogN)$，二分法的时间复杂度为 $O(logN)$，在二分法的内部，执行了一次 <code>for</code> 循环，时间复杂度为 $O(N)$，故时间复杂度为 $O(NlogN)$。<br>空间复杂度：$O(1)$，使用了一个 <code>cnt</code> 变量，因此空间复杂度为 $O(1)$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/find-the-duplicate-number&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;287. Find the Duplicate Number&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>搜索旋转数组</title>
    <link href="http://0202zc.github.io/2020/03/15/algorithm/algorithm-search-rotate-array-lcci/"/>
    <id>http://0202zc.github.io/2020/03/15/algorithm/algorithm-search-rotate-array-lcci/</id>
    <published>2020-03-15T02:38:52.000Z</published>
    <updated>2020-04-08T11:35:28.506Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/" target="_blank" rel="noopener">面试题 10.03. Search Rotate Array LCCI</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p><p><strong>示例1:</strong></p><blockquote><p><strong>输入:</strong> arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5<br><strong>输出:</strong> 8（元素5在该数组中的索引）</p></blockquote><p><strong>示例2:</strong></p><blockquote><p><strong>输入：</strong>arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11<br><strong>输出：</strong>-1 （没有找到）</p></blockquote><p><strong>提示:</strong></p><blockquote><p>arr 长度范围在[1, 1000000]之间</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><a href="https://leetcode-cn.com/problems/search-rotate-array-lcci/solution/er-fen-fa-by-armeria-program/" target="_blank" rel="noopener"><strong>二分法</strong></a><br>对于能判断升序区间的情况，根据目标值的大小移动边界。<br>对于不能判断升序区间的情况，需要逐步清除重复值。</p><p>没有重复值的最优情况时间复杂度是$O(log N)$，全部或几乎全部是重复值的最差情况时间复杂度是$O(N)$。</p><!--                                     `nums[left] <= target`                                ┌─  `&& target <= nums[mid]`   ──>  `right = mid`                                              │   （目标在左边的升序区间中）      （右边界移动到mid）  ┌─  nums[left] < nums[mid] ─┼  │     （左边区间升序）       │  │                           └─    否则目标在右半边        ──>  `left = mid + 1`  │                                                             （左边界移动到mid+1）  │                 │                                 `nums[left] <= target`    │                           ┌─  `|| target <= nums[mid]`   ──>  `right = mid`                │                           │    （目标在左半边）              （右边界移动到mid） ─┼─  nums[left] > nums[mid] ─┼       │     （左边不是升序）       │  │                           └─    否则目标在右半边        ──>  `left = mid + 1`   │                                                             （左边界移动到mid+1）  │                 │                               │                           ┌─   `nums[left] != target`    ──>  `left++`                  │                           │     （左值不等于目标              （需要逐一清理重复值）          └─ nums[left] == nums[mid] ─┼         说明还没找到）      （可能是已经找到了目标    │        也可能是遇到了重复值）  └─   `nums[left] == target`    ──>  `right = left`                                    （左值等于目标                （将右边界移动到left，循环结束）                                      已经找到最左边的目标值） --><p><img data-src="/images/algorithm/Search-Rotate-Array-Lcci.jpg" alt=""></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> arrSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = arrSize - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;                                         <span class="comment">// 循环结束条件left==right</span></span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;                              <span class="comment">// 如果左值小于中值，说明左边区间升序               </span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt;= nums[mid]) &#123;     <span class="comment">// 如果目标在左边的升序区间中，右边界移动到mid</span></span><br><span class="line">                    right = mid;                                       </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                               <span class="comment">// 否则目标在右半边，左边界移动到mid+1</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;                                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;                       <span class="comment">// 如果左值大于中值，说明左边不是升序，右半边升序</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target || target &lt;= nums[mid]) &#123;     <span class="comment">// 如果目标在左边，右边界移动到mid</span></span><br><span class="line">                    right = mid;                                       </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                               <span class="comment">// 否则目标在右半边，左边界移动到mid+1</span></span><br><span class="line">                    left = mid + <span class="number">1</span>;                                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] == nums[mid]) &#123;                      <span class="comment">// 如果左值等于中值，可能是已经找到了目标，也可能是遇到了重复值</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] != target) &#123;                            <span class="comment">// 如果左值不等于目标，说明还没找到，需要逐一清理重复值。</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                               <span class="comment">// 如果左值等于目标，说明已经找到最左边的目标值 </span></span><br><span class="line">                    right = left;                                      <span class="comment">// 将右边界移动到left，循环结束</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (nums[left] == target) ? left : <span class="number">-1</span>;                     <span class="comment">// 返回left，或者-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/search-rotate-array-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 10.03. Search Rotate Array LCCI&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>反转链表 II</title>
    <link href="http://0202zc.github.io/2020/03/12/algorithm/algorithm-reverse-linked-list-ii/"/>
    <id>http://0202zc.github.io/2020/03/12/algorithm/algorithm-reverse-linked-list-ii/</id>
    <published>2020-03-12T09:48:25.000Z</published>
    <updated>2020-04-08T11:35:33.206Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse Linked List II</a><br><a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p><strong>示例:</strong></p><blockquote><p><strong>输入:</strong> <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code>, <code>m = 2</code>, <code>n = 4</code><br><strong>输出:</strong> <code>1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></p></blockquote><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>用四个指针分别指向第 $(m - 1)$、$m$、$n$、$(n + 1)$ 个元素</li><li>从第 $m$ 个元素到第 $n$ 个元素断链，将其逆置，得到新链表<code>newLink</code>（设置头结点以便操作）</li><li>再将原链表衔接起来</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverse</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = head;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseBetween</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || m &gt; n)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">H</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    H-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">start</span> = <span class="title">H</span>, *<span class="title">end</span> = <span class="title">H</span>, *<span class="title">preStart</span> = <span class="title">start</span>, *<span class="title">rearEnd</span> = <span class="title">end</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m) &#123;</span><br><span class="line">            preStart = start;</span><br><span class="line">            start = start-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        end = end-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    rearEnd = end-&gt;next;</span><br><span class="line">    end-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    t = start;</span><br><span class="line">    preStart-&gt;next = reverse(start);</span><br><span class="line">    t-&gt;next = rearEnd;</span><br><span class="line">    <span class="keyword">return</span> H-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>实现思路 ：以1-&gt;2-&gt;3-&gt;4-&gt;5, m = 2, n=4 为例:</p><ul><li>定位到要反转部分的头节点 2，head = 2；前驱结点 1，pre = 1；</li><li>当前节点的下一个节点3调整为前驱节点的下一个节点 1-&gt;3-&gt;2-&gt;4-&gt;5,</li><li>当前结点仍为2， 前驱结点依然是1，重复上一步操作。。。</li><li>1-&gt;4-&gt;3-&gt;2-&gt;5.</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseBetween</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> = <span class="title">dummy</span>, *<span class="title">nxt</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) </span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    head = pre-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt; n; i++)&#123;</span><br><span class="line">        nxt = head-&gt;next;</span><br><span class="line">        head-&gt;next = nxt-&gt;next;</span><br><span class="line">        nxt-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = nxt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;92. Reverse Linked List II&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>算法集（改）</title>
    <link href="http://0202zc.github.io/2020/03/07/%E7%AE%97%E6%B3%95%E9%9B%86(%E6%94%B9)/"/>
    <id>http://0202zc.github.io/2020/03/07/算法集(改)/</id>
    <published>2020-03-07T03:08:09.000Z</published>
    <updated>2020-04-08T12:08:42.764Z</updated>
    
    <content type="html"><![CDATA[<p>对算法集.doc的整理，好像都是真题（一部分算法题，一部分是填空、改错等）<br><a id="more"></a></p><h1 id="筛选法求素数"><a href="#筛选法求素数" class="headerlink" title="筛选法求素数"></a>筛选法求素数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PWIDTH 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> sieve[SIZE];</span><br><span class="line"><span class="keyword">int</span> i, n, printcol;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">sieve[i] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//存放100以内的素数标识</span></span><br><span class="line"></span><br><span class="line">sieve[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//1表示不是素数</span></span><br><span class="line">printcol = <span class="number">0</span>; <span class="comment">//行计数</span></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">1</span>; n &lt;= SIZE; n++) &#123;</span><br><span class="line"><span class="keyword">if</span> (sieve[n - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, n);</span><br><span class="line"><span class="keyword">if</span> (++printcol &gt;= PWIDTH) &#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">printcol = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = n; i &lt;= SIZE; i = i + n) &#123;</span><br><span class="line"><span class="comment">//i的倍数(i += n)全为合数</span></span><br><span class="line">sieve[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串交换"><a href="#字符串交换" class="headerlink" title="字符串交换"></a>字符串交换</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">char</span> **q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *temp;</span><br><span class="line">temp = *p;</span><br><span class="line">*p = *q;</span><br><span class="line">*q = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str1 = <span class="string">"aaaa"</span>, *str2 = <span class="string">"bbb"</span>;</span><br><span class="line">swap(&amp;str1, &amp;str2);</span><br><span class="line"><span class="built_in">puts</span>(str1);</span><br><span class="line"><span class="built_in">puts</span>(str2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j, k, a[N + <span class="number">1</span>], *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>, p = a; p &lt;= a + N; i++, p++) &#123;</span><br><span class="line">*p = i;</span><br><span class="line">&#125;   <span class="comment">//填充序号</span></span><br><span class="line">p = a + <span class="number">1</span>; <span class="comment">//取值</span></span><br><span class="line">k = N; <span class="comment">//统计剩余人数</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; k != <span class="number">1</span>; p++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p &gt; a + N) &#123;</span><br><span class="line">p = a + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="comment">//若越界，返回数组首部，开始下一轮</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (j % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">*p = <span class="number">0</span>;</span><br><span class="line">k--;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">//判断是否为3</span></span><br><span class="line">j++;</span><br><span class="line">&#125; <span class="comment">//判断是否被推出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最后剩下的数字是：%d\n"</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求第k小"><a href="#求第k小" class="headerlink" title="求第k小"></a>求第k小</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[MAXN] = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>&#125;, n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入n值：\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, search(a, <span class="number">10</span>, n));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low, high, i, j, t;</span><br><span class="line">k--;</span><br><span class="line">low = <span class="number">0</span>;</span><br><span class="line">high = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">i = low;</span><br><span class="line">j = high;</span><br><span class="line">t = a[low];</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; t &lt;= a[j]) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">a[i] = a[j];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; t &gt; a[i]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">a[j] = a[i];</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; j);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下开始进行二分查找，找到第k个位置</span></span><br><span class="line"><span class="keyword">if</span> (i == k) &#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; k) &#123;</span><br><span class="line">low = i + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">high = i - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (low &lt; high);</span><br><span class="line"><span class="keyword">return</span> a[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将字符串中的数字提取到数组中"><a href="#将字符串中的数字提取到数组中" class="headerlink" title="将字符串中的数字提取到数组中"></a>将字符串中的数字提取到数组中</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_int</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">char</span> *pc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[] = <span class="string">"ues11tc2015jsj320#"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; find_int(arr, s); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_int</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">char</span> *pc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pc[i] != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'0'</span> &lt;= pc[i] &amp;&amp; pc[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line">sum = sum * <span class="number">10</span> + pc[i] - <span class="string">'0'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line">arr[j++] = sum;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输入20个数（浮点-整型），逆序存放到单链表中"><a href="#输入20个数（浮点-整型），逆序存放到单链表中" class="headerlink" title="输入20个数（浮点+整型），逆序存放到单链表中"></a>输入20个数（浮点+整型），逆序存放到单链表中</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">float</span> y;</span><br><span class="line">&#125; data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line">node *L;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">Creatlist</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">node *r;</span><br><span class="line">r = Creatlist(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r) &#123;</span><br><span class="line"><span class="keyword">if</span> (r-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, r-&gt;data.x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1f "</span>, r-&gt;data.y);</span><br><span class="line">&#125;</span><br><span class="line">r = r-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">node *<span class="title">Creatlist</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, f;</span><br><span class="line">node *L, *p;</span><br><span class="line">L = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入第%d个数字的标志位："</span>, i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;f); <span class="comment">//若标志位0，则输入整型，否则输入浮点型</span></span><br><span class="line">p = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">p-&gt;flag = f;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数据:"</span>);</span><br><span class="line"><span class="keyword">if</span> (f == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p-&gt;data.x);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>, &amp;p-&gt;data.y);</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = L;</span><br><span class="line">L = p;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求最高分分数学生的编号"><a href="#求最高分分数学生的编号" class="headerlink" title="求最高分分数学生的编号"></a>求最高分分数学生的编号</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line">&#125; stu;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HighScore</span><span class="params">(stu *p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stu arr[N];</span><br><span class="line">HighScore(arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HighScore</span><span class="params">(stu *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">stu *r, q;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入学生的编号和分数: \n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d,%d"</span>, &amp;p[i].num, &amp;p[i].score);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 直接进行大小比较</span></span><br><span class="line"><span class="comment">int num = p[0].num;</span></span><br><span class="line"><span class="comment">max = p[0].score;</span></span><br><span class="line"><span class="comment">for(i = 1; i &lt; N; i++) &#123;</span></span><br><span class="line"><span class="comment">if(max &lt; p[i].score) &#123;</span></span><br><span class="line"><span class="comment">max = p[i].score;</span></span><br><span class="line"><span class="comment">num = p[i].num;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("最大：%d, %d\n", num, max);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">r = &amp;p[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[j].score &lt; p[i].score) &#123;</span><br><span class="line">r = &amp;p[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//一轮遍历找出余下数据中的最小者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换数据</span></span><br><span class="line">q.num = r-&gt;num;</span><br><span class="line">q.score = r-&gt;score;</span><br><span class="line"></span><br><span class="line">r-&gt;num = p[i].num;</span><br><span class="line">r-&gt;score = p[i].score;</span><br><span class="line"></span><br><span class="line">p[i].num = q.num;</span><br><span class="line">p[i].score = q.score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max = p[N - <span class="number">1</span>].score;</span><br><span class="line"><span class="keyword">for</span> (i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i].score == max) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, p[i].num, p[i].score);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符数组逆置"><a href="#字符数组逆置" class="headerlink" title="字符数组逆置"></a>字符数组逆置</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdefg"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line"><span class="keyword">char</span> p;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span><br><span class="line">p = *(str + i);</span><br><span class="line">*(str + i) = *(str + len - i - <span class="number">1</span>);</span><br><span class="line">*(str + len - i - <span class="number">1</span>) = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2个字符串是否相等"><a href="#2个字符串是否相等" class="headerlink" title="2个字符串是否相等"></a>2个字符串是否相等</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>], str2[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> *p, *q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入两个字符串，中间用空格隔开\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, str1, str2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %s"</span>, str1, str2);</span><br><span class="line">getchar();</span><br><span class="line">p = str1;</span><br><span class="line">q = str2;</span><br><span class="line"><span class="keyword">if</span> (*p != *q) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n两个字符串不相等\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> ((*p == *q) &amp;&amp; (*p != <span class="string">'\0'</span>) &amp;&amp; (*q != <span class="string">'\0'</span>)) &#123;</span><br><span class="line">p++;</span><br><span class="line">q++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((*p == <span class="string">'\0'</span>) &amp;&amp; (*q == <span class="string">'\0'</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n两个字符串相等\n"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n两个字符串不相等\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="传地址"><a href="#传地址" class="headerlink" title="传地址"></a>传地址</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (*t-- = <span class="number">3</span>) - <span class="number">1</span>; <span class="comment">//</span></span><br><span class="line">&#125; <span class="comment">//t得到p的地址1，地址1中内容被赋值为3，函数返回值为2，t--移动到地址0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr + <span class="number">1</span>;  <span class="comment">//p得到数组的地址1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, func(p) + *p); <span class="comment">//p依旧在地址1 其值为3 | func(p) == 2，*p == 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="地址理解"><a href="#地址理解" class="headerlink" title="地址理解"></a>地址理解</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;arr[<span class="number">1</span>];</span><br><span class="line">p[<span class="number">1</span>] = *p - <span class="number">1</span> + (p[<span class="number">-1</span>] = <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一个交错级数求和"><a href="#一个交错级数求和" class="headerlink" title="一个交错级数求和"></a>一个交错级数求和</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入数值x及项数n：\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, sum(x, n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">double</span> a, b, s;</span><br><span class="line">s = <span class="number">1.0</span>;</span><br><span class="line">a = b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">a = a * x;</span><br><span class="line">b = b * i;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">s = s + a / b;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = s - a / b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="去掉字符串中的字母数字和重复项"><a href="#去掉字符串中的字母数字和重复项" class="headerlink" title="去掉字符串中的字母数字和重复项"></a>去掉字符串中的字母数字和重复项</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">81</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> *s = <span class="string">"UE&amp;&amp;&amp;stc2018##@%"</span>;</span><br><span class="line">del(s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, arr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((*str) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="string">'a'</span> &lt;= *str &amp;&amp; *str &lt;= <span class="string">'z'</span>) || (<span class="string">'A'</span> &lt;= *str &amp;&amp; *str &lt;= <span class="string">'Z'</span>) || (<span class="string">'0'</span> &lt;= *str &amp;&amp; *str &lt;= <span class="string">'9'</span>)) &#123;</span><br><span class="line"><span class="comment">//arr[i]=*str;</span></span><br><span class="line">str++;</span><br><span class="line"><span class="comment">//i++;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (*str == *(str + <span class="number">1</span>)) &#123;</span><br><span class="line">str++;</span><br><span class="line">&#125;</span><br><span class="line">arr[i++] = *str++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对算法集.doc的整理，好像都是真题（一部分算法题，一部分是填空、改错等）&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回文链表</title>
    <link href="http://0202zc.github.io/2020/03/02/algorithm/algorithm-palindrome-linked-list/"/>
    <id>http://0202zc.github.io/2020/03/02/algorithm/algorithm-palindrome-linked-list/</id>
    <published>2020-03-02T03:38:10.000Z</published>
    <updated>2020-04-08T11:35:47.496Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>编写一个函数，检查输入的链表是否是回文的。</p><p><strong>示例 1：</strong></p><blockquote><p>输入： 1-&gt;2<br>输出： <code>false</code> </p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入： 1-&gt;2-&gt;2-&gt;1<br>输出： <code>true</code> </p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1、找中点的同时，将前半部倒序；<br>2、比较。<br>时间复杂度：$O(1)$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">L</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//找中点</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同时对前面进行反转（头插法）</span></span><br><span class="line">        head-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        head = slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//slow指向后半部分头结点，head指向前半部分头结点</span></span><br><span class="line">    <span class="keyword">if</span>(fast)</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    head = L-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前半部分和后半部分进行比较</span></span><br><span class="line">    <span class="keyword">while</span>(head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;val != slow-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;234. Palindrome Linked List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>二进制链表转整数</title>
    <link href="http://0202zc.github.io/2020/03/01/algorithm/algoritm-convert-binary-number-in-a-linked-list-to-integer/"/>
    <id>http://0202zc.github.io/2020/03/01/algorithm/algoritm-convert-binary-number-in-a-linked-list-to-integer/</id>
    <published>2020-03-01T05:20:47.000Z</published>
    <updated>2020-04-08T11:34:36.055Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/" target="_blank" rel="noopener">1290. Convert Binary Number in a Linked List to Integer</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你一个单链表的引用结点 <code>head</code>。链表中每个结点的值不是 <code>0</code> 就是 <code>1</code>。已知此链表是一个整数数字的二进制表示形式。</p><p>请你返回该链表所表示数字的 <strong>十进制值</strong> 。</p><p><strong>示例 1：</strong></p><p><img data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/15/graph-1.png" alt=""></p><blockquote><p><strong>输入：</strong><code>head = [1,0,1]</code><br><strong>输出：</strong><code>5</code><br><strong>解释：</strong>二进制数 (101) 转化为十进制数 (5)</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><code>head = [0]</code><br><strong>输出：</strong><code>0</code></p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1]</code><br><strong>输出：</strong><code>1</code></p></blockquote><p><strong>示例 4：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]</code><br><strong>输出：</strong><code>18880</code></p></blockquote><p><strong>示例 5：</strong></p><blockquote><p><strong>输入：</strong><code>head = [0,0]</code><br><strong>输出：</strong><code>0</code></p></blockquote><p>提示：</p><ul><li>链表不为空。</li><li>链表的结点总数不超过 <code>30</code>。</li><li>每个结点的值不是 <code>0</code> 就是 <code>1</code>。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>采用<strong>位运算</strong>，<code>result &lt;&lt; 1</code> 就相当于 <code>result * 2</code>, <code>result |= 1（result |= 0）</code> 相当于 <code>result++</code>（不变）</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ans = ans * <span class="number">2</span> + cur-&gt;val;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1290. Convert Binary Number in a Linked List to Integer&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>环路检测</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm/algorithm-linked-list-cycle-lcci/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm/algorithm-linked-list-cycle-lcci/</id>
    <published>2020-02-29T04:29:05.000Z</published>
    <updated>2020-04-08T11:36:07.556Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">面试题 02.08. Linked List Cycle LCCI</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong><code>head = [3,2,0,-4]</code>, <code>pos = 1</code><br><strong>输出：</strong>tail connects to node index 1<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1,2]</code>, <code>pos = 0</code><br><strong>输出：</strong>tail connects to node index 0<br><strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1]</code>, <code>pos = -1</code><br><strong>输出：</strong>no cycle<br><strong>解释：</strong>链表中没有环。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>经典的快慢指针问题，这里给出C的解法。</p><blockquote><ol><li>设置快慢指针</li><li>找到第一次相遇【快慢指针相遇】</li><li>再出发慢指针【从头结点出发的慢指针与快指针】</li><li>相遇即所求</li></ol></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 如果相遇了就break</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fast到了链表尾部,说明链表无环</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 慢指针从头开始, 快慢指针再一次相遇就是在环的起点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 02.08. Linked List Cycle LCCI&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>重排链表</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm/algorithm-reorder-list/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm/algorithm-reorder-list/</id>
    <published>2020-02-29T03:19:36.000Z</published>
    <updated>2020-04-08T11:35:38.352Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. Reorder List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><hr><p>给定一个单链表 $L：L_0→L_1→…→Ln-1→L_n$ ，<br>将其重新排列后变为： $L_0→L_n→L_1→Ln-1→L_2→Ln-2→…$</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4</code>, 重新排列为 <code>1-&gt;4-&gt;2-&gt;3</code>.</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, 重新排列为 <code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</p></blockquote><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, 重新排列为 <code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</p></blockquote><p>通过观察，可以将重排链表分解为以下三个步骤：</p><ol><li>首先重新排列后，链表的中心节点会变为最后一个节点。所以需要先找到链表的中心节点：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. 链表的中间结点</a></li><li>可以按照中心节点将原始链表划分为左右两个链表。<ol><li>按照中心节点将原始链表划分为左右两个链表，左链表：<code>1-&gt;2-&gt;3</code> 右链表：<code>4-&gt;5</code>。</li><li>将右链表反转，就正好是重排链表交换的顺序，右链表反转：<code>5-&gt;4</code>。反转链表：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></li></ol></li><li>合并两个链表，将右链表插入到左链表，即可重新排列成：<code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用快慢指针,找出链表的中心节点</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过递归反转链表</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">p</span>;</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = head;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 合并两个链表，将右链表插入到左链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(struct ListNode* left, struct ListNode* right)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">leftTemp</span>, *<span class="title">rightTemp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge的循环时候条件应为: 当右链表为空的时候,就结束循环</span></span><br><span class="line">    <span class="comment">// 原因是: </span></span><br><span class="line">    <span class="comment">//     1.你取了中心节点的next为右链表的head, 那么两者的长度一定是  左链表 &gt; 右链表</span></span><br><span class="line">    <span class="comment">//     2. 当原始链表为:  奇数 左链表=右链表+1 ; 偶数 左链表=右链表+2</span></span><br><span class="line">    <span class="comment">// 所以: 只用判断右链表的节点是否为空就可以了,而不用判断左链表. 左链表的next肯定有值.</span></span><br><span class="line">    <span class="keyword">while</span>(right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//1. 保存next节点</span></span><br><span class="line">        leftTemp = left-&gt;next;</span><br><span class="line">        rightTemp = right-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将右链表的第一个节点插入到左链表中</span></span><br><span class="line">        <span class="comment">// 左链表：1-&gt;2-&gt;3 右链表：5-&gt;4 </span></span><br><span class="line">        <span class="comment">// 合并后的左链表：1-&gt;5-&gt;2-&gt;3</span></span><br><span class="line">        left-&gt;next = right;</span><br><span class="line">        right-&gt;next = leftTemp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 移动left和right指针</span></span><br><span class="line">        <span class="comment">// 左链表变为：2-&gt;3 右链表变为：4</span></span><br><span class="line">        left = leftTemp;</span><br><span class="line">        right = rightTemp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用快慢指针,找出链表的中心节点。</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5,中心节点为3</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">middle</span> = <span class="title">middleNode</span>(<span class="title">head</span>);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将原始链表按照中心链表分割为两个链表，并将右链表反转</span></span><br><span class="line">    <span class="comment">// 2.1 原始链表：1-&gt;2-&gt;3-&gt;4-&gt;5 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">left</span> = <span class="title">head</span>, *<span class="title">right</span> = <span class="title">middle</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    middle-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 反转右链表</span></span><br><span class="line">    <span class="comment">//原始右链表：4-&gt;5 反转后：5-&gt;4</span></span><br><span class="line">    right = reverseList(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 合并两个链表，将右链表插入到左链表</span></span><br><span class="line">    <span class="comment">// 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5 合并后：1-&gt;5-&gt;2-&gt;4-&gt;3</span></span><br><span class="line">    mergeList(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reorder-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;143. Reorder List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>链表的中间结点</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm/algorithm-middle-of-the-linked-list/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm/algorithm-middle-of-the-linked-list/</id>
    <published>2020-02-29T01:56:03.000Z</published>
    <updated>2020-04-08T11:35:57.773Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. Middle of the Linked List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong><code>[1,2,3,4,5]</code><br><strong>输出：</strong>此列表中的结点 <code>3</code> (序列化形式：[3,4,5])<br>返回的结点值为 <code>3</code> 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 <code>ListNode</code> 类型的对象 <code>ans</code>，这样：<br><code>ans.val = 3</code>, <code>ans.next.val = 4</code>, <code>ans.next.next.val = 5</code>, 以及 <code>ans.next.next.next = NULL</code>.</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><code>[1,2,3,4,5,6]</code><br><strong>输出：</strong>此列表中的结点 <code>4</code> (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 <code>3</code> 和 <code>4</code>，我们返回第二个结点。</p></blockquote><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>先求出链表的长度 <code>length</code>，再进行计数遍历，遍历到 <code>length / 2</code> 为止，返回该结点。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">LinkLength</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">         head = head-&gt;next;</span><br><span class="line">         len++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> len;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> len = LinkLength(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>设置<strong>快慢指针</strong> <code>fast</code>，<code>slow</code>。其中 <code>fast</code> 的步长为 $2$，<code>slow</code> 的步长为 $1$，那么在相同时间的前提下 <code>fast</code> 走过的链表长度就是 <code>slow</code> 走过长度的<strong>两倍</strong>。当 <code>fast</code> 抵达链表末尾时，<code>slow</code> 恰好指向链表的中间结点，此时 <code>return slow</code>。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;876. Middle of the Linked List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="http://0202zc.github.io/2020/02/16/algorithm/algorithm-remove-nth-node-from-end-of-list/"/>
    <id>http://0202zc.github.io/2020/02/16/algorithm/algorithm-remove-nth-node-from-end-of-list/</id>
    <published>2020-02-16T04:28:04.000Z</published>
    <updated>2020-04-08T11:35:41.580Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，删除链表的倒数第 $n$ 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><blockquote><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong>n = 2</strong>.</p></blockquote><blockquote><p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.<br>说明：</p></blockquote><p>给定的 $n$ 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>快慢指针，快指针先走n步，然后快慢一起走，直到快指针走到最后，要注意的是可能是要删除第一个节点，这个时候可以直接返回<code>head -&gt; next</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head -&gt; next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast)&#123;</span><br><span class="line">        <span class="keyword">return</span> head -&gt; next;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast -&gt; next)&#123;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow -&gt; next = slow -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h3><h4 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><blockquote><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong>k = 2</strong>.</p></blockquote><blockquote><p>返回链表 <strong>4-&gt;5</strong>.</p></blockquote><h5 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h5><p>与上面思路相同，使用快慢指针同步移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">getKthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; fast != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol><li>先得到链表<code>head</code>的长度<code>len</code> –&gt; 用来动态申请数组<code>returnArray</code></li><li>遍历链表，把其中的元素赋值给数组<code>returnArray</code></li><li>数组内部进行逆置</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, i=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">int</span> *returnArray = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        returnArray[i++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = returnArray[i];</span><br><span class="line">        returnArray[i] = returnArray[len - i - <span class="number">1</span>];</span><br><span class="line">        returnArray[len - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    (*returnSize) = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;19. Remove Nth Node From End of List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>有序循环数组查找值</title>
    <link href="http://0202zc.github.io/2020/02/12/algorithm/algorithm-ordering-and-circulate/"/>
    <id>http://0202zc.github.io/2020/02/12/algorithm/algorithm-ordering-and-circulate/</id>
    <published>2020-02-12T06:01:34.000Z</published>
    <updated>2020-04-08T11:35:49.782Z</updated>
    
    <content type="html"><![CDATA[<p>有序循环数组查找<strong>指定值</strong><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个有序循环数组array[]，不知其升序还是降序，也不知其起点在哪里。请编程寻找指定元素。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先通过中间值和最后一个或者第一个元素比较，找出局部有序范围，再通过<strong>二分查找</strong>局部有序段</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sortArrFindOne</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == target)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; arr[high]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target &amp;&amp; target &lt;= arr[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(arr, mid, high, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArrFindOne(arr, low, mid, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] &lt;= target &amp;&amp; target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(arr, low, mid, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArrFindOne(arr, mid, high, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>找局部有序（二分递归查找）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span>  + low;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(arr, mid + <span class="number">1</span>, high, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(arr, low, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有序循环数组查找&lt;strong&gt;指定值&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>反转字符串中的单词 III</title>
    <link href="http://0202zc.github.io/2020/02/10/algorithm/algorithm-reverse-words-in-a-string-iii/"/>
    <id>http://0202zc.github.io/2020/02/10/algorithm/algorithm-reverse-words-in-a-string-iii/</id>
    <published>2020-02-10T11:08:43.000Z</published>
    <updated>2020-04-08T11:35:31.185Z</updated>
    
    <content type="html"><![CDATA[<p>From LeetCode <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii" target="_blank" rel="noopener">557. Reverse Words in a String III</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: “Let’s take LeetCode contest”<br>输出: “s’teL ekat edoCteeL tsetnoc”<br><strong>注意：</strong>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h4><p>第一眼看上去是反转字符串，而反转字符串的形式有所不同——并不是整体反转，而是单个单词进行反转，所有单词相对位置不变。<br>(我第一次提交的时候没有注意到，因此有了以下代码)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">    temp = s[i];</span><br><span class="line">    s[i] = s[len-i<span class="number">-1</span>];</span><br><span class="line">    s[len-i<span class="number">-1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此代码是反转整个字符串，与线性表的反转类似【见<a href="https://0202zc.github.io/2020/01/18/algorithm-reverse-linerlist/">就地逆置线性表元素</a>】</p><blockquote><p>输入：”Let’s take LeetCode contest”<br>输出：<font color="#CD5C5C">“tsetnoc edoCteeL ekat s’teL”</font><br>预期：<font color="#008000">“s’teL ekat edoCteeL tsetnoc”</font></p></blockquote><h4 id="正确解题思路"><a href="#正确解题思路" class="headerlink" title="正确解题思路"></a>正确解题思路</h4><ul><li>记录s的长度len</li><li>若s为空或只有一个字符，则直接返回</li><li>否则<ul><li>使用r记录翻转后的字符串，用start指向每一个单词的第一个字母，end指向该单词的最后一个字符（遇到空格或者结束符就停下）</li><li>将start到end之间的字符复制到r中</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>来源：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/cyu-yan-by-kdurant/" target="_blank" rel="noopener">LeetCode - kdurant</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> || len == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * r = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="keyword">char</span> *start = s, *end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++, s++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">' '</span> || *s == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(end = s - <span class="number">1</span>; end &gt;= start; end--)&#123;</span><br><span class="line">                r[index++] = *end;</span><br><span class="line">            &#125;</span><br><span class="line">            r[index++] = (*s == <span class="string">' '</span>) ? <span class="string">' '</span> : (*s = <span class="string">'\0'</span>);</span><br><span class="line">            start = s + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(n)$, 空间复杂度$O(n)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string-iii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;557. Reverse Words in a String III&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://0202zc.github.io/2020/02/09/algorithm/algorithm-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://0202zc.github.io/2020/02/09/algorithm/algorithm-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2020-02-09T03:10:32.000Z</published>
    <updated>2020-04-08T11:36:04.452Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 3. Longest Substring Without Repeating Characters<br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<br><strong>示例 1:</strong></p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题主要用到思路是：滑动窗口</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 <code>abcabcbb</code>，进入这个队列（窗口）为 <code>abc</code> 满足题目要求，当再进入 <code>a</code>，队列变成了 <code>abca</code>，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p>时间复杂度：$O(n)$</p><p><img data-src="https://pic.leetcode-cn.com/d7a5c09ca134fed8250408fb1bbde0032ae4ecc45a1be3133e5c1855bcb2bbe7-1.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/c94cc222f6d272a20c72e9eb23bf664f8967f38bd6c53d0b396c82e2951b27b5-2.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/c10a1b15727ca49bf991690c40eb5db94a9199a81a8162f86a7f0f283ad8198b-3.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/d5aba4bfea1d0b0d6fc31fb6cefd8b2e5489bcf7e1b77b81cc74cea3ec7c5853-4.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/215d944bde59087836aa4f5aad4514177fd1acc9707386413e40678a8406262e-5.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/3acbd78605394f8dbf3ce96f25867e73851837224ef65596ad354500b0e3a181-6.jpg" alt=""></p><p><em>图片来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-cshi-xian-/" target="_blank" rel="noopener">无重复字符的最长子串 c++实现三种解法 多重循环，hashmap优化，桶优化</a></em></p><h4 id="滑动窗口题目"><a href="#滑动窗口题目" class="headerlink" title="滑动窗口题目"></a>滑动窗口题目</h4><ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank">30. 串联所有单词的子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. 至多包含两个不同字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank">239. 滑动窗口最大值</a></li><li><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range/" target="_blank">632. 最小区间</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-subsequence/" target="_blank">727. 最小窗口子序列</a></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j, k, max = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//j 作为外部循环变量，遍历字符串的每一个元素</span></span><br><span class="line">    <span class="comment">//i 初始指向当前检测到的重复元素的下一个元素索引</span></span><br><span class="line">    <span class="comment">//k 用于遍历从 i 到 j 的子串</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = i; k &lt; j; k++)</span><br><span class="line">            <span class="keyword">if</span>(s[k] == s[j]) &#123;</span><br><span class="line">                i = k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; max)</span><br><span class="line">            max = j - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 3. Longest Substring Without Repeating Characters&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://0202zc.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
