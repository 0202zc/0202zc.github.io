<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L..z、℃的博客</title>
  
  <subtitle>Be unfazed by defeat.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0202zc.github.io/"/>
  <updated>2020-02-10T11:13:58.333Z</updated>
  <id>http://0202zc.github.io/</id>
  
  <author>
    <name>0202zc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>反转字符串中的单词 III</title>
    <link href="http://0202zc.github.io/2020/02/10/algorithm-reverse-words-in-a-string-iii/"/>
    <id>http://0202zc.github.io/2020/02/10/algorithm-reverse-words-in-a-string-iii/</id>
    <published>2020-02-10T11:08:43.000Z</published>
    <updated>2020-02-10T11:13:58.333Z</updated>
    
    <content type="html"><![CDATA[<p>From LeetCode <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii" target="_blank" rel="noopener">557. Reverse Words in a String III</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: “Let’s take LeetCode contest”<br>输出: “s’teL ekat edoCteeL tsetnoc”<br><strong>注意：</strong>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string-iii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;557. Reverse Words in a String III&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://0202zc.github.io/2020/02/09/algorithm-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://0202zc.github.io/2020/02/09/algorithm-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2020-02-09T03:10:32.000Z</published>
    <updated>2020-02-09T05:53:24.919Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 3. Longest Substring Without Repeating Characters<br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<br><strong>示例 1:</strong></p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题主要用到思路是：滑动窗口</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 <code>abcabcbb</code>，进入这个队列（窗口）为 <code>abc</code> 满足题目要求，当再进入 <code>a</code>，队列变成了 <code>abca</code>，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p>时间复杂度：$O(n)$</p><p><img data-src="https://pic.leetcode-cn.com/d7a5c09ca134fed8250408fb1bbde0032ae4ecc45a1be3133e5c1855bcb2bbe7-1.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/c94cc222f6d272a20c72e9eb23bf664f8967f38bd6c53d0b396c82e2951b27b5-2.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/c10a1b15727ca49bf991690c40eb5db94a9199a81a8162f86a7f0f283ad8198b-3.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/d5aba4bfea1d0b0d6fc31fb6cefd8b2e5489bcf7e1b77b81cc74cea3ec7c5853-4.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/215d944bde59087836aa4f5aad4514177fd1acc9707386413e40678a8406262e-5.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/3acbd78605394f8dbf3ce96f25867e73851837224ef65596ad354500b0e3a181-6.jpg" alt=""></p><p><em>图片来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-cshi-xian-/" target="_blank" rel="noopener">无重复字符的最长子串 c++实现三种解法 多重循环，hashmap优化，桶优化</a></em></p><h4 id="滑动窗口题目"><a href="#滑动窗口题目" class="headerlink" title="滑动窗口题目"></a>滑动窗口题目</h4><ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank">30. 串联所有单词的子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. 至多包含两个不同字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank">239. 滑动窗口最大值</a></li><li><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range/" target="_blank">632. 最小区间</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-subsequence/" target="_blank">727. 最小窗口子序列</a></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j, k, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = i;k&lt;j;k++)</span><br><span class="line">            <span class="keyword">if</span>(s[k] == s[j]) &#123;</span><br><span class="line">                i = k+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; max)</span><br><span class="line">            max = j - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 3. Longest Substring Without Repeating Characters&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>操作系统、计算机网络、数据库系统概论等相关问题</title>
    <link href="http://0202zc.github.io/2020/02/05/os-network-db-questions/"/>
    <id>http://0202zc.github.io/2020/02/05/os-network-db-questions/</id>
    <published>2020-02-05T02:33:46.000Z</published>
    <updated>2020-02-05T03:32:37.456Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统、计算机网络、数据库系统概论等相关问题<br><a id="more"></a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="1-中断和陷入有什么异同？"><a href="#1-中断和陷入有什么异同？" class="headerlink" title="1. 中断和陷入有什么异同？"></a>1. 中断和陷入有什么异同？</h3><ol><li>外中断时指来自处理机和内存外部的中断,如I/O中断、定时器中断、外部信号中断等。狭义上也叫中断;</li><li>内中断主要指在处理机和内存内部产生的中断,也称陷入,如校验错、页面失效、溢出、除数为零等;</li><li>中断和陷阱的主要区别:<br>  (1) 陷入通常由处理机正在执行的现行指令引起,而中断则是由与现行指令无关的中断源引起的。<br>  (2) 陷阱处理程序提供的服务为当前进程所用,而中断处理程序提供的服务则不是为了当前进程的。<br>  (3) CPU在执行完一条指令之后,下一条指令开始之前响应中断,而在一条指令执行中也可以响应陷阱。</li></ol><h3 id="2-父子进程是否可以并发运行？"><a href="#2-父子进程是否可以并发运行？" class="headerlink" title="2. 父子进程是否可以并发运行？"></a>2. 父子进程是否可以并发运行？</h3><p>可以</p><h3 id="3-在没有程序运行时-CPU在做什么？"><a href="#3-在没有程序运行时-CPU在做什么？" class="headerlink" title="3. 在没有程序运行时, CPU在做什么？"></a>3. 在没有程序运行时, CPU在做什么？</h3><p>只要计算机打开着，CPU一定都在不停处理进程。在Windows系统下至少rundll32.exe这个程序是持续运行的。在linux下kernel也是会持续运行的。运行进程个数为零的时候有没有呢？有，那就是计算机关机的时候。</p><h3 id="4-设备驱动器是否属于操作系统，它的作用是什么？"><a href="#4-设备驱动器是否属于操作系统，它的作用是什么？" class="headerlink" title="4. 设备驱动器是否属于操作系统，它的作用是什么？"></a>4. 设备驱动器是否属于操作系统，它的作用是什么？</h3><p>不是，驱动程序是另外安装的软件，是操作系统控制并且和硬件之间通讯的桥梁（程序）</p><h3 id="5-线程、进程、程序和任务的区别"><a href="#5-线程、进程、程序和任务的区别" class="headerlink" title="5. 线程、进程、程序和任务的区别?"></a>5. 线程、进程、程序和任务的区别?</h3><ol><li>任务是最抽象的， 是一个一般性的术语， 指由软件完成的一个活动。一个任务既可以是一个进程,也可以是一个线程。简而言之,它指的是一系列共同达到某一目的的操  作。例如,读取数据并将数据放入内存中。这个任务可以作为一个进程来实现,也可以作为一个线程（或作为一个中断任务）来实现。   </li><li>进程常常被定义为程序的执行。可以把一个进程看成是一个独立的程序,在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。  </li><li>线程则是某一进程中一路单独运行的程序。也就是说， 线程存在于进程之中。一个进程由一个或多个线程构成， 各线程共享相同的代码和全局数据， 但各有其自己的堆栈。由于堆栈是每个线程一个， 所以局部变量对每一线程来说是私有的。由于所有线程共享同样的代码和全局数据，它们比进程更紧密，比单独的进程间更趋向于相互作用,线程间的相互作用更容易些,因为它们本身就有某些供通信用的共享内存：进程的全局数据进程的全局数据进程的全局数据进程的全局数据</li><li>程序只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体。</li></ol><h3 id="6-处理中断的过程"><a href="#6-处理中断的过程" class="headerlink" title="6. 处理中断的过程"></a>6. 处理中断的过程</h3><p>请求中断→响应中断→关闭中断→保留断点→中断源识别→保护现场→中断服务子程序→恢复现场→中断返回</p><h3 id="7-分页、分段、段页式的特点，为什么要引入？"><a href="#7-分页、分段、段页式的特点，为什么要引入？" class="headerlink" title="7. 分页、分段、段页式的特点，为什么要引入？"></a>7. 分页、分段、段页式的特点，为什么要引入？</h3><p>分页是为了提高内存的利用率，提高计算机性能，且分页通过硬件机制来实现，对用户完全透明。分段是为了方便编程，信息保护和共享、动态增长及动态链接等多方面的需要。段页式是两者的结合。</p><h3 id="8-计算机系统怎样实现存储保护？"><a href="#8-计算机系统怎样实现存储保护？" class="headerlink" title="8. 计算机系统怎样实现存储保护？"></a>8. 计算机系统怎样实现存储保护？</h3><ol><li>防止地址越界（对进程所产生的地址必须加以检查，发生越界时产生中断，由操作系统<br>进行相应处理）</li><li>防止操作越权（对属于自己区域的信息，可读可写：对公共区域中允许共享的信息或获得授权可使用的信息，可读而不可修改；对未授权使用的信息，不可读，不可写）</li></ol><h3 id="9-MMU-是-Memory-Management-Unit-的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。"><a href="#9-MMU-是-Memory-Management-Unit-的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。" class="headerlink" title="9. MMU 是 Memory Management Unit 的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。"></a>9. MMU 是 Memory Management Unit 的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。</h3><h3 id="10-多线程，真的提高了效率吗？"><a href="#10-多线程，真的提高了效率吗？" class="headerlink" title="10. 多线程，真的提高了效率吗？"></a>10. 多线程，真的提高了效率吗？</h3><p>多线程效率，我认为未必会高，而且有时候相反会低。<br>多线程并不是为了提高效率，而是不必等待  可以并行执行多条数据。<br>可以这么想：我们通过 xp 系统复制文件。你可以复制一份文件  这叫是单线呈，但是你要等这个复制完了才能复制另一份文件，而且不能多复制。这样很难受，所以你可以选择多复制文件,这就是多线程。但复制多份文件用的时间未必会比一份一份文件所用时间少。只是它合理利用了时间进行了多个操作。<br>如果是买票系统  就会用到多线呈。买票是同时进行的，如果一个用户一个用户等下去不是办法，所以可以多个用户同时买票，效率也就提高了。这里的效率不是执行的效率  而是时间的合理利用,多个线呈同时进行。</p><h3 id="11-中断的作用"><a href="#11-中断的作用" class="headerlink" title="11. 中断的作用"></a>11. 中断的作用</h3><p>中断是计算机系统结构一个重要的组成部分。在中断机制中的硬件部分(中断装置)<br>的作用就是在 CPU 每执行完一条指令后，判别是否有事件发生，如果没有事件发生，CPU<br>继续执行；若有事件发生，中断装置中断原先占用 CPU 的程序的执行，把被中断程序的断<br>点保存起来，让操作系统的处理服务程序占用 CPU 对事件进行处理，处理完后，再让被中<br>断的程序继续占用 CPU 执行下去。</p><h3 id="12-DMA-的优先级为什么比-CPU-的优先级高？"><a href="#12-DMA-的优先级为什么比-CPU-的优先级高？" class="headerlink" title="12. DMA 的优先级为什么比 CPU 的优先级高？"></a>12. DMA 的优先级为什么比 CPU 的优先级高？</h3><p>因为 DMA 请求得不到及时响应，I/O 传输数据可能会丢失</p><h3 id="13-虚拟内存容量由什么决定？"><a href="#13-虚拟内存容量由什么决定？" class="headerlink" title="13. 虚拟内存容量由什么决定？"></a>13. 虚拟内存容量由什么决定？</h3><p>虚拟存储区的容量与物理主存大小无关，而受限于计算机的地址结构和可用磁盘容量。</p><h3 id="14-RAID-的工作原理"><a href="#14-RAID-的工作原理" class="headerlink" title="14. RAID 的工作原理"></a>14. RAID 的工作原理</h3><p>RAID（独立磁盘冗余阵列（Redundant Array of Independent Disks））通过条带化存储和奇偶校验两个措施来实现其冗余和容错的目标。条带化存储意味着可以一次写入一个数据块的方式将文件写入多个磁盘。条带化存储技术将数据分开写入多个驱动器，从而提高数据传输速率并缩短磁盘处理总时间。这种系统非常适用于交易处理、但可靠性却很差，因为系统的可靠性等于最差的单个驱动器的可靠性。<br>奇偶校验通过在传输后对所有数据进行冗余校验可以确保数据的有效性。<br>利用奇偶校验，当 RAID 系统的一个磁盘发生故障时，其它磁盘能够重建该故障磁盘。在这两种情况中，这些功能对于操作系统都是透明的。由磁盘阵列控制器（DAC）进行条带化存储和奇偶校验控制。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-计算机网络和分布式计算机系统的区别"><a href="#1-计算机网络和分布式计算机系统的区别" class="headerlink" title="1. 计算机网络和分布式计算机系统的区别?"></a>1. 计算机网络和分布式计算机系统的区别?</h3><p>两者在计算机硬件连接、系统拓朴结构和通信控制等方面基本都是一样的,它们都具有通信和资源共享的功能。<br>区别关键在于:分布式计算机系统是在分布式计算机操作系统支持下,进行分布式数据库处理的,也就是说各互联的计算机可以互相协调工作,共同完成一项任务,多台计算机上并行运行。且具有透明性,用户不知道数据、资源的具体位置,整个网络中所有计算机就像是一台计算机一样;而计算机网络却不具备这种功能,计算机网络系统中的各计算机通常是各自独立进行工作的。</p><h3 id="2-波特和比特的区别"><a href="#2-波特和比特的区别" class="headerlink" title="2. 波特和比特的区别?"></a>2. 波特和比特的区别?</h3><p>波特是码元传输的踵率单位,说明每秒传多少个码元。码元传输速率也称为调制速率、波形速率或符号速率。<br>比恃是信息量的单位,与码元的传输速率”波特”是两个完全不同的概念。<br>但是,信息的传输速率”比特/秒”与码元的传输速率”波特”在数量上却有一定的关系。</p><h3 id="3-TCP-IP网络协议核心以及如何引出overeverything"><a href="#3-TCP-IP网络协议核心以及如何引出overeverything" class="headerlink" title="3. TCP/IP网络协议核心以及如何引出overeverything"></a>3. TCP/IP网络协议核心以及如何引出overeverything</h3><p>TCP/IP（传输控制协议/网间协议）是一种网络通信协议，它规范了网络上的所有通信设备，尤其是一个主机与另一个主机之间的数据往来格式以及传送方式。TCP/IP是INTERNET的基础协议，也是一种电脑数据打包和寻址的标准方法。<br>核心是OSI模型，共七层，第7层应用层，第6层表示层，第5层会话层，第4层传输层，第3层网络层，第2层数据链路层，第1层物理层，从第七层传到第一层，接受方则相反。 上三层总称应用层，用来控制软件方面。 下四层总称数据流层，用来管理硬件。<br>everything over IP：everything均以IP为基础，以后的网络中的设备都用IP（现在的电话网络就不是）。over：以…为基础。<br>IP over everything：在现在的电通信网过渡到光通信网的过程中，IP、ATM、WDM会配合使用，渐渐过渡，既是IP over everything。over：凌驾于…之上。</p><h3 id="4-电路交换与分组交换区别"><a href="#4-电路交换与分组交换区别" class="headerlink" title="4. 电路交换与分组交换区别"></a>4. 电路交换与分组交换区别</h3><ol><li><p>电路交换是以电路为目的的交换方式，即通信双方要通过电路建立联系，建立后没挂断则电路一直保持，实时性高。</p><p>而分组交换是把信息分为若干分组，每个分组有分组头含有选路和控制信息，可以到达收信方，但是不能即时通信。</p></li><li><p>分组交换通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。</p><p>电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。</p></li><li><p>分组交换由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。</p><p>电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用低。</p><p>若要传送的数据量很大，且其传送时间远大于呼叫时间，<br>则采用电路交换较为合适；<br>当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。<br>从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，<br>其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。</p></li></ol><h3 id="5-IPV4-和-IPV6-的区别"><a href="#5-IPV4-和-IPV6-的区别" class="headerlink" title="5. IPV4 和 IPV6 的区别"></a>5. IPV4 和 IPV6 的区别</h3><p>（1）IPV6 地址长度为 128 比特，地址增大了 296 倍；<br>（2）灵活的 IP 报文头部格式。使用一系列固定格式的扩展头部取代了 IPV4 中可变长度的选项字段。IPV6 中选项部分的出现方式也有所变化，使路由器可以简单路过选项而不做任何处理，加快了报文处理速度。<br>（3）IPV6 简化了报文头部格式，字段只有 7 个，加快报文转发，提高了吞吐量；<br>（4）提高安全性。身份认证和隐私权是 IPV6 的关键特性。<br>（5）支持更多的服务类型；<br>（6）允许协议继续演变，增加新的功能，使之适应未来技术的发展。</p><h3 id="6-TCP-的拥塞控制与流量控制的功能和区别？"><a href="#6-TCP-的拥塞控制与流量控制的功能和区别？" class="headerlink" title="6. TCP 的拥塞控制与流量控制的功能和区别？"></a>6. TCP 的拥塞控制与流量控制的功能和区别？</h3><p>1拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br>2流量控制：指点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收.</p><h3 id="7-集线器-路由器和交换机有什么区别"><a href="#7-集线器-路由器和交换机有什么区别" class="headerlink" title="7. 集线器,路由器和交换机有什么区别."></a>7. 集线器,路由器和交换机有什么区别.</h3><p><strong>集线器</strong>工作在第一层（即物理层），它没有智能处理能力，对它来说，数据只是电流而已，<br>当一个端口的电流传到集线器中时，它只是简单地将电流传送到其他端口，至于其他端口连接的计算机接收不接收这些数据，它就不管了。<br><strong>交换机</strong>工作在第二层（即数据链路层），它要比集线器智能一些，对它来说，网络上的数据就是 MAC 地址的集合，它能分辨出帧中的源 MAC 地址和目的 MAC 地址，因此可以在任意两个端口间建立联系，但是交换机并不懂得 IP 地址，它只知道 MAC 地址。<br><strong>路由器</strong>工作在第三层（即网络层），它比交换机还要“聪明”一些，它能理解数据中的 IP 地址，如果它接收到一个数据包，就检查其中的 IP地址，如果目标地址是本地网络的就不理会，如果是其他网络的，就将数据包转发出本地网络。</p><h3 id="8-P2P-网络编程的特点"><a href="#8-P2P-网络编程的特点" class="headerlink" title="8. P2P 网络编程的特点"></a>8. P2P 网络编程的特点</h3><p>P2P（对等网络，是一种有别于传统 C/S 客户/服务器式的分布式网络）直接将人们联系起来，让人们通过互联网直接交互。P2P 使得网络上的沟通变得容易、更直接共享和交互，真正地消除中间商。P2P 就是人可以直接连接到其他用户的计算机、交换文件，而不是像过去那样连接到服务器去浏览与下载。</p><h3 id="9-DNS-的递归查询与迭代查询"><a href="#9-DNS-的递归查询与迭代查询" class="headerlink" title="9. DNS 的递归查询与迭代查询"></a>9. DNS 的递归查询与迭代查询</h3><ol><li>递归查询:<br>  一般客户机和服务器之间属递归查询，即当客户机向 DNS 服务器发出请求后,若 DNS 服务<br>  器本身不能解析,则会向另外的 DNS 服务器发出查询请求，得到结果后转交给客户机； </li><li>迭代查询(反复查询):<br>  一般 DNS 服务器之间属迭代查询，如：若 DNS2 不能响应 DNS1 的请求，则它会将 DNS3<br>  的 IP 给 DNS2，以便其再向 DNS3 发出请求；</li></ol><h3 id="10-ARP-协议的过程"><a href="#10-ARP-协议的过程" class="headerlink" title="10. ARP 协议的过程"></a>10. ARP 协议的过程</h3><p>ARP 协议是“Address Resolution Protocol”（地址解析协议）的缩写。在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的 MAC 地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的 MAC 地址。但这个目标 MAC 地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标 IP 地址转换成目标 MAC 地址的过程。 ARP 协议的基本功能就是通过目标设备的 IP 地址，查询目标设备的 MAC 地址，以保证通信的顺利进行。</p><h3 id="11-计算机网络的接入类型都有哪些？"><a href="#11-计算机网络的接入类型都有哪些？" class="headerlink" title="11. 计算机网络的接入类型都有哪些？"></a>11. 计算机网络的接入类型都有哪些？</h3><p>局域网、城域网、广域网和互联网四种</p><h3 id="12-中继器，集线器，交换机，网桥，网关，路由器的功能作用-区别到底是什么？"><a href="#12-中继器，集线器，交换机，网桥，网关，路由器的功能作用-区别到底是什么？" class="headerlink" title="12. 中继器，集线器，交换机，网桥，网关，路由器的功能作用,区别到底是什么？"></a>12. 中继器，集线器，交换机，网桥，网关，路由器的功能作用,区别到底是什么？</h3><p>中继器： 物理层， 适用于完全相同的两类网络的互连，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。<br>集线器：物理层，基本功能信息分发，它把一个端口接收的所有信号向所有端口分发出去。<br>一些集线器在分发之前将弱信号重新生成。<br>中继器与集线器的区别：区别在于集线器能够提供多端口服务，也称为多口中继器。<br>网桥：数据链路层， 网桥（Bridge）像一个聪明的中继器， 网桥是一种对帧进行转发的技术，根据 MAC 分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来。</p><h2 id="数据库系统概论"><a href="#数据库系统概论" class="headerlink" title="数据库系统概论"></a>数据库系统概论</h2><h3 id="1-数据库安全性与操作系统安全性的关系"><a href="#1-数据库安全性与操作系统安全性的关系" class="headerlink" title="1. 数据库安全性与操作系统安全性的关系?"></a>1. 数据库安全性与操作系统安全性的关系?</h3><p>安全性问题不是数据库系统所独有的,所有计算机系统都有这个问题.只是在数据库系统中<br>大量数据集中存放,而且为许多最终用户直接共享,从而使安全性问题更为突出.系统安全保<br>护措施是否有效是数据库系统的主要指标之一.数据库的安全性和计算机系统的安全性,包<br>括操作系统,网络系统的安全性是紧密联系,相互支持的</p><h3 id="2-SQL-主键约束和唯一约束有什么区别呢？"><a href="#2-SQL-主键约束和唯一约束有什么区别呢？" class="headerlink" title="2. SQL 主键约束和唯一约束有什么区别呢？"></a>2. SQL 主键约束和唯一约束有什么区别呢？</h3><p>主键不能为空而唯一可以为空相同的就是都不允许重复</p><h3 id="3-什么是基本表？什么是视图？两者的区别和联系是什么？"><a href="#3-什么是基本表？什么是视图？两者的区别和联系是什么？" class="headerlink" title="3. 什么是基本表？什么是视图？两者的区别和联系是什么？"></a>3. 什么是基本表？什么是视图？两者的区别和联系是什么？</h3><p>表是实实在在得保存数据的实体,写入的数据都保存在表中,而视图  是不保存数据的,也没有数据.视图就是一条  语句,实际上视图从表中去数据.只是给我们的感觉好像直接从表中  取得一样.  表可以建立各种触发器,可以建立索引,可以建立主健,约束等.  但是视图不能建立这些对象( 视图可以建立替代触发器)  .  表和视图可以更新, 但是视图的更新受到约束.  比如,group  by  和表连接生成的视图不能更新表是实实在在得  保存数据的实体,  写入的数据都保存在表中,  而视图是不保存数据的,  也没有数据.</p><h3 id="4-数据库索引"><a href="#4-数据库索引" class="headerlink" title="4. 数据库索引"></a>4. 数据库索引</h3><p>目的：提供多种存储路径，加快查找速度。<br>建立索引需要考虑的问题： 1.没有查询、统计的需要则不建 2.数据增删改频繁，系统会花费许多时间来维护索引，从而降低了查询效率。</p><h3 id="5-哪些视图是可以更新、哪些是不可以更新的"><a href="#5-哪些视图是可以更新、哪些是不可以更新的" class="headerlink" title="5. 哪些视图是可以更新、哪些是不可以更新的"></a>5. 哪些视图是可以更新、哪些是不可以更新的</h3><ol><li>简单视图<br>就是由一个表生成出来的视图，这种情况你更新她就和更新表一样。</li><li>二次加工出来的简单视图<br>仍然是一个表出来的视图，但是视图中存在通过函数或计算二次加工出来的其他字段。更新的时候只要不更新这些加工出来的字段也是可以更新的。</li><li>组合视图<br>通过表之间关联联合等出来的复杂视图。这种视图更新的时候要注意你所更新的列要来自同一个表，也是可以更新的。</li><li>静态视图<br>这种视图等同于表可以直接更新，但是更新的数据尽在视图中反映出来，不反映到原表。</li><li>其他视图<br>通过表函数等其他生成的更为复杂的视图。一般不可更新。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统、计算机网络、数据库系统概论等相关问题&lt;br&gt;
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="计算机网络" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="数据库" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="操作系统" scheme="http://0202zc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OS" scheme="http://0202zc.github.io/tags/OS/"/>
    
      <category term="计算机网络" scheme="http://0202zc.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="数据库" scheme="http://0202zc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>复试英语口语</title>
    <link href="http://0202zc.github.io/2020/02/02/English-speaking-test/"/>
    <id>http://0202zc.github.io/2020/02/02/English-speaking-test/</id>
    <published>2020-02-02T10:03:15.000Z</published>
    <updated>2020-02-02T10:49:37.811Z</updated>
    
    <content type="html"><![CDATA[<p>~2020.02.02~<br><a id="more"></a></p><h4 id="1-self-introduction-自我介绍"><a href="#1-self-introduction-自我介绍" class="headerlink" title="(1). self-introduction (自我介绍)"></a>(1). self-introduction (自我介绍)</h4><p>Good morning, my dear teachers and professors. I am very happy to introduce myself. I am 陈琪, a 22-year-old boy graduated from <u>Chongqing University of Posts and Telecommunications</u>. My major was <u>Computer Science and Technology</u>. And I am very kind-hearted as well and ready to help others especially when they are in troubles. Owing to my kindness I made a lot of friends in university. In my spare time I like sports such as Ping-pong .I also took some part-time jobs as a family tutor. One of my students got his mark improved through our joint effort and I was very proud of that.This is all for my self-introduction. If I am lucky enough to get the chance, I will devote all myself to my major and focus all of my energy on it.</p><h4 id="2-reasons-for-my-choice-考研原因"><a href="#2-reasons-for-my-choice-考研原因" class="headerlink" title="(2). reasons for my choice (考研原因)"></a>(2). reasons for my choice (考研原因)</h4><p>Firstly, I think my major is very <strong>practical and useful</strong>. Through four years’study in university I find the knowledge I have <strong>mastered</strong> is not enough to <strong>solve some specific problems</strong>. So I decide to further my education.<br>Secondly,I can broaden my horizon and enrich the knowledge in this field through the postgraduate education. It is an indispensable step for my self-development in the future as well. </p><h4 id="3-plans-in-the-postgraduate-study-研究生期间你的计划"><a href="#3-plans-in-the-postgraduate-study-研究生期间你的计划" class="headerlink" title="(3). plans in the postgraduate study (研究生期间你的计划)"></a>(3). plans in the postgraduate study (研究生期间你的计划)</h4><p>Because my dream is to be a scientist , so i want to further my study when i become postgraduate. May be i will be a teacher in the university  at first.That’s my simple plan.</p><h4 id="4-about-hometown-介绍你的家乡"><a href="#4-about-hometown-介绍你的家乡" class="headerlink" title="(4). about hometown (介绍你的家乡)"></a>(4). about hometown (介绍你的家乡)</h4><p>I come from ZiGong of Sichuan province,which is famous for its salt industry and dinosaur fossils.<br>Known as home of dinosaur. What’s more? It is also a city of lights. Every year,there are a lot of tourist traveling here.</p><h4 id="5-about-family-你的家庭"><a href="#5-about-family-你的家庭" class="headerlink" title="(5). about family (你的家庭)"></a>(5). about family (你的家庭)</h4><p>I have a happy family .In my family, there are five members: grandfather, father, mother.My family is just like a hand, and each of us like a finger.<br>Mother worker, Father teacher. They love me ,we live harmoniously.</p><h4 id="6-about-university-你的大学"><a href="#6-about-university-你的大学" class="headerlink" title="(6). about university (你的大学)"></a>(6). about university (你的大学)</h4><p>My university is Chongqing university of Post and Telecommunication .it has digital libraries and labs. My university is famous for its 3G research and it is located in a small mountain which is beautiful and full of cherry blossom.There a fresh airs and warm atmosphere.</p><h4 id="7-plans-after-graduation-毕业后有什么打算"><a href="#7-plans-after-graduation-毕业后有什么打算" class="headerlink" title="(7). plans after graduation (毕业后有什么打算)"></a>(7). plans after graduation (毕业后有什么打算)</h4><p>After my graduation, I want to find a job in Chengdu and make good use of the theories I will have learned from this university.I want to become a teacher of university or a scientist .if possible ,After graduation, I want to further my study for a Doctor’s degree. Then I’ll work for a research institute. What satisfies me most is to make contributions for the whole earth.</p><h4 id="8-What-is-your-greatest-strength-你最突出的优点是什么？"><a href="#8-What-is-your-greatest-strength-你最突出的优点是什么？" class="headerlink" title="(8).What is your greatest strength? (你最突出的优点是什么？)"></a>(8).What is your greatest strength? (你最突出的优点是什么？)</h4><p>I am good at math and programming, because i can solve a problem by myself independent and improve in a short time without others’ help.</p><h4 id="要求重复询问"><a href="#要求重复询问" class="headerlink" title="要求重复询问"></a>要求重复询问</h4><p>Sorry, I did not catch/follow your meaning. Pardon, please.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;~2020.02.02~&lt;br&gt;
    
    </summary>
    
      <category term="English" scheme="http://0202zc.github.io/categories/English/"/>
    
    
      <category term="English" scheme="http://0202zc.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>C语言中变量存储位置</title>
    <link href="http://0202zc.github.io/2020/02/01/C-variable-storage-2/"/>
    <id>http://0202zc.github.io/2020/02/01/C-variable-storage-2/</id>
    <published>2020-02-01T06:28:06.000Z</published>
    <updated>2020-02-01T06:44:12.011Z</updated>
    
    <content type="html"><![CDATA[<p>局部变量、静态局部变量、静态全局变量…<br><a id="more"></a></p><h3 id="一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？"><a href="#一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？" class="headerlink" title="一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？"></a>一、C语言中，常量存储在哪儿？<code>static</code>全局变量和<code>static</code>局部变量存储在哪儿？</h3><p>全局变量（外部变量）的说明之前再冠以<code>static</code>就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于</p><blockquote><p><strong>非静态全局变量的作用域是整个源程序，</strong><br><strong>当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的，</strong><br><strong>而静态全局变量则限制了其作用域。</strong><br><strong>即只在定义该变量的源文件内有效，</strong></p></blockquote><p>在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</p><h3 id="二、static全局变量与普通的全局变量有什么区别？"><a href="#二、static全局变量与普通的全局变量有什么区别？" class="headerlink" title="二、static全局变量与普通的全局变量有什么区别？"></a>二、<code>static</code>全局变量与普通的全局变量有什么区别？</h3><ul><li><strong><code>static</code>全局变量只初始化一次</strong>，防止在其他文件单元中被是引用。</li></ul><h3 id="三、static局部变量与普通的局部变量有什么区别？"><a href="#三、static局部变量与普通的局部变量有什么区别？" class="headerlink" title="三、static局部变量与普通的局部变量有什么区别？"></a>三、<code>static</code>局部变量与普通的局部变量有什么区别？</h3><ul><li><strong><code>static</code>局部变量只被初始化一次</strong>，下一次依据上一次结果值。</li></ul><h3 id="四、局部变量、静态局部变量、静态全局变量存储位置"><a href="#四、局部变量、静态局部变量、静态全局变量存储位置" class="headerlink" title="四、局部变量、静态局部变量、静态全局变量存储位置"></a>四、局部变量、静态局部变量、静态全局变量存储位置</h3><table><thead><tr><th>变量类型</th><th>存储位置</th></tr></thead><tbody><tr><td>局部变量</td><td>静态区（全局区）</td></tr><tr><td>局部静态变量</td><td>静态区（全局区）的常量区</td></tr><tr><td>全局静态变量</td><td>静态区（全局区）</td></tr></tbody></table><h3 id="五、各存储区的定义"><a href="#五、各存储区的定义" class="headerlink" title="五、各存储区的定义"></a>五、各存储区的定义</h3><ol><li><p><strong>栈区（stack）</strong> —— 由编译器自动分配释放，存放<u>函数的参数值，局部变量的值</u>等，其操作方式类似于数据结构中的栈。</p></li><li><p><strong>堆区（heap）</strong> —— 一般由程序员分配释放。若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p></li><li><p><strong>全局区（静态区）（static）</strong> —— <u>全局变零和静态变量</u>的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，- <em>程序结束后由系统释放</em>。</p></li><li><p><strong>文字常量区</strong> —— <u>常量字符串</u>就是放在这里的。- <em>程序结束后由系统释放</em>。</p></li><li><p><strong>程序代码区</strong> —— <u>存放函数体的二进制代码</u>。</p></li></ol><h3 id="六、NOTES"><a href="#六、NOTES" class="headerlink" title="六、NOTES"></a>六、NOTES</h3><ol><li><p><strong>栈</strong>，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。</p></li><li><p><strong>堆</strong>，就是那些由<code>new</code>分配的内存块，他们的释放编译器不去管，由应用程序控制，一般一个<code>new</code>就要对应一个<code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p></li><li><p><strong>自由存储区</strong>，就是那些由<code>malloc</code>分配的内存块，它和堆十分相似，不过它是用<code>free</code>来结束自己的生命。</p></li><li><p><strong>全局/静态存储区</strong>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，<em>在C++里面没有这个区分</em>，它们共同占用一块内存区。</p></li><li><p><strong>常量存储区</strong>，这是一块比较特殊的存储区，它们存放的是常量，<strong>不允许被修改</strong>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;局部变量、静态局部变量、静态全局变量…&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C语言效率问题</title>
    <link href="http://0202zc.github.io/2020/01/31/C-efficiency/"/>
    <id>http://0202zc.github.io/2020/01/31/C-efficiency/</id>
    <published>2020-01-31T15:13:35.000Z</published>
    <updated>2020-01-31T15:14:27.489Z</updated>
    
    <content type="html"><![CDATA[<p>来源：UESTC考研群<br><a id="more"></a></p><ul><li><p>编译器可以将代码编译为汇编语言，然后转换为机器语言，并且编译器可以在编译时进行优化，例如gcc可以进行五级优化</p></li><li><p>采用宏去定义一些函数，提高效率 比如#define MAX(x,y) ((x)&gt;(y)?(x):(y))</p></li><li><p>可以使用位操作来替代乘法除法 比如计算机网络中进行CRC检验</p></li><li><p>可以在程序效率低的地方嵌入汇编语言提高程序效率</p></li><li><p>可以使用指针直接操作内存，提高效率</p></li><li><p>可以使用内联函数（C99标准添加，之前宏定义）</p></li><li><p>可以使用寄存器变量（register），提高变量存取速度</p></li><li><p>复合的赋值运算符的使用，比如i-=1效率大于i=i-1，可以提高程序的编译效率</p></li><li><p>自增自减运算符的使用，比如i++和i–</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：UESTC考研群&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>指针与自增优先级的问题</title>
    <link href="http://0202zc.github.io/2020/01/29/C-pointer-and-increase/"/>
    <id>http://0202zc.github.io/2020/01/29/C-pointer-and-increase/</id>
    <published>2020-01-29T09:54:17.000Z</published>
    <updated>2020-01-29T10:04:00.283Z</updated>
    
    <content type="html"><![CDATA[<p>在我们面试时，经常会有一些关于运算符优先级的题目，今天就给大家展示一个常出现的例子。<br><a id="more"></a><br>问题：定义一个数组 <code>int a[10]={1,2,3,4,5,6,7,8,9,0}; int *p=a;</code> 则 <code>cout&lt;&lt;*p++&lt;&lt;endl;</code> </p><p>由此问题我们可以看出来，其想考察的是C++程序设计的运算符的优先级以及后自增的知识点。我们查看优先级表格表格可以得到后自增（<code>++</code>）运算符优先于取值运算符（<code>*</code>），因此<code>（*p++）</code>等价于<code>(*(p++))</code>。</p><p>求值顺序得到了，我们下面的任务就是要分析后自增的实现原理了，我们参考了《C++ primer 第五版》（503页）讲解的知识如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strBlobPtr strBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">strBlobPtr为定义的一个类名，operator++（int）为重载后自增运算符，参数int为区分前自增还是后自增</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       strBlobPtr ret =*<span class="keyword">this</span>;</span><br><span class="line">       ++*<span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在后自增的运算符实现的步骤中，先返回值，再自增，因此（<code>*p++</code>）计算过程为先运算<code>p++</code>（结果为<code>p</code>指向的地址<code>a</code>）,再对指针求值<code>*p</code>,得到<code>a[0]</code>.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*p:"</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*p++:"</span> &lt;&lt; *p++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们面试时，经常会有一些关于运算符优先级的题目，今天就给大家展示一个常出现的例子。&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C语言中变量存储类型和生存周期</title>
    <link href="http://0202zc.github.io/2020/01/28/C-variable-storage/"/>
    <id>http://0202zc.github.io/2020/01/28/C-variable-storage/</id>
    <published>2020-01-28T01:55:14.000Z</published>
    <updated>2020-01-28T03:33:46.819Z</updated>
    
    <content type="html"><![CDATA[<p>内容来自谭浩强的《C语言程序设计》总结<br><a id="more"></a></p><blockquote><p>原文链接：<a href="https://blog.csdn.net/wuyuzun/article/details/82432355" target="_blank" rel="noopener">https://blog.csdn.net/wuyuzun/article/details/82432355</a></p></blockquote><h3 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h3><ol><li><p>数据类型：浮点型，整型，字符型等都是一个数据类型；</p></li><li><p>数据存储类型：数据在内存中的存储方式；（这是本博文要讨论的重点）<br>注意：数据类型和数据存储类型都是针对于声明或定义的函数和变量而言的；</p></li><li><p>动态存储类型：变量或函数，在被使用时临时分配内存单元，在函数结束后所占用的内存单元将会被释放，例如局部变量；因此，动态存储的变量每次被调用时所占的内存单元的地址可能会发生改变；</p></li><li><p>静态存储类型：变量或函数，在程序运行期间编译器统一分配内存单元，直到程序结束分配的内存才被释放；例如：全局变量；</p></li></ol><h3 id="内存中供用户使用的存储空间"><a href="#内存中供用户使用的存储空间" class="headerlink" title="内存中供用户使用的存储空间"></a>内存中供用户使用的存储空间</h3><table><thead><tr><th>用户区</th><th>存储内容</th></tr></thead><tbody><tr><td>程序区</td><td>CPU指令</td></tr><tr><td>静态存储区</td><td>全部的全局变量，局部静态变量</td></tr><tr><td>动态存储区</td><td>被调用函数的形参；被调用函数中非局部静态变量；函数调用时的现场保护和返回地址等</td></tr></tbody></table><p><strong>注：</strong></p><ol><li>在平时编程过程中，一般对变量和函数的声明和定义都应同时指定数据类型和数据存储类型；如果我们没有对变量进行指定数据存储类型；</li><li>在定义全局变量和局部静态变量时，如果没有赋初始值，系统会默认为0；而动态变量们竟会被随机赋值；</li></ol><h3 id="局部变量的存储类型"><a href="#局部变量的存储类型" class="headerlink" title="局部变量的存储类型"></a>局部变量的存储类型</h3><h4 id="1-自动变量—auto"><a href="#1-自动变量—auto" class="headerlink" title="1. 自动变量—auto"></a>1. <strong>自动变量—auto</strong></h4><p>定义：函数中，包括复合语句内和形式参数在内的变量中，不被<code>static</code>限制的变量；</p><p>性质：动态存储类型，系统调用函数时临时分配内存单元；函数执行结束就占用的内存释放；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fun1(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span>  <span class="comment">//形式参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> b = <span class="number">0</span>;    <span class="comment">//函数内不被static限制,且函数每次被调用，b的值都会被赋0；</span></span><br><span class="line">    b++;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c;  <span class="comment">//函数内复合语句内；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img data-src="https://img-blog.csdn.net/20180906000827834?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eXV6dW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>注：大多数情况下，自动变量是可以直接省略<code>auto</code>的，系统也会默认为自动变量；</p><h4 id="2-静态局部变量—static"><a href="#2-静态局部变量—static" class="headerlink" title="2. 静态局部变量—static"></a>2. <strong>静态局部变量—static</strong></h4><p>定义：函数内被静态<code>static</code>限制的局部变量；静态局部变量在函数执行结束时，内存不被释放，函数下次被执行的时候，此变量的值并不改变；</p><p>性质：静态存储类型，函数每次被调用其值还是上次函数执行时的值，且默认的初始化的值是$0$；</p><p>举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fun1(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b=a;   <span class="comment">//第一次执行函数后被b被赋初值，</span></span><br><span class="line">                      <span class="comment">//以后再执行函数后b将不会再被赋值；</span></span><br><span class="line">    b--;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><img data-src="https://img-blog.csdn.net/20180906000326874?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eXV6dW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h4 id="3-寄存器变量—register变量"><a href="#3-寄存器变量—register变量" class="headerlink" title="3. 寄存器变量—register变量"></a>3. <strong>寄存器变量—register变量</strong></h4><p>定义：存放在CPU寄存器中的变量；（寄存器存储类型也是随着函数的结束，内存被释放）</p><p>形式：<code>register int a = 1;</code> \将定义的a送到寄存器中；</p><p>说明：寄存器这个名词如果是学过单片机的同志肯定是知道的，对于单片机功能的实现，基本上都是靠配置寄存器实现的；寄存器是什么，参考<a href="https://blog.csdn.net/wuyuzun/article/details/74171359" target="_blank" rel="noopener">《存储器》</a>；</p><p>性质：CPU能够快速读写寄存器变量；</p><p>优点：一般来说，程序中定义，<strong>声明的变量是放在内存中的</strong>，例如全局变量存储在静态存储器中，对一个全局变量的每次读写操作都是CPU和内存之间的传输；但是寄存器变量是把变量存储在CPU的寄存器中，由于寄存器的读写传输速度很快，所以非常适合处理一些程序中被高频使用的变量；</p><p>缺点：CPU寄存器数量有限，不适合定义太多寄存器变量；</p><p><strong>注意：</strong><br>目前计算器处理速度越来越快，加上C语言IDE对于代码的优化越来越好，所以有时即使我们不去定义或声明一个寄存器变量，IDE也会把高频使用的变量默认声明为寄存器变量；所以在平时的编程时，并不用过于强调寄存器变量。</p><h3 id="全局变量的存储类型"><a href="#全局变量的存储类型" class="headerlink" title="全局变量的存储类型"></a>全局变量的存储类型</h3><p>外部变量：定义在函数外的变量，也可以说就是全局变量；</p><p>全局变量的有效域：自定义处起以下范围；</p><p>举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>    <span class="comment">//全局变量a不被main()函数调用；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;    <span class="comment">//全局变量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span>   <span class="comment">//全局变量a可以被fun1()调用；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-同文件内扩展外部变量的作用域-—-extern"><a href="#1-同文件内扩展外部变量的作用域-—-extern" class="headerlink" title="1. 同文件内扩展外部变量的作用域 — extern"></a>1. <strong>同文件内扩展外部变量的作用域 — <code>extern</code></strong></h4><p><strong>举例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>    <span class="comment">//全局变量a不被main()函数调用；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;    <span class="comment">//全局变量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span>   <span class="comment">//全局变量a可以被fun1()调用；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在第二行语句以下的函数都可以调用变量<code>a</code>；外部变量声明也可以写成：“<code>extern a</code>”这种形式，因为<code>a</code>已经是已经定义过的变量；<br>注意：<code>extern</code>并不是定义变量，而是声明变量，这个关键字就是为了告诉编译器：本文件中已经定义这个变量；</p><h4 id="2-将外部变量的作用域扩展到其他文件–extern"><a href="#2-将外部变量的作用域扩展到其他文件–extern" class="headerlink" title="2. 将外部变量的作用域扩展到其他文件–extern"></a>2. <strong>将外部变量的作用域扩展到其他文件–extern</strong></h4><p><strong>怎样扩展</strong>：一个大的程序往往是由许多源文件和头文件组成，当不同文件要引用同一个外部变量时，方法是：在任意一个文件中定义外部变量，而在另一个文件中用<code>extern</code>对其进行“外部变量声明”；这样，在编译连接时编译器好知道这个变量来自于其他位置；如果说两个文件同时用了定义了相同名字的外部变量，那编译器连接时会报错；</p><p><strong>扩展的方式</strong>：当程序进行编译的时候，编译器遇到<code>extern</code>所声明的变量后，编译器会现在本文件中寻找此变量，如果找到了，就在此处扩展有效域，如果找不到，会进入其他文件进行寻找，找到后将有效域扩展其他文件，如果还找不到就按错误处理；</p><h4 id="3-静态外部（全局）变量–static"><a href="#3-静态外部（全局）变量–static" class="headerlink" title="3. 静态外部（全局）变量–static"></a>3. <strong>静态外部（全局）变量–static</strong></h4><p>定义：定义在函数外部的静态变量；</p><p>优点：被<code>static</code>限制的外部变量，编译时不会被其他文件发现，即使不同文件之间有同名的现象也没关系；如果确定一个外部变量不被其他文件引用，就可以直接加static，这一点很符合C语言模块化的思想，也提高了程序的可移植性；</p><p><strong>举例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">//静态全局变量，只能在本文件中被调用；如果在其他文件被调用将会报错；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以：对于<code>static</code>来说，静态<strong>局部</strong>变量说明的是此变量的<strong>生存期</strong>；静态<strong>外部</strong>变量说明的是此变量的<strong>作用域</strong>；</p><h4 id="三个概念："><a href="#三个概念：" class="headerlink" title="三个概念："></a><strong>三个概念：</strong></h4><p><strong>生存期</strong>：一个变量值在<strong>某一时刻</strong>是存在的，则这个时期就是这个变量的生存期；<br><strong>作用域</strong>：一个变量在<strong>某个文件或函数范围内</strong>是有效的，则这个范围就是这个变量的作用域；<br><strong>可见性</strong>：在一个变量的作用域可以<strong>引用</strong>该变量，则说这个变量在这个作用域是可见的，这么一个性质就是可见性；</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>存储类型（即存储类型关键字）是数据在内存中的存储方式，有四种：<code>auto</code>，<code>static</code>，<code>extern</code>，<code>register</code>。</li></ol><p><code>auto</code>和<code>register</code>用于声明内部变量，<code>auto</code>变量存储在<strong>栈</strong>中；<code>extern</code>用于声明外部变量，<code>static</code>用于声明内部和外部变量，<code>extern</code>和<code>static</code>变量存储在静态存储区中。内部变量默认是<code>auto</code>类型，外部变量默认是<code>extern</code>类型。</p><ol start="2"><li><p>C语言中，常量存储在常量区，该区数据可读不可写。<br><code>static</code>全局变量和<code>static</code>局部变量都存储在全局数据区。</p></li><li><p>C语言中，除了关键字，还有单词类型（语法符号）：标识符、运算符、分隔符、常量、注释符。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容来自谭浩强的《C语言程序设计》总结&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>二分查找算法细节详解</title>
    <link href="http://0202zc.github.io/2020/01/27/algorithm-binary-search/"/>
    <id>http://0202zc.github.io/2020/01/27/algorithm-binary-search/</id>
    <published>2020-01-27T04:37:40.000Z</published>
    <updated>2020-01-27T05:28:17.252Z</updated>
    
    <content type="html"><![CDATA[<p>From LeetCode 34. Find First and Last Position of Element in Sorted Array<br><a id="more"></a></p><blockquote><p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/</a><br>来源：力扣（LeetCode）</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我相信对很多读者朋友来说，编写二分查找的算法代码属于玄学编程，虽然看起来很简单，就是会出错，要么会漏个等号，要么少加个 1。</p><p>不要气馁，因为二分查找其实并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的：</p><blockquote><p>Although the basic idea of binary search is comparatively straightforward,<br>the details can be surprisingly tricky… </p></blockquote><p>这句话可以这样理解：<strong>思路很简单，细节是魔鬼。</strong></p><p>本文以问答的形式，探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。第一个场景是最简单的算法形式，解决 <a href="https://leetcode-cn.com/problems/binary-search/" target="_blank">这道题</a>，后两个场景就是本题。</p><p>而且，我们就是要深入细节，比如不等号是否应该带等号，<code>mid</code> 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p><h3 id="零、二分查找框架"><a href="#零、二分查找框架" class="headerlink" title="零、二分查找框架"></a>零、二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。</strong>本文都会使用 <code>else if</code>，旨在讲清楚，读者理解后可自行简化。</p><p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><p>另外声明一下，计算 mid 时需要技巧防止溢出，即 <code>mid=left+(right-left)/2</code>。本文暂时忽略这个问题。</p><h3 id="一、寻找一个数（基本的二分搜索）"><a href="#一、寻找一个数（基本的二分搜索）" class="headerlink" title="一、寻找一个数（基本的二分搜索）"></a>一、寻找一个数（基本的二分搜索）</h3><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为什么 <code>while</code> 循环的条件中是 <strong>&lt;=</strong>，而不是 <strong>&lt;</strong> ？</li></ol><p>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length-1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p><p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」</strong>。</p><p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">     <span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure></p><p>但如果没找到，就需要 <code>while</code> 循环终止，然后返回 -1。那 <code>while</code> 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 $[right + 1, right]$，或者带个具体的数字进去 $[3, 2]$，<strong>可见这时候搜索区间为空</strong>，因为没有数字既大于等于 $3$ 又小于等于 $2$ 的吧。所以这时候 <code>while</code> 循环终止是正确的，直接返回 -1 即可。</p><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 $[left, right]$，或者带个具体的数字进去 $[2, 2]$，这时候搜索区间非空，还有一个数 $2$，但此时 while 循环终止了。也就是说这区间 $[2, 2]$ 被漏掉了，索引 $2$ 没有被搜索，如果这时候直接返回 $-1$ 就是错误的。</p><p>当然，如果你非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断？</li></ol><p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 $[left, right]$。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，如何确定下一步的搜索区间呢？</p><p>当然是 $[left, mid - 1]$ 或者 $[mid + 1, right]$ 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</p><ol start="3"><li>此算法有什么缺陷？</li></ol><p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p><p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target = 2</code>，此算法返回的索引是 $2$，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 $1$，或者我想得到 <code>target</code> 的右侧边界，即索引 $3$，这样的话此算法是无法处理的。</p><p>这样的需求很常见。你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</p><p>我们后续的算法就来讨论这两种二分查找的算法。</p><h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h3><p>直接看代码，其中的标记是需要注意的细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为什么 <code>while(left &lt; right)</code> 而不是 <code>&lt;=</code> ?</li></ol><p>答：用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code> 。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。</p><p><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</p><ol start="2"><li>为什么没有返回 <code>-1</code> 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？</li></ol><p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：</p><p><img data-src="https://pic.leetcode-cn.com/0ee763a9e3b27dddf9c60ffe7e17db7160d2910d7bca591af8f3e3202d0f19ea-file_1560274288808" alt=""></p><p>对于这个数组，算法会返回 $1$。这个 $1$ 的含义可以这样解读：<code>nums</code> 中小于 $2$ 的元素有 $1$ 个。</p><p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 $0$<code>，含义是：nums</code> 中小于 $1$ 的元素有 $0$ 个。</p><p>再比如说 <code>nums</code> 不变，<code>target = 8</code>，算法会返回 $4$，含义是：<code>nums</code> 中小于 $8$ 的元素有 $4$ 个。</p><p>综上可以看出，函数的返回值（即 <code>left</code> 变量的值）取值区间是闭区间 $[0, nums.length]$，所以我们简单添加两行代码就能在正确的时候 <code>return -1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>为什么 <code>left = mid + 1</code>，<code>right = mid</code> ？和之前的算法不一样？</li></ol><p>答：这个很好解释，因为我们的「搜索区间」是 $[left, right)$ 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 $[left, mid)$ 或 $[mid + 1, right)$。</p><ol start="4"><li>为什么该算法能够搜索左侧边界？</li></ol><p>答：关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure></p><p>可见，找到 <code>target</code> 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 $[left, mid)$ 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><p>可见，找到 <code>target</code> 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 $[left, mid)$ 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><ol start="5"><li>为什么返回 <code>left</code> 而不是 <code>right？</code></li></ol><p>答：都是一样的，因为 <code>while</code> 终止的条件是 <code>left == right</code>。</p><h3 id="三、寻找右侧边界的二分查找"><a href="#三、寻找右侧边界的二分查找" class="headerlink" title="三、寻找右侧边界的二分查找"></a>三、寻找右侧边界的二分查找</h3><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>为什么这个算法能够找到右侧边界？</li></ol><p>答：类似地，关键点还是这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>left</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。</p><ol start="2"><li>为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对。</li></ol><p>答：首先，<code>while</code> 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</p><p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这样想: mid = left - 1</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic.leetcode-cn.com/dc975e6d3c8b9d0ee5453ce9253d5ee3b2b3ee6461a5183d3922d52724873709-file_1560274288798" alt=""></p><p>因为我们对 left 的更新必须是 <code>left = mid + 1</code>，就是说 <code>while</code> 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</p><p>至于为什么 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，同左侧边界搜索，就不再赘述。</p><ol start="3"><li>为什么没有返回 $-1$ 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？</li></ol><p>答：类似之前的左侧边界搜索，因为 <code>while</code> 的终止条件是 <code>left == right</code>，就是说 <code>left</code> 的取值范围是 $[0, nums.length]$，所以可以添加两行代码，正确地返回 $−1$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left-<span class="number">1</span>] == target ? (left-<span class="number">1</span>) : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h3><p>来梳理一下这些细节差异的因果逻辑：</p><p>第一个，最基本的二分查找算法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length - <span class="number">1</span></span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+<span class="number">1</span> 和 right = mid<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure></p><p>第二个，寻找左侧边界的二分查找：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure></p><p>第三个，寻找右侧边界的二分查找：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + <span class="number">1</span></span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure></p><p>如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。</p><p>通过本文，你学会了：</p><p>分析二分查找代码时，不要出现 <code>else</code>，全部展开成 <code>else if</code> 方便理解。</p><p>注意「搜索区间」和 <code>while</code> 的终止条件，如果存在漏掉的元素，记得在最后检查。</p><p>如需要搜索左右边界，只要在<code>nums[mid] == target</code> 时做修改即可。搜索右侧时需要减一。</p><p>以后就算遇到其他的二分查找变形，运用这几点技巧，也能保证你写出正确的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From LeetCode 34. Find First and Last Position of Element in Sorted Array&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>合并有序线性表</title>
    <link href="http://0202zc.github.io/2020/01/26/algorithm-merge-list/"/>
    <id>http://0202zc.github.io/2020/01/26/algorithm-merge-list/</id>
    <published>2020-01-26T03:13:54.000Z</published>
    <updated>2020-01-27T03:51:50.390Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 21. Merge Two Sorted Lists &amp; 88. Merge Sorted Array<br><a id="more"></a></p><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素<br>终止条件：两条链表分别名为<code>l1</code>和<code>l2</code>，当<code>l1</code>为空或<code>l2</code>为空时结束<br>返回值：每一层调用都返回排序好的链表头<br>本级递归内容：如果<code>l1</code>的$val$值更小，则将<code>l1-&gt;next</code>与排序好的链表头相接，<code>l2</code>同理<br>$O(m+n)$，<code>m</code>为<code>l1</code>的长度，<code>n</code>为<code>l2</code>的长度</p><h4 id="画解"><a href="#画解" class="headerlink" title="画解"></a>画解</h4><p><img data-src="https://pic.leetcode-cn.com/7ddaf1beb64fdef4393cc6ebd0dfd1723b97d2c183ab5c8414c0898027623a00-frame_00001.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/f4b7e354473d2bf28283ac3c410bc81e9f7ecb35f14189de9fadc041452c2653-frame_00002.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/001e4c2fdd8b5d725bc25df6373f7590404d9ef16efdea6e3700b68c23500a7a-frame_00003.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/5fbc72d56f32a8b1bc34db4bbd1588abebb4942348d8ea22fdb60724c8e4986c-frame_00004.png" alt=""></p><ul><li>作者：guanpengchn</li><li>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/</a></li><li>来源：力扣（LeetCode）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br><strong>说明:</strong></p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li></ul><p><strong>示例:</strong></p><blockquote><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>因为<code>nums1</code>的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去<br>设置指针<code>len1</code>和<code>len2</code>分别指向<code>nums1</code>和<code>nums2</code>的有数字尾部，从尾部值开始比较遍历，同时设置指针<code>len</code>指向<code>nums1</code>的最末尾，每次遍历比较值大小之后，则进行填充<br>当<code>len1 &lt; 0</code>时遍历结束，此时<code>nums2</code>中海油数据未拷贝完全，将其直接拷贝到<code>nums1</code>的前面，最后得到结果数组<br>时间复杂度：$O(m+n)$</p><h4 id="画解-1"><a href="#画解-1" class="headerlink" title="画解"></a>画解</h4><p><img data-src="https://pic.leetcode-cn.com/2b89af59204b9e77445e33b9613be7f61bcd2a1b0a07c0bde2e2b50603d5efff-1.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/bc8d62acb39e43526e7844b62724f43d6193570d9952a96277f55b02cbe4e525-2.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/b72c52702e7b932eefbf0459630038a0120bf51cdf0f744bed7bdd317a739677-3.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/5b0376aed4cf530afc60594379b030511adb22661b4ba7892601d194b6426200-4.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：guanpengchn</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/hua-jie-suan-fa-88-he-bing-liang-ge-you-xu-shu-zu-/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len1 &gt;= <span class="number">0</span> &amp;&amp; len2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码</span></span><br><span class="line">            nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1</span></span><br><span class="line">        System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, len2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 21. Merge Two Sorted Lists &amp;amp; 88. Merge Sorted Array&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>复试笔试C语言重要简答题</title>
    <link href="http://0202zc.github.io/2020/01/25/algorithm-short-answers-about-C/"/>
    <id>http://0202zc.github.io/2020/01/25/algorithm-short-answers-about-C/</id>
    <published>2020-01-25T08:45:37.000Z</published>
    <updated>2020-01-31T12:44:29.254Z</updated>
    
    <content type="html"><![CDATA[<p>来源：UESTC考研群<br><a id="more"></a></p><h3 id="从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。"><a href="#从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。" class="headerlink" title="从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。"></a>从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。</h3><ul><li><p><strong>使用指针</strong>：有些程序用其他语言也可以实现，但C能够更有效地实现；有些程序无法用其它语言实现，如直接访问硬件，但C却可以。正因为指针可以拥有类似于汇编的寻址方式，所以可以使程序更高效。</p></li><li><p><strong>使用宏函数</strong>：宏函数仅仅作为预先写好的代码嵌入到当前程序，不会产生函数调用，所以仅仅是占用了空间，而使程序可以高效运行。在频繁调用同⼀个宏函数的时候，该现象尤其突出。函数和宏函数的区别就在于，宏函数占用了大量的空间，而函数占用了时间。</p><ul><li>宏函数的例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxNum = MAX(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The max num is : %d\n"</span>, maxNum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用位操作</strong>：位操作可以减少除法和取模的运算。在计算机程序中数据的位是可以操作的最小数据单位，理论上可以用“位运算”来完成所有的运算和操作。灵活的位操作可以有效地提高程序运行的效率。</p></li><li><p>循环嵌套中将较<strong>长</strong>循环设为<strong>内置</strong>循环，较<strong>短</strong>循环设为<strong>外置</strong>循环，以减少cpu跨切循环层的次数，提高程序的运行效率。(操作系统页面置换相关，减少页面置换次数)</p></li><li><p>将汇编指令嵌入到C语言程序中，<strong>汇编语言是效率最高的计算机语言</strong>，因此为了获得程序的高效率，可以在C语言程序中嵌入汇编，从而充分利用高级语言和汇编语言各⾃的特点。</p></li><li><p>在C语言程序中可以<strong>调用系统API</strong>，接近底层，从而提高程序的运行效率。</p></li><li><p>⼀般情况下，C语言源程序中的每⼀行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中⼀部分内容进行编译，此时就需要在程序中加上条件，让编译器<strong>只对满足条件的代码进行编译</strong>，将不满足条件的代码舍弃，这就是<em>条件编译</em>。</p></li></ul><h3 id="请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int）"><a href="#请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int）" class="headerlink" title="请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int）"></a>请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int）</h3><ul><li>算术运算式中，低类型能够转换为高类型（自动类型转换）。</li><li>赋值表达式中，右边表达式的值<u>⾃动隐式转换</u>为左边变量的类型，并赋值给它。</li><li>函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。</li><li>函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋给调用函数。</li></ul><h4 id="小题：float如何四舍五入转化成int"><a href="#小题：float如何四舍五入转化成int" class="headerlink" title="小题：float如何四舍五入转化成int"></a>小题：float如何四舍五入转化成int</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)(f + <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组越界会产生什么后果？"><a href="#数组越界会产生什么后果？" class="headerlink" title="数组越界会产生什么后果？"></a>数组越界会产生什么后果？</h3><p>越界访问有可能把数据放到已经存储了重要数据的内存单元，也就是<strong>改写了本来不许改写的数据</strong>，如果这个数据是系统的重要数据，有可能<strong>导致系统运行紊乱甚至是崩溃</strong>。当然如果这个数据并不重要，那么越界访问的后果就不明显或者是没有影响。避免的方法是对数组的下标严格检测，判断组数下标是否越界，用指针访问数组时要注意判断<strong>指针的指向是否已超过数组下标的最大值</strong>。</p><h3 id="值传递和地址传递"><a href="#值传递和地址传递" class="headerlink" title="值传递和地址传递"></a>值传递和地址传递</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>被调函数的形参作为被调函数的<strong>局部变量</strong>处理，即在内存的堆栈中开辟空间以存放由主调函数放进来的实参的值，从而成为了实参的一个<strong>拷贝</strong>。<br>其特点是被调函数对形参的任何操作都是作为<strong>局部变量</strong>进行，<u>不会影响</u>主调函数的实参变量的值。</p><h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><p>被调函数的形参虽然也作为局部变量在堆栈中开辟了内存空间，但是这是存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成<strong>间接寻址</strong>，即通过<strong>堆栈中存放的地址</strong>访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><h3 id="C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？"><a href="#C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？" class="headerlink" title="C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？"></a>C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储位置</th></tr></thead><tbody><tr><td style="text-align:center">常量</td><td style="text-align:center">常量区</td></tr><tr><td style="text-align:center">静态局部变量</td><td style="text-align:center">全局数据区</td></tr><tr><td style="text-align:center">静态局部变量</td><td style="text-align:center">全局数据区</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：UESTC考研群&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>删除排序数组中的重复项与移除元素</title>
    <link href="http://0202zc.github.io/2020/01/24/algorithm-remove-elements/"/>
    <id>http://0202zc.github.io/2020/01/24/algorithm-remove-elements/</id>
    <published>2020-01-24T06:54:54.000Z</published>
    <updated>2020-01-24T09:52:48.401Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 26. Remove Duplicates from Sorted Array &amp; 27. remove elements<br><a id="more"></a></p><h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用$O(1)$额外空间的条件下完成。</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5><blockquote><p>给定数组 <code>nums = [1,1,2]</code>,<br>函数应该返回新的长度<code>2</code>, 并且原数组<code>nums</code>的前两个元素被修改为<code>1, 2</code>。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5><p>给定<code>nums = [0,0,1,1,1,2,2,3,3,4]</code>,</p><p>函数应该返回新的长度<code>5</code>, 并且原数组<code>nums</code>的前五个元素被修改为<code>0, 1, 2, 3, 4</code>。</p><p>你不需要考虑数组中超出新长度后面的元素。</p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p><strong>“拷贝覆盖”</strong><br><img data-src="/images/algorithm/Remove-Elements-1.jpg" alt=""><br>如上图所示，用count来记录元素应该覆盖的步长：<br>在i位置时，</p><ul><li>若<code>nums[i] == nums[i + 1]</code>，则<code>count++</code></li><li>否则，<code>countinue</code><br><em>此处用了arr[]来记录每个元素应该移动的步长</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)&#123;  <span class="comment">//空数组直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> arr[numsSize];</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">             count++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i]=count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">         nums[i - arr[i]] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组<code>nums</code>和一个值<code>val</code>，你需要<strong>原地</strong>移除所有数值等于<code>val</code>的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用$O(1)$额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h4 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h4><p>同样是“拷贝覆盖”<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//空数组直接返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i - count] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 26. Remove Duplicates from Sorted Array &amp;amp; 27. remove elements&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C语言一些要点总结</title>
    <link href="http://0202zc.github.io/2020/01/23/algorithm-something-about-C/"/>
    <id>http://0202zc.github.io/2020/01/23/algorithm-something-about-C/</id>
    <published>2020-01-23T02:39:09.000Z</published>
    <updated>2020-01-30T05:07:19.590Z</updated>
    
    <content type="html"><![CDATA[<p>复试笔试C语言一些要点<br><a id="more"></a></p><h3 id="C语言短路求值（逻辑与、逻辑或）"><a href="#C语言短路求值（逻辑与、逻辑或）" class="headerlink" title="C语言短路求值（逻辑与、逻辑或）"></a>C语言短路求值（逻辑与、逻辑或）</h3><h4 id="逻辑或的短路"><a href="#逻辑或的短路" class="headerlink" title="逻辑或的短路"></a>逻辑或的短路</h4><p>首先上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="number">1</span> || (a = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：</p><blockquote><p>a = 1<br>a = 1</p></blockquote><p>逻辑或的表现形式如下：<br><code>expression1 || exexpression2</code></p><p>这⾥用到了逻辑或，由于逻辑或的短路，expression1为true，则后⾯的expression2（即：(a=0) ）不再求值，整个表达式的结果为true，所以a的值仍为1，没有改变。【即：一真为真】</p><h4 id="逻辑与的短路"><a href="#逻辑与的短路" class="headerlink" title="逻辑与的短路"></a>逻辑与的短路</h4><p>⾸先看如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="number">0</span> &amp;&amp; (a = <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：</p><blockquote><p>a = 1<br>a = 1</p></blockquote><p>逻辑与的表现形式如下：<br><code>expression1 &amp;&amp; expression2</code></p><p>上述代码中用到了逻辑与，由于逻辑与的短路，<code>expression1</code>为<code>false</code>，则后面的<code>expression2</code>不再求值，整个的结果为<code>false</code>，所以a的值没有改变。【即：一假则假】</p><h3 id="Eratosthenes筛选法"><a href="#Eratosthenes筛选法" class="headerlink" title="Eratosthenes筛选法"></a>Eratosthenes筛选法</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>解释一：<br>给出要筛选数值的范围$n$，找出<code>sqrt(n)</code>以内的素数$p_1, p_2, … , p_k$。</p><ul><li>先把1删除（现今数学界1既不是质数也不是合数）</li><li>读取队列中当前最小的数2，然后把2的倍数删去</li><li>读取队列中当前最小的数3，然后把3的倍数删去</li><li>读取队列中当前最小的数5，然后把5的倍数删去</li><li>读取队列中当前最小的数7，然后把7的倍数删去</li><li>不断重复下去…直到需求的范围内所有的数均删除或读取<br>注：此处的队列并非数据结构队列，如需保留运算结果，处于存储空间的充分利用以及大量删除操作的实施，建议采用链表的数据结构。<br>【来源：百度百科】</li></ul><p>解释二：</p><ol><li>取最小的数$2$，并声明它是素数，同时筛去它及它的所有倍数；</li><li>取未筛去的数中的最小者，声明它是素数，同时筛去它及它的所有倍数；</li><li>重复步骤2，至筛中无数为止，得到所有素数。</li></ol><p>筛法实际上是筛去合数，留下素数。</p><h5 id="一位数组举例"><a href="#一位数组举例" class="headerlink" title="一位数组举例"></a>一位数组举例</h5><p><img data-src="/images/algorithm/something-about-C-1.jfif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C Language</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">/*i表示整数和对应的下标*/</span></span><br><span class="line"><span class="keyword">int</span> j; <span class="comment">/*j表示正要处理的质数，j之前的已处理，j之后的未处理*/</span></span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">/*k表示正在处理的j的倍数从2开始到j*k&lt;SIZE*/</span></span><br><span class="line"><span class="keyword">int</span> a[SIZE]; <span class="comment">/*下标表示整数内容判断是否为质数*/</span></span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">/*控制循环*/</span></span><br><span class="line"><span class="keyword">for</span>(p = a; p &lt; a+SIZE; ++p) &#123; <span class="comment">/*初始化数组全是TRUE*/</span></span><br><span class="line">*p = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>] = a[<span class="number">1</span>] = FALSE; <span class="comment">/*设置前面两个是不是质数的数的状态为FALSE，即0和1不是质数*/</span></span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; SIZE) &#123; <span class="comment">/*找到下一个质数*/</span></span><br><span class="line"><span class="keyword">while</span>(a[i++] == TRUE) &#123;</span><br><span class="line">j = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">2</span>; j*k &lt; SIZE &amp;&amp; i &lt; SIZE; ++k) &#123; <span class="comment">/*处理质数的倍数*/</span></span><br><span class="line">a[j*k] = FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(p = a; p &lt; a+SIZE; ++p) &#123; <span class="comment">/*打印出质数*/</span></span><br><span class="line"><span class="keyword">if</span>(*p == TRUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%8d"</span>, p-a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vec_flag(n, <span class="literal">true</span>);</span><br><span class="line">    vec_flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    vec_flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec_flag[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                vec_flag[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(vec_flag.begin(), vec_flag.end(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_int_iter</span><span class="params">()</span>:</span><span class="comment">#生成器生成从3开始的无限奇数序列</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">_not_divisible</span><span class="params">(n)</span>:</span><span class="comment">#定义筛选函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x % n &gt; <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>          <span class="comment">#先返回一个2</span></span><br><span class="line">    it = _int_iter() <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():<span class="comment">#构造循环条件，使之可以输出任何范围的素数序列</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="关于void"><a href="#关于void" class="headerlink" title="关于void *"></a>关于void *</h3><h4 id="void的含义"><a href="#void的含义" class="headerlink" title="void的含义"></a>void的含义</h4><p><code>void</code>即“无类型”，<code>void *</code>则为“无类型指针”，可以指向任何数据类型</p><h4 id="void指针的使用规范"><a href="#void指针的使用规范" class="headerlink" title="void指针的使用规范"></a>void指针的使用规范</h4><ul><li><code>void</code>指针可以指向任意类型的数据，亦即可用任意数据类型的指针对<code>void</code>指针赋值。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_int;</span><br><span class="line"><span class="keyword">void</span> *p_void;</span><br><span class="line">p_void = p_int; <span class="comment">/*但是不能 p_int = p_void*/</span></span><br></pre></td></tr></table></figure></li></ul><p>如果要将<code>p_void</code>赋给其他类型指针，则需要强制类型转换如：<code>p_int = (int *)p_void;</code></p><ul><li>在ANSIC标准中，不允许对<code>void</code>指针进行算术运算如<code>p_void++</code>或<code>p_void += 1</code>等，而在GNU中则允许。因为在缺省情况下，GNU认为<code>void *</code>与<code>char *</code>⼀样。<code>sizeof(*pvoid ) == sizeof(char)</code>.</li><li>由于<code>void</code>指针可以指向任意类型的数据，亦即可用任意数据类型的指针对<code>void</code>指针赋值，因此还可以用<code>void</code>指针来作为函数形参，这样函数就可以接受任意数据类型的指针作为参数。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">int</span> c, <span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复试笔试C语言一些要点&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转排序数组中的最小值</title>
    <link href="http://0202zc.github.io/2020/01/22/algorithm-Find-Minimum-in-Rotated-Sorted-Array/"/>
    <id>http://0202zc.github.io/2020/01/22/algorithm-Find-Minimum-in-Rotated-Sorted-Array/</id>
    <published>2020-01-22T03:21:36.000Z</published>
    <updated>2020-01-24T09:52:51.953Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode上的一道题目：153. 寻找旋转排序数组中的最小值<br><a id="more"></a><br>来源：<br><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xi/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。</p></blockquote><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><blockquote><p>输入: [3,4,5,1,2]<br>输出: 1</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><blockquote><p>输入: [4,5,6,7,0,1,2]<br>输出: 0</p></blockquote><h3 id="方法：二分查找"><a href="#方法：二分查找" class="headerlink" title="方法：二分查找"></a>方法：二分查找</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一种暴力的解法是搜索整个数组，找到其中的最小元素，这样的时间复杂度是 $O(N)$ 其中 $N$ 是给定数组的大小。</p><p>一个非常棒的解决该问题的办法是使用<code>二分搜索</code>。在二分搜索中，我们找到区间的中间点并根据某些条件决定去区间左半部分还是右半部分搜索。</p><p>由于给定的数组是有序的，我们就可以使用二分搜索。然而，数组被旋转了，所以简单的使用二分搜索并不可行。</p><p>我们希望找到旋转排序数组的最小值，如果数组没有被旋转呢？如何检验这一点呢？</p><p>如果数组没有被旋转，是升序排列，就满足 <code>last element &gt; first element</code>。</p><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-1.png" alt=""></p><p>上图例子中 <code>7&gt;2</code> 。说明数组仍然是有序的，没有被旋转。</p><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-2.png" alt=""></p><p>上面的例子中 <code>3 &lt; 4</code>，因此数组旋转过了。这是因为原先的数组为 <code>[2, 3, 4, 5, 6, 7]</code>，通过旋转较小的元素 <code>[2, 3]</code> 移到了后面，也就是 [4, 5, 6, 7, <code>2, 3</code>]。因此旋转数组中第一个元素 <code>[4]</code> 变得比最后一个元素大。</p><p>这意味着在数组中你会发现一个变化的点，这个点会帮助我们解决这个问题，我们称其为<code>变化点</code>。</p><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-3.png" alt=""></p><p>在这个改进版本的二分搜索算法中，我们需要找到这个点。下面是关于<code>变化点</code>的特点：</p><blockquote><p>所有变化点左侧元素 &gt; 数组第一个元素<br>所有变化点右侧元素 &lt; 数组第一个元素</p></blockquote><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol><li><p>找到数组的中间元素<code>mid</code>。</p></li><li><p>如果<code>中间元素 &gt; 数组第一个元素</code>，我们需要在<code>mid</code>右边搜索变化点。</p></li><li><p>如果<code>中间元素 &lt; 数组第一个元素</code>，我们需要在<code>mid</code>做边搜索变化点。</p></li></ol><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-4.png" alt=""></p><p>上面的例子中，中间元素<code>6</code>比第一个元素<code>4</code>大，因此在中间点右侧继续搜索。</p><ol start="4"><li><p>当我们找到变化点时停止搜索，当以下条件满足任意一个即可：<br><code>nums[mid] &gt; nums[mid + 1]</code>，因此<strong>mid+1</strong>是最小值。</p><p><code>nums[mid - 1] &gt; nums[mid]</code>，因此<strong>mid</strong>是最小值。</p></li></ol><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-5.png" alt=""></p><p>在上面的例子中，标记左右区间端点。中间元素为<code>2</code>，之后的元素是<code>7</code>满足<code>7 &gt; 2</code>也就是<code>nums[mid - 1] &gt; nums[mid]</code>。因此找到变化点也就是最小元素为<code>2</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the list has just one element then return that element.</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initializing left and right pointers.</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the last element is greater than the first element then there is no rotation.</span></span><br><span class="line">    <span class="comment">// e.g. 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 7. Already sorted array.</span></span><br><span class="line">    <span class="comment">// Hence the smallest element is first element. A[0]</span></span><br><span class="line">    <span class="keyword">if</span> (nums[right] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Binary search way</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">      <span class="comment">// Find the mid element</span></span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the mid element is greater than its next element then mid+1 element is the smallest</span></span><br><span class="line">      <span class="comment">// This point would be the point of change. From higher to lower value.</span></span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the mid element is lesser than its previous element then mid element is the smallest</span></span><br><span class="line">      <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[mid];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the mid elements value is greater than the 0th element this means</span></span><br><span class="line">      <span class="comment">// the least value is still somewhere to the right as we are still dealing with elements</span></span><br><span class="line">      <span class="comment">// greater than nums[0]</span></span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if nums[0] is greater than the mid value then this means the smallest value is somewhere to</span></span><br><span class="line">        <span class="comment">// the left</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><ul><li>时间复杂度：和二分搜索一样$O(logN)$</li><li>空间复杂度：$O(1)$</li></ul><h5 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h5><ol><li><p>判断最小的数是否在第一个位置，若是则返回<code>nums[0]</code>；</p></li><li><p>否则，选取中间位置mid的数和right位置的数进行比较，若<code>nums[mid] &lt; nums[r]</code>，说明最小的数在mid之前，<code>right = mid</code>；反之，令<code>left = mid + 1</code>；</p></li><li><p>重复进行，直到<code>left &gt;= right</code>。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span> *nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">if</span>(nums[left] &lt; nums[right])</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[right])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode上的一道题目：153. 寻找旋转排序数组中的最小值&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>最小公倍数&amp;最大公因数</title>
    <link href="http://0202zc.github.io/2020/01/21/algorithm-LCM&amp;GCD/"/>
    <id>http://0202zc.github.io/2020/01/21/algorithm-LCM&amp;GCD/</id>
    <published>2020-01-21T03:08:28.000Z</published>
    <updated>2020-01-24T09:52:50.425Z</updated>
    
    <content type="html"><![CDATA[<p>几个数共有的倍数叫做这几个数的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。约数和倍数都表示一个整数与另一个整数的关系，不能单独存在。<br><a id="more"></a></p><h3 id="求最大公因数算法"><a href="#求最大公因数算法" class="headerlink" title="求最大公因数算法"></a>求最大公因数算法</h3><p>求最大公约数有多种方法，常见的有<strong>质因数分解法</strong>、<strong>短除法</strong>、<strong>辗转相除法</strong>、<strong>更相减损法</strong>。<br>下面介绍辗转相除法（欧几里德算法）</p><blockquote><p>有两整数a和b：<br>① a%b得余数temp<br>② 若temp=0，则b即为两数的最大公因数<br>③ 若temp≠0，则令a=b，b=temp，再回去执行①</p></blockquote><p>例如，求27和15的最大公因数过程为：</p><blockquote><p>27÷15=1 余12<br>15÷12=1 余3<br>12÷3=4 余0<br>因此，3即为最大公因数</p></blockquote><h4 id="代码实现如下："><a href="#代码实现如下：" class="headerlink" title="代码实现如下："></a>代码实现如下：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求a，b的最大公因数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        temp = a % b;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(temp != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求最小公倍数算法"><a href="#求最小公倍数算法" class="headerlink" title="求最小公倍数算法"></a>求最小公倍数算法</h3><blockquote><p><strong>最小公倍数 = 两整数的乘积 ÷ 最大公约数</strong></p></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求m和n的最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, c;</span><br><span class="line">    x = m; y = n;</span><br><span class="line">    <span class="keyword">while</span>(m != <span class="number">0</span>) &#123;</span><br><span class="line">        c = n % m;</span><br><span class="line">        n = m;</span><br><span class="line">        m = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x * y / n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个数共有的倍数叫做这几个数的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。约数和倍数都表示一个整数与另一个整数的关系，不能单独存在。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>文件分配方式之索引分配</title>
    <link href="http://0202zc.github.io/2020/01/20/os-index-assignment/"/>
    <id>http://0202zc.github.io/2020/01/20/os-index-assignment/</id>
    <published>2020-01-20T03:14:05.000Z</published>
    <updated>2020-01-21T04:46:50.010Z</updated>
    
    <content type="html"><![CDATA[<p>磁盘空间分配的主要常用方法有三个：<strong>连续分配</strong>、<strong>链接分配</strong>和<strong>索引分配</strong>。本文主要讨论<strong>索引分配中处理索引块大小</strong>的问题。<br><a id="more"></a><br>文件实际上是一种抽象数据类型，文件的实现就是研究文件的物理结构，即文件数据在物理存储设备上是如何分布和组织的。同一个问题有两个方面的回答：一是文件的<strong>分配方式</strong>，讲的是对磁盘<u>非空闲块</u>的管理；二是文件<strong>存储空间管理</strong>，将的是对磁盘<u>空闲块</u>的管理。<br><br><br>索引分配解决了连续分配和链式分配中的许多问题。对于索引分配，每个文件在文件分配表中有一个一级索引，索引包含分配给文件的每个分区入口。典型地，文件索引在物理上并不是作为文件分配表的一部分存储的，相反，<u>文件索引保存在一个单独的块中，文件分配表中改文件的入口指向这一块。</u>分配可以基于大小固定的块，也可以基于大小可变的块。索引分配支持顺序访问和直接访问文件，因而是最普遍的一种文件分配方式。</p><p>索引分配解决了连接分配不能有效支持直接访问（FAT除外）的问题，它把每个文件的所有的盘块号都集中放在一起构成索引块（表），如下图所示。</p><p><img data-src="http://c.biancheng.net/uploads/allimg/181112/2-1Q112104520B6.gif" alt="" title="磁盘空间的索引分配【来源：C语言中文网 http://c.biancheng.net/view/1302.html】"></p><p>每个文件都有其索引块，这是一个磁盘块地址的数组。索引表记录了文件的<strong>各个逻辑块对应的物理块</strong>。索引块的第i个条目指向文件的第i个块。目录条目包括索引块的地址。要读第i块，通过索引块的第i个条目的指针来查找和读入所需的块。<br>创建文件时，索引块的所有项目都设为空。首次写入第i块时，先从空闲空间中取得一个块，再将其地址写到索引块的第i个条目。<strong>索引分配支持直接访问（随机访问），且没有外部碎片的问题，易于文件拓展</strong>。其缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此需要索引块尽可能小，但索引块太小就无法支持大文件。可采用以下机制来处理这个问题。</p><ol><li>链接方案</li></ol><ul><li><strong>一个块通常为一个磁盘块</strong>，因此它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。</li></ul><ol start="2"><li>多层索引：使第一层索引块指向第二层索引块，第二层文件块指向文件块。根据实际要求可以继续到第三层或第四层。</li></ol><ul><li>最大文件长度 = 每层索引项个数之积 × 单个文件大小；</li><li>每层索引表最大不能超过一个磁盘块大小；</li><li>K层索引，顶级索引表<strong>未调入内存</strong>，则访问K级索引需要<u>K+1</u>次读磁盘。<br>【注：文件分配方式之链接分配的隐式分配，读入i号逻辑块，总共需要i+1次读磁盘I/O操作】</li></ul><ol start="3"><li>混合索引：多重索引分配方式相结合。<ul><li>UNIX的文件系统采用三级索引机制。在文件控制块（FCB）中，设置了一个索引表，共有13个索引地址。其中，前10个为直接索引地址，后3个为间接索引地址，包括1个一级索引地址、1个二级索引地址和1个三级索引地址。</li><li>每一块中能记录的数据块数=512/4≈128<br>一级索引时文件最大长度的字节数 = 128 × 512<br>二级索引时文件最大长度的字节数 = 128×128 × 512<br>三级索引时文件最大长度的字节数 = 128×128×128 × 512<br>最大搜索文件的长度 = (10 + 128 + 128×128 + 128×128×128) × 512<br><img data-src="/images/mixed_index_allocation.jpg" alt="" title="混合索引分配方式"><br>与多层索引方式不同，混合索引有个<strong>主索引表</strong>（13个地址项）【主索引表是索引节点的一部分】，若题目告知主索引表<strong>在内存中【主索引表在FCB中，FCB在内存中】</strong>，访问k级间址需要读磁盘k+1次（读取数据块1次）；若主索引表不在内存中，访问k级间址需要读磁盘k+2次。<br>而多层索引没有主索引表，因此相当于直接从混合索引的一级间址开始读磁盘，故k层索引读磁盘k+1次。<br>【以上是使用索引结点的次数】<br>注：<ul><li>与单个文件长度无关的因素：索引结点的总数【索引结点个数仅与文件个数有关，一个索引结点对应一个文件】</li><li>一个盘块号就有一个索引项</li><li>将文件描述信息从目录项中分离出来，有利于减少查找文件时的I/O信息量</li><li>各级索引表最大不能超过一个块</li><li>判断读磁盘次数时，注意顶级索引块是否已调入磁盘<br><i>文件物理地址指的就是主索引表的始址</i><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><img data-src="/images/mixed_index_allocation_1.png" alt=""><br><br><br>如有错误，欢迎指正！</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;磁盘空间分配的主要常用方法有三个：&lt;strong&gt;连续分配&lt;/strong&gt;、&lt;strong&gt;链接分配&lt;/strong&gt;和&lt;strong&gt;索引分配&lt;/strong&gt;。本文主要讨论&lt;strong&gt;索引分配中处理索引块大小&lt;/strong&gt;的问题。&lt;br&gt;
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://0202zc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OS" scheme="http://0202zc.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的应用</title>
    <link href="http://0202zc.github.io/2020/01/19/algorithm-btree/"/>
    <id>http://0202zc.github.io/2020/01/19/algorithm-btree/</id>
    <published>2020-01-19T13:09:15.000Z</published>
    <updated>2020-01-24T09:52:53.699Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的系列应用<br><a id="more"></a></p><ol><li><p>层次遍历求二叉树宽度、高度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计一个非递归算法求以二叉链表存储的二叉树的高度、最大宽度</span></span><br><span class="line"><span class="comment">//非递归：层次遍历，设置level记录当前结点所在层数，last指向下一层第一个结点的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Btdepth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> front=<span class="number">-1</span>, rear=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>, level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth=<span class="number">0</span>;<span class="comment">//记录最大宽度</span></span><br><span class="line">    BiTree Q[MaxSize];</span><br><span class="line">    Q[++rear]=T;<span class="comment">//将根结点入队</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="keyword">while</span>(front&lt;rear)&#123;<span class="comment">//队不空，则循环</span></span><br><span class="line">        p=Q[++rear];<span class="comment">//队列元素出队，即正在访问的结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild)</span><br><span class="line">            Q[++rear]=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild)</span><br><span class="line">            Q[++rear]=p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span>(front == last)处理该层的最右结点，此时last指向该层最右结点</span><br><span class="line">            level++;层数加<span class="number">1</span></span><br><span class="line">        last = rear;last指向下一层</span><br><span class="line">        maxWidth=maxWidth&gt;(last-front) ? maxWidth : (last-front);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根结点左右子树叶子结点最远距离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归：</span></span><br><span class="line"><span class="keyword">int</span> ldep=<span class="number">0</span>, rdep=<span class="number">0</span>;<span class="comment">//左右子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Btdepth2</span><span class="params">(BiTree *T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ldep=Btdepth2(T-&gt;lchild);</span><br><span class="line">    rdep=Btdepth2(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(ldep&gt;rdep)</span><br><span class="line">        <span class="keyword">return</span> ldep+<span class="number">1</span>;<span class="comment">//树的高度为子树最大高度加根结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> rdep+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的系列应用&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>就地逆置线性表元素</title>
    <link href="http://0202zc.github.io/2020/01/18/algorithm-reverse-linerlist/"/>
    <id>http://0202zc.github.io/2020/01/18/algorithm-reverse-linerlist/</id>
    <published>2020-01-18T08:56:00.000Z</published>
    <updated>2020-01-19T02:57:55.500Z</updated>
    
    <content type="html"><![CDATA[<p>本文分为线性表逆置操作的基本操作和扩展操作<br><a id="more"></a></p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><blockquote><p>设计一个高效算法，将顺序表L的所有元素逆置，要求空间复杂度为O(1)</p></blockquote><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>扫描前半部分元素，对于L.data[i]（0&lt;i&lt;L.length/2），与后半部分对应元素L.data[L.length-i-1].data交换<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">ElemType temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++) &#123;</span><br><span class="line">temp = L.data[i];</span><br><span class="line">L.data[i] = L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">L.data[L.length-i<span class="number">-1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>用两个指针i、j分别指向数组的前后<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> *a[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>, j=n<span class="number">-1</span>, temp;</span><br><span class="line">While(i&lt;j)&#123;</span><br><span class="line">temp=a[i];</span><br><span class="line">a[i]=a[j];</span><br><span class="line">a[j]=temp;</span><br><span class="line">i++; j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>逆置链表（带头结点L）用“头插法”。尾插时，最后一个结点的指针要置空。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">LinkNode *p=L-&gt;next, *q;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p>逆置双链表除了上述的步骤外，还多了两个指针，p的后继的前驱和p的前驱的后继<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(DLinkList L)</span> </span>&#123;</span><br><span class="line">DLinkNode *p=L-&gt;next, *q;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=L-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)  <span class="comment">//第一个用“头插法”插入L的结点没有后继</span></span><br><span class="line">P-&gt;next-&gt;prior=p;</span><br><span class="line">L-&gt;next=p;</span><br><span class="line">p-&gt;prior=L;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h1><h2 id="两个顺序表位置互换"><a href="#两个顺序表位置互换" class="headerlink" title="两个顺序表位置互换"></a>两个顺序表位置互换</h2><blockquote><pre><code>一维数组A[m+n]中一次存放两个线性表(a1, a2, …, am)和(b1, b2 , …, bn)。编写一个算法，将数组中两个线性表的位置互换—&gt;(b1,b2,…,bn, a1,a2,…,am)</code></pre></blockquote><p>算法思想：将A[m+n]中全部元素逆置为(bn, bn-1, …, b2, b1, am, am-1, …, a2, a1)，再对前n个元素和后m个元素分别逆置<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> arraySize)</span></span>&#123;</span><br><span class="line"><span class="comment">//逆置(aleft, aleft+1, …, aright)</span></span><br><span class="line"><span class="keyword">if</span>(left&gt;=right||right&gt;=arraySize)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i&lt;= mid - left; i++)&#123;</span><br><span class="line"><span class="comment">//这里i作为下标的增量</span></span><br><span class="line"><span class="keyword">int</span> temp=A[left+i];</span><br><span class="line">A[left+i]=a[right-i];</span><br><span class="line">A[right-i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> arraySize)</span></span>&#123;</span><br><span class="line"><span class="comment">//数组A[m+n]中，从0到m-1存放顺序表(a1,a2,…,am)，从m到n-1存放(b1,b2,…,bn)</span></span><br><span class="line">Reverse(A, <span class="number">0</span>, m+n<span class="number">-1</span>, arraySize);</span><br><span class="line">Reverse(A, <span class="number">0</span>, n<span class="number">-1</span>, arraySize);</span><br><span class="line">Reverse(A, n, m+n<span class="number">-1</span>, arraySize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三个顺序表位置互换"><a href="#三个顺序表位置互换" class="headerlink" title="三个顺序表位置互换"></a>三个顺序表位置互换</h2><blockquote><p>设规模n=3m, m≥1的顺序表存储在一维数组int array[n]中，它含有的元素为(a1,a2,…,am, b1, b2 , …, bm,c1,c2,…,cm)。请编写算法将上述顺序表改造成为(c1,c2,…,cm, bm, …, b2, b1, a1,a2,…,am)，要求时间复杂度和空间复杂度尽可能低。</p></blockquote><p><img data-src="/images/screenshot20200118171403.jpg" alt="" title="下标图示"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reverse</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp, mid, i;  <span class="comment">//i作为下标增量</span></span><br><span class="line">mid = (left+right)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= mid - left; i++)&#123;</span><br><span class="line">temp=a[left+i];</span><br><span class="line">a[left+i]=a[right-i];</span><br><span class="line">a[right-i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">Reverse(<span class="built_in">array</span>, <span class="number">0</span>, <span class="number">3</span>m<span class="number">-1</span>);</span><br><span class="line">Reverse(<span class="built_in">array</span>, <span class="number">0</span>, m<span class="number">-1</span>);</span><br><span class="line">Reverse(<span class="built_in">array</span>, <span class="number">2</span>m, <span class="number">3</span>m<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就地逆置线性表元素基本操作总结为“二分交换”，基本思想是从头开始将前半部分与后半部分以中心元素对称的元素进行交换，直到走到了中心元素位置</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文分为线性表逆置操作的基本操作和扩展操作&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>文件控制块与索引节点的总结</title>
    <link href="http://0202zc.github.io/2019/11/24/os-FCB-and-inode/"/>
    <id>http://0202zc.github.io/2019/11/24/os-FCB-and-inode/</id>
    <published>2019-11-24T14:37:17.000Z</published>
    <updated>2020-01-19T12:46:12.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>文件控制块（FCB）与索引结点（inode）都是操作系统文件管理中逻辑结构的重要部分。在今日考研复习过程中，基本解决了以前遇到的“FCB与inode”的问题，现以此博文记录该知识点。<br><a id="more"></a></p><h1 id="文件控制块与索引结点"><a href="#文件控制块与索引结点" class="headerlink" title="文件控制块与索引结点"></a>文件控制块与索引结点</h1><p>这需要从目录结构说起。</p><ul><li>文件目录：包含有关文件的信息，信息主要有：属性，位置，所有权。这些信息主要是由OS进行管理。把所有的FCB组织在一起，就构成了文件目录，即文件控制块的有序集合，其包含许多目录项（即FCB）。<br><br>目录管理的基本要求：从用户角度看待，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射。目录管理提供的是：按名存取。</li></ul><ul><li>共享系统中目录还需要提供控制访问文件的信息。重名问题主要通过树形结构来解决。</li></ul><!-- ![](/images/catalogue_FCB.jpg "目录实现对比") --><table><thead><tr><th>普通文件目录</th><th>以索引结点实现的目录</th></tr></thead><tbody><tr><td>由FCB构成的一个一个目录项组成；<br>FCB中存放了和文件相关的所有控制信息</td><td>a. 文件名<br> b. 指向索引结点的指针</td></tr></tbody></table><p>采用索引结点的方式来实现目录，好处是文件目录的目录项长度会缩短很多。因为通过文件目录实现对文件的按名存取时，在寻找文件的过程中只需要用到文件名这个信息，而其他信息在寻找文件的时候没有必要。<br>如果一个目录中存放了很多个文件，采用传统的以FCB构成目录项的方式，那么这个文件目录会非常大，因为每个目录项就特别大。<br>而采用索引结点的方式实现目录，每个目录项就会很小，只包含文件名和指向索引结点的指针。可以提高文件检索速度。</p><ul><li>FCB：文件控制块。用于存放控制文件的各种信息的数据结构，实现了按名存取。</li></ul><p><br><br>总结如下表：<br><img data-src="/images/FCB&amp;inode_1.jpg" alt="" title="FCB与inode"></p><p>此处有个小问题：</p><ul><li>某科技大学的OS考研试卷填空题答案中索引节点分为文件描述信息和i结点，而资料书上说的是索引节点即为i结点</li></ul><p>检索目录文件（FCB的集合）时只用到了文件名。仅当找到一个目录项时才需要从该目录项（FCB）中读出该文件的物理地址。即：检索目录时文件的其他描述信息用不到，也因此不必调入内存。那么我们是否可以考虑，把<strong>文件名</strong>和<strong>文件的描述信息(FCB-文件名)</strong>分开，文件的描述信息单独形成一个数据结构，这个被称作索引结点。简称为i结点。<br>这样就可以简化目录结构为：<strong>文件名</strong>对应<strong>i结点指针</strong>。<br>比如在UNIX系统中，文件目录项（FCB）占16B，其中14B是文件名，2B是i结点指针。<br>注意到设计i结点的设计思路是怎么得到的，就很容易理解FCB和i结点包含的信息大部分是相同的，i结点只是抽出了文件名。每个文件对应一个文件名，则一个文件也只要一个i结点。</p><ul><li>存放在磁盘上的索引结点称为磁盘索引结点。</li></ul><h2 id="文件控制块与索引节点的区别"><a href="#文件控制块与索引节点的区别" class="headerlink" title="文件控制块与索引节点的区别"></a>文件控制块与索引节点的区别</h2><p>个人总结：<br>从文件目录结构来看，UNIX中，</p><ul><li>文件目录由FCB（目录项）组成</li><li>FCB = 文件名 + inode</li><li>inode包含了文件物理地址信息</li><li>物理地址信息的组成主要是主索引表<br><br><br>如图所示:<br><img data-src="/images/FCB&amp;inode.jpg" alt="" title="逻辑结构图"></li></ul><p><strong>个人能力有限，总结有问题请指出。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h1&gt;&lt;p&gt;文件控制块（FCB）与索引结点（inode）都是操作系统文件管理中逻辑结构的重要部分。在今日考研复习过程中，基本解决了以前遇到的“FCB与inode”的问题，现以此博文记录该知识点。&lt;br&gt;
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://0202zc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OS" scheme="http://0202zc.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.6 监控爬取成绩并推送到邮箱(基于百度云接口的验证码识别)</title>
    <link href="http://0202zc.github.io/2018/12/28/Python-3-6-%E7%9B%91%E6%8E%A7%E7%88%AC%E5%8F%96%E6%88%90%E7%BB%A9%E5%B9%B6%E6%8E%A8%E9%80%81%E5%88%B0%E9%82%AE%E7%AE%B1(%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E4%BA%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB)/"/>
    <id>http://0202zc.github.io/2018/12/28/Python-3-6-监控爬取成绩并推送到邮箱(基于百度云接口的验证码识别)/</id>
    <published>2018-12-28T15:53:25.000Z</published>
    <updated>2020-01-19T03:01:23.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本程序模拟登录正方教务系统获取本人当前学期成绩（也可以手动改学期学年），20分钟检测一次，当有新成绩公布时就发送到邮箱，本程序用到的是我学校的教务网网址。</p><ul><li>本项目GitHub地址<a href="https://github.com/0202zc/grade_sender" target="_blank" rel="noopener">大连大学成绩监控查询脚本</a><a id="more"></a></li><li>第一代手动输入验证码的程序<a href="https://0202zc.github.io/2018/07/25/Python-3-6-监控爬取成绩并推送到邮箱">Python 3.6 监控爬取成绩并推送到邮箱</a></li><li>验证码识别参照了XiaoYaoII的文章<a href="https://blog.csdn.net/qq_35323001/article/details/79100664" target="_blank" rel="noopener">利用python3 爬取教务处实现自动查询成绩并发送给用户QQ邮箱</a></li><li>使用百度云文字识别的SDK的帮助文档在此<a href="https://ai.baidu.com/docs#/OCR-Python-SDK/top" target="_blank" rel="noopener">Python SDK文档</a></li></ul><h1 id="实现思想"><a href="#实现思想" class="headerlink" title="实现思想"></a>实现思想</h1><p>本程序的实现主要步骤有：</p><ol><li>首先登录进入成绩查询页面</li><li>将对应的所有成绩爬取下来</li><li>将爬取下来的成绩进行格式化（表格）</li><li>美化后的成绩表格发送到邮箱</li></ol><h1 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h1><ol><li>登录<ol><li>得到跳转后页面的地址（为了防止登录重复，教务系统后面会跳转后在网址后面加一串随机的hash码）</li><li>利用百度云识别验证码</li></ol></li><li>将需要的列爬取下来</li><li>每次爬取后让程序暂停20分钟，将每次所爬取的成绩数量进行对比，如果与第一次爬取的数量相同则不发邮件，否则发送邮件</li></ol><h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">大连大学成绩查询助手V1.7.190216</span></span><br><span class="line"><span class="string">Code By ZC Liang</span></span><br><span class="line"><span class="string">2018.6.6</span></span><br><span class="line"><span class="string">Completed on 2019.2.15</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="keyword">import</span> http.cookiejar</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> platform</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> prettytable <span class="keyword">as</span> pt</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> prettytable <span class="keyword">import</span> PrettyTable</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ReadTimeout</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> ConnectionError</span><br><span class="line"></span><br><span class="line">my_sender = <span class="string">'发件人邮箱账号'</span>    <span class="comment"># 发件人邮箱账号</span></span><br><span class="line">my_pass = <span class="string">'发件人邮箱密码'</span>              <span class="comment"># 发件人邮箱密码(当时申请smtp给的口令)</span></span><br><span class="line"><span class="comment"># my_user = '收件人邮箱账号'      # 收件人邮箱账号，我这边发送给自己</span></span><br><span class="line">email_send_to = <span class="string">''</span>                <span class="comment"># 收件人邮箱账号</span></span><br><span class="line"></span><br><span class="line">DstDir = os.getcwd()</span><br><span class="line">searchCount = <span class="number">0</span>  <span class="comment"># 查询次数</span></span><br><span class="line">count = <span class="number">0</span>  <span class="comment"># 循环计数</span></span><br><span class="line">scorenum = <span class="number">0</span>  <span class="comment"># 成绩条数</span></span><br><span class="line">score = []</span><br><span class="line">scorenp = np.array(score)</span><br><span class="line">makeup_course_num = <span class="number">0</span>  <span class="comment"># 重修课程数目</span></span><br><span class="line">makeup_course_flag = <span class="number">-1</span>  <span class="comment"># 重修课程数目下标</span></span><br><span class="line">courseList = [] <span class="comment"># 选课情况查询列表</span></span><br><span class="line">required_course_num = <span class="number">0</span> <span class="comment"># 本学期必修课总数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备Cookie和opener，因为cookie存于opener中，所以以下所有网页操作全部要基于同一个opener</span></span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line">opener = urllib.request.build_opener(</span><br><span class="line">    urllib.request.HTTPCookieProcessor(cookie))</span><br><span class="line"></span><br><span class="line">final_url = <span class="string">""</span>      <span class="comment"># 头 + 随机编码 + default2.aspx</span></span><br><span class="line">final_url_head = <span class="string">""</span></span><br><span class="line">url_head = <span class="string">"202.199.155."</span> + str(random.randint(<span class="number">33</span>, <span class="number">37</span>))     <span class="comment"># 随机产生网址</span></span><br><span class="line"></span><br><span class="line">ddlxn = <span class="string">""</span></span><br><span class="line">ddlxq = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="string">""" 你的 APPID AK SK """</span></span><br><span class="line">APP_ID = <span class="string">'你的 APP_ID'</span></span><br><span class="line">API_KEY = <span class="string">'你的 API_KEY'</span></span><br><span class="line">SECRET_KEY = <span class="string">'你的 SECRET_KEY'</span></span><br><span class="line"></span><br><span class="line">client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="string">""" 读取图片 """</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span><span class="params">(filePath)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filePath, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断操作系统类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOpeningSystem</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> platform.system()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断操作系统类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOpeningSystem</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> platform.system()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否联网</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isConnected</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(<span class="string">'http://'</span> + url_head, timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'网络检测错误status_code: '</span> + response.status_code, <span class="string">'http://'</span> + url_head)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">except</span> (ConnectionError, ReadTimeout):</span><br><span class="line">        print(<span class="string">'无网络连接。'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取重定向编码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_for_redirects</span><span class="params">(url)</span>:</span></span><br><span class="line">    r = requests.head(url)</span><br><span class="line">    <span class="keyword">if</span> r.ok:</span><br><span class="line">        <span class="keyword">return</span> r.headers[<span class="string">'location'</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'[no redirect]'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   图像转换并识别</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_util</span><span class="params">(img)</span>:</span></span><br><span class="line">    new_im = img.convert(<span class="string">"RGB"</span>)  <span class="comment"># 将验证码图片转换成24位图片</span></span><br><span class="line">    new_im.save(<span class="string">''</span> + DstDir + <span class="string">'\\ScoreHelper\\CheckCode1.jpg'</span>)  <span class="comment"># 将24位图片保存到本地</span></span><br><span class="line"></span><br><span class="line">    arr = np.array(Image.open(<span class="string">''</span> + DstDir + <span class="string">'\\ScoreHelper\\CheckCode1.jpg'</span>).convert(<span class="string">"L"</span>))</span><br><span class="line"></span><br><span class="line">    b = <span class="number">255</span> - arr</span><br><span class="line">    im = Image.fromarray(b.astype(<span class="string">'uint8'</span>))  <span class="comment"># 翻转</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># d = 255 * (arr / 255) ** 2</span></span><br><span class="line">    <span class="comment"># im = Image.fromarray(d.astype('uint8'))  # 灰度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#  此处验证过，翻转比灰度识别率更高</span></span><br><span class="line">    im.save(<span class="string">''</span> + DstDir + <span class="string">'\\ScoreHelper\\CheckCode2.jpg'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   验证码识别</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">code_recognition</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#   调用百度云识别验证码</span></span><br><span class="line">        result = client.basicAccurate(get_file_content(<span class="string">''</span> + DstDir + <span class="string">'\\ScoreHelper\\CheckCode2.jpg'</span>))</span><br><span class="line">        word = result.get(<span class="string">'words_result'</span>)</span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> len(word):</span><br><span class="line">            res = re.findall(<span class="string">'[a-zA-Z0-9]+'</span>, word[<span class="number">0</span>].get(<span class="string">'words'</span>))[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> len(res) &gt; <span class="number">4</span>:  <span class="comment"># 教务系统所有的验证码都是四位的，若大于四位，则挑选前四位</span></span><br><span class="line">            res = res[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   登陆</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 构造表单</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'txtUserName'</span>: sid,</span><br><span class="line">        <span class="string">'Textbox1'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'Textbox2'</span>: spwd,</span><br><span class="line">        <span class="string">'RadioButtonList1'</span>: <span class="string">'学生'</span>,</span><br><span class="line">        <span class="string">'Button1'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'lbLanguage'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'hidPdrs'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'hidsc'</span>: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   获取验证码</span></span><br><span class="line">    res = opener.open(final_url_head + <span class="string">'/checkcode.aspx'</span>).read()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">''</span> + DstDir + <span class="string">'\\ScoreHelper\\CheckCode.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(res)</span><br><span class="line">    img = Image.open(<span class="string">''</span> + DstDir + <span class="string">'\\ScoreHelper\\CheckCode.jpg'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   图片处理</span></span><br><span class="line">    image_util(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># img.show()</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'验证码识别结果：'</span> + code_recognition())</span><br><span class="line">    vcode = code_recognition()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># img.close()</span></span><br><span class="line"></span><br><span class="line">    params[<span class="string">'txtSecretCode'</span>] = vcode</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   获取ViewState</span></span><br><span class="line">    response = urllib.request.urlopen(<span class="string">'http://'</span> + url_head + <span class="string">'/'</span>)</span><br><span class="line">    html = response.read().decode(<span class="string">'gb2312'</span>)</span><br><span class="line">    viewstate = re.search(</span><br><span class="line">        <span class="string">'&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"'</span>, html)</span><br><span class="line">    params[<span class="string">'__VIEWSTATE'</span>] = viewstate.group(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#   尝试登陆</span></span><br><span class="line">    loginurl = final_url</span><br><span class="line">    print(<span class="string">"\n本次登录所用网址为："</span> + loginurl + <span class="string">"\n"</span>)</span><br><span class="line">    data = urllib.parse.urlencode(params).encode(<span class="string">'gb2312'</span>)</span><br><span class="line">    response = opener.open(loginurl, data)</span><br><span class="line">    <span class="keyword">if</span> response.geturl() == final_url:</span><br><span class="line">        print(<span class="string">'登陆失败，可能是姓名，学号，密码或验证码填写错误！'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   获取本学期必修课数目</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_RequiredCourse_num</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> required_course_num</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"正在查询本学期必修课数目..."</span>)</span><br><span class="line">    <span class="comment">#   构造url</span></span><br><span class="line">    url = <span class="string">''</span>.join([</span><br><span class="line">        final_url_head + <span class="string">'/xsxkqk.aspx'</span>,</span><br><span class="line">        <span class="string">'?xh='</span>,</span><br><span class="line">        sid,</span><br><span class="line">        <span class="string">'&amp;xm='</span>,</span><br><span class="line">        urllib.parse.quote(sname),</span><br><span class="line">        <span class="string">'&amp;gnmkdm=N121615'</span>,</span><br><span class="line">    ])</span><br><span class="line">    <span class="comment">#   构建查询学生选课情况表单</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'ddlxn'</span>: ddlxn,</span><br><span class="line">        <span class="string">'ddlxq'</span>: ddlxq,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   构造Request对象，填入Header，防止302跳转，获取新的View_State</span></span><br><span class="line">    req = urllib.request.Request(url)</span><br><span class="line">    req.add_header(<span class="string">'Referer'</span>, final_url)</span><br><span class="line">    req.add_header(<span class="string">'Origin'</span>, <span class="string">'http://'</span> + url_head + <span class="string">'/'</span>)</span><br><span class="line">    req.add_header(</span><br><span class="line">        <span class="string">'User-Agent'</span>,</span><br><span class="line">        <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36'</span>)</span><br><span class="line">    response = opener.open(req)</span><br><span class="line">    html = response.read().decode(<span class="string">'gb2312'</span>)</span><br><span class="line">    viewstate = re.search(</span><br><span class="line">        <span class="string">'&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"'</span>, html)</span><br><span class="line">    params[<span class="string">'__VIEWSTATE'</span>] = viewstate.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   查询所有成绩</span></span><br><span class="line">    req = urllib.request.Request(</span><br><span class="line">        url, urllib.parse.urlencode(params).encode(<span class="string">'gb2312'</span>))</span><br><span class="line">    req.add_header(<span class="string">'Referer'</span>, final_url)</span><br><span class="line">    req.add_header(<span class="string">'Origin'</span>, <span class="string">'http://'</span> + url_head + <span class="string">'/'</span>)</span><br><span class="line">    response = opener.open(req)</span><br><span class="line">    soup = BeautifulSoup(response.read().decode(<span class="string">'gb2312'</span>), <span class="string">'html.parser'</span>)</span><br><span class="line">    html = soup.find(<span class="string">'table'</span>, class_=<span class="string">'datelist'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   指定要输出的列，原网页的表格列下标从0开始</span></span><br><span class="line">    <span class="comment">#   用于标记是否是遍历第一行</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="comment">#   根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象</span></span><br><span class="line">    <span class="comment">#   遍历行</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> html:</span><br><span class="line">        columnCounter = <span class="number">0</span></span><br><span class="line">        column = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> type(each) == bs4.element.NavigableString:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#   遍历列</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> each.contents:</span><br><span class="line">                <span class="keyword">if</span> item != <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="keyword">if</span> counter &gt; <span class="number">0</span> <span class="keyword">and</span> columnCounter == <span class="number">3</span>:</span><br><span class="line">                        courseList.append(str(item.contents[<span class="number">0</span>]).strip())</span><br><span class="line">                    columnCounter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                flag = <span class="keyword">False</span></span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> courseList:</span><br><span class="line">        <span class="keyword">if</span> each == <span class="string">"必修课程"</span>:</span><br><span class="line">            required_course_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   获取成绩</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getScore</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> searchCount</span><br><span class="line">    <span class="keyword">global</span> scorenum</span><br><span class="line">    <span class="keyword">global</span> scorenp</span><br><span class="line">    <span class="keyword">global</span> ddlxn</span><br><span class="line">    <span class="keyword">global</span> ddlxq</span><br><span class="line">    score = []</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   构造url</span></span><br><span class="line">    url = <span class="string">''</span>.join([</span><br><span class="line">        final_url_head + <span class="string">'/xscjcx_dq.aspx'</span>,</span><br><span class="line">        <span class="string">'?xh='</span>,</span><br><span class="line">        sid,</span><br><span class="line">        <span class="string">'&amp;xm='</span>,</span><br><span class="line">        urllib.parse.quote(sname),</span><br><span class="line">        <span class="string">'&amp;gnmkdm=N121605'</span>,</span><br><span class="line">    ])</span><br><span class="line">    <span class="comment">#   构建查询全部成绩表单</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">'ddlxn'</span>: ddlxn,  <span class="comment"># 全部为 %C8%AB%B2%BF</span></span><br><span class="line">        <span class="string">'ddlxq'</span>: ddlxq,</span><br><span class="line">        <span class="string">'btnCx'</span>: <span class="string">'查询'</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   构造Request对象，填入Header，防止302跳转，获取新的View_State</span></span><br><span class="line">    req = urllib.request.Request(url)</span><br><span class="line">    req.add_header(<span class="string">'Referer'</span>, final_url)</span><br><span class="line">    req.add_header(<span class="string">'Origin'</span>, <span class="string">'http://'</span> + url_head + <span class="string">'/'</span>)</span><br><span class="line">    req.add_header(</span><br><span class="line">        <span class="string">'User-Agent'</span>,</span><br><span class="line">        <span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36'</span>)</span><br><span class="line">    response = opener.open(req)</span><br><span class="line">    html = response.read().decode(<span class="string">'gb2312'</span>)</span><br><span class="line">    viewstate = re.search(</span><br><span class="line">        <span class="string">'&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"'</span>, html)</span><br><span class="line">    params[<span class="string">'__VIEWSTATE'</span>] = viewstate.group(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   查询所有成绩</span></span><br><span class="line">    req = urllib.request.Request(</span><br><span class="line">        url, urllib.parse.urlencode(params).encode(<span class="string">'gb2312'</span>))</span><br><span class="line">    req.add_header(<span class="string">'Referer'</span>, final_url)</span><br><span class="line">    req.add_header(<span class="string">'Origin'</span>, <span class="string">'http://'</span> + url_head + <span class="string">'/'</span>)</span><br><span class="line">    response = opener.open(req)</span><br><span class="line">    soup = BeautifulSoup(response.read().decode(<span class="string">'gb2312'</span>), <span class="string">'html.parser'</span>)</span><br><span class="line">    html = soup.find(<span class="string">'table'</span>, class_=<span class="string">'datelist'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"执行第"</span> + str(searchCount) + <span class="string">"次查询："</span>)</span><br><span class="line">    print(<span class="string">'你的所有成绩如下：'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#   指定要输出的列，原网页的表格列下标从0开始</span></span><br><span class="line">    outColumn = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">    <span class="comment">#   用于标记是否是遍历第一行</span></span><br><span class="line">    flag = <span class="keyword">True</span></span><br><span class="line">    <span class="comment">#   根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象</span></span><br><span class="line">    <span class="comment">#   遍历行</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> html:</span><br><span class="line">        columnCounter = <span class="number">0</span></span><br><span class="line">        column = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> type(each) == bs4.element.NavigableString:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#   遍历列</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> each.contents:</span><br><span class="line">                <span class="keyword">if</span> item != <span class="string">'\n'</span>:</span><br><span class="line">                    <span class="keyword">if</span> columnCounter <span class="keyword">in</span> outColumn:</span><br><span class="line">                        <span class="comment">#   要使用str转换，不然陷入copy与deepcopy的无限递归</span></span><br><span class="line">                        column.append(str(item.contents[<span class="number">0</span>]).strip())</span><br><span class="line">                    columnCounter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                table = PrettyTable(column)</span><br><span class="line">                flag = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table.add_row(column)</span><br><span class="line">            score.extend([column])</span><br><span class="line">    searchCount += <span class="number">1</span></span><br><span class="line">    scorenp = np.array(score)</span><br><span class="line">    <span class="comment">#   table.set_style(pt.PLAIN_COLUMNS)</span></span><br><span class="line"></span><br><span class="line">    print(table)</span><br><span class="line">    print(<span class="string">"分条统计："</span>)</span><br><span class="line">    scorenum = sendScore(table)</span><br><span class="line">    print(<span class="string">"成绩数目: "</span> + str(scorenum) + <span class="string">"条"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendScore</span><span class="params">(table)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> scorenum</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    <span class="keyword">global</span> email_send_to</span><br><span class="line">    <span class="keyword">global</span> scorenp</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> table:</span><br><span class="line">        print(i.get_string())</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count &gt; scorenum:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            scorenum = count</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 文本模式</span></span><br><span class="line">            <span class="comment"># context = i.get_string().replace("+"," ")</span></span><br><span class="line">            <span class="comment"># context = context.replace("-"," ")</span></span><br><span class="line">            <span class="comment"># context = context.replace("2017 2018","2017-2018")</span></span><br><span class="line">            <span class="comment"># if(scorenum == 1):</span></span><br><span class="line">            <span class="comment">#     msg=MIMEText("有成绩下来了：" + context,'plain','utf-8')</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     msg=MIMEText("又有成绩下来了：" + context,'plain','utf-8')</span></span><br><span class="line">            <span class="comment"># msg = prettyScore()</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># html格式</span></span><br><span class="line">            msg = prettyScore()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 括号里的对应发件人邮箱昵称、发件人邮箱账号</span></span><br><span class="line">            msg[<span class="string">'From'</span>] = formataddr([<span class="string">"1115810371@qq.com"</span>, my_sender])</span><br><span class="line">            <span class="comment"># 括号里的对应收件人邮箱昵称、收件人邮箱账号</span></span><br><span class="line">            msg[<span class="string">'To'</span>] = formataddr([email_send_to, email_send_to])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count == required_course_num:</span><br><span class="line">                msg[<span class="string">'Subject'</span>] = <span class="string">"第"</span> + str(count) + <span class="string">"次成绩推送加平均绩点"</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                msg[<span class="string">'Subject'</span>] = <span class="string">"第"</span> + str(count) + <span class="string">"次成绩推送"</span>  <span class="comment"># 邮件的主题，也可以说是标题</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发件人邮箱中的SMTP服务器，端口是465</span></span><br><span class="line">            server = smtplib.SMTP_SSL(<span class="string">"smtp.qq.com"</span>, <span class="number">465</span>)</span><br><span class="line">            server.login(my_sender, my_pass)  <span class="comment"># 括号中对应的是发件人邮箱账号、邮箱密码</span></span><br><span class="line">            <span class="comment"># 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件</span></span><br><span class="line">            server.sendmail(my_sender, [email_send_to, ], msg.as_string())</span><br><span class="line">            server.quit()  <span class="comment"># 关闭连接</span></span><br><span class="line">            print(<span class="string">"发送成功，请注意在此邮箱查收："</span> + email_send_to)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            print(<span class="string">"发送失败！"</span>)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> scorenum != required_course_num:</span><br><span class="line">        print(<span class="string">"程序休息中...（按'Ctrl C'结束）"</span>)</span><br><span class="line">        time.sleep(<span class="number">1200</span>)  <span class="comment"># 二十分钟查一次</span></span><br><span class="line">    <span class="keyword">return</span> scorenum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   接收构造成功的表格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prettyScore</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> scorenp</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># context = MIMEText(html,_subtype='html',_charset='utf-8')  #解决乱码</span></span><br><span class="line">        msg = MIMEText(str(htmlText(scorenum)), <span class="string">"html"</span>, <span class="string">"gb2312"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   构造邮件内容：成绩表格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlText</span><span class="params">(scorenum)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> required_course_num</span><br><span class="line"></span><br><span class="line">    html = <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        &lt;table color="CCCC33" width="800" border="1" cellspacing="0" cellpadding="5" text-align="center"&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                &lt;tr&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                        &lt;td&gt;课程名称&lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                        &lt;td&gt;课程性质&lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                        &lt;td&gt;学分&lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                        &lt;td&gt;平时成绩&lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                        &lt;td&gt;期末成绩&lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                        &lt;td&gt;成绩&lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                &lt;/tr&gt;   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    """</span> + addtrs(scorenum) + <span class="string">"""</span></span><br><span class="line"><span class="string">                        &lt;/table&gt;</span></span><br><span class="line"><span class="string">                    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#   最后一次推送时计算GPA并与成绩表格一起推送</span></span><br><span class="line">    <span class="keyword">if</span> scorenum == required_course_num:</span><br><span class="line">        html += <span class="string">"""</span></span><br><span class="line"><span class="string">                        &lt;br/&gt;</span></span><br><span class="line"><span class="string">                        &lt;div class='gpa_text' style='font-size: 25px;font-style: italic;'&gt;--&gt;平均绩点：%s &lt;--&lt;/div&gt;</span></span><br><span class="line"><span class="string">                    """</span> % (getGPA()) + <span class="string">"""</span></span><br><span class="line"><span class="string">                        &lt;br/&gt;</span></span><br><span class="line"><span class="string">                        &lt;div class='end_words' style='font-size: 20px;'&gt;本学期考试成绩查询完成！&lt;/div&gt;</span></span><br><span class="line"><span class="string">                    """</span></span><br><span class="line">    <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   在发送的表格里添加成绩行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addtrs</span><span class="params">(scorenum)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> scorenp</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    array = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= scorenum:</span><br><span class="line">        trs = <span class="string">'''</span></span><br><span class="line"><span class="string">                                    &lt;tr&gt;   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                            &lt;td&gt;%s &lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                            &lt;td&gt;%s &lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                            &lt;td&gt;%s &lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                            &lt;td&gt;%s &lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                            &lt;td&gt;%s &lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                        '''</span> % (scorenp[i][<span class="number">0</span>], scorenp[i][<span class="number">1</span>], scorenp[i][<span class="number">2</span>], scorenp[i][<span class="number">3</span>], scorenp[i][<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">if</span> (scorenp[i][<span class="number">5</span>].isalpha() <span class="keyword">and</span> scorenp[i][<span class="number">5</span>] == <span class="string">"A"</span>) <span class="keyword">or</span> (scorenp[i][<span class="number">5</span>].isdigit() <span class="keyword">and</span> int(scorenp[i][<span class="number">5</span>]) &gt;= <span class="number">90</span>):</span><br><span class="line">            <span class="comment">#   等级A和90以上的成绩标记为绿色</span></span><br><span class="line">            trs += <span class="string">'&lt;td style="color:springgreen;"&gt;'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> (scorenp[i][<span class="number">5</span>].isalpha() <span class="keyword">and</span> scorenp[i][<span class="number">5</span>] == <span class="string">"F"</span>) <span class="keyword">or</span> (</span><br><span class="line">                scorenp[i][<span class="number">5</span>].isdigit() <span class="keyword">and</span> int(scorenp[i][<span class="number">5</span>]) &lt; <span class="number">60</span>):</span><br><span class="line">            <span class="comment">#   不及格的成绩标记为红色</span></span><br><span class="line">            trs += <span class="string">'&lt;td style="color:red;"&gt;'</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#   普通成绩不标记</span></span><br><span class="line">            trs += <span class="string">'&lt;td&gt;'</span></span><br><span class="line"></span><br><span class="line">        trs += <span class="string">'''</span></span><br><span class="line"><span class="string">                            %s &lt;/td&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                    &lt;/tr&gt;</span></span><br><span class="line"><span class="string">        '''</span> % (scorenp[i][<span class="number">5</span>])</span><br><span class="line">        array.append(trs)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    s = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> array:</span><br><span class="line">        s += str(x)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   计算GPA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getGPA</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> scorenp</span><br><span class="line">    <span class="keyword">global</span> scorenum</span><br><span class="line">    <span class="keyword">global</span> makeup_course_num</span><br><span class="line">    <span class="keyword">global</span> makeup_course_flag</span><br><span class="line"></span><br><span class="line">    sc = []</span><br><span class="line">    GPAlist = []</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    coursenum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt;= scorenum:</span><br><span class="line">        <span class="keyword">if</span> scorenp[i][<span class="number">1</span>] != <span class="string">"必修课程"</span> <span class="keyword">or</span> scorenp[i][<span class="number">6</span>] == <span class="string">"是"</span>:</span><br><span class="line">            <span class="comment">#   排除非必修课以及重修课</span></span><br><span class="line">            makeup_course_num += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment">#   有些成绩是等级，需要转换为数字</span></span><br><span class="line">            <span class="keyword">if</span> scorenp[i][<span class="number">5</span>].isalpha() <span class="keyword">and</span> scorenp[i][<span class="number">5</span>] != <span class="string">"F"</span>:</span><br><span class="line">                sc.append(<span class="number">745</span> - <span class="number">10</span> * ord(scorenp[i][<span class="number">5</span>]))  <span class="comment"># 计算式子：x - (x - A) + 10 * (D - x) 即 745 - 10 * x</span></span><br><span class="line">            <span class="keyword">elif</span> scorenp[i][<span class="number">5</span>] == <span class="string">"F"</span>:</span><br><span class="line">                sc.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                sc.append(int(scorenp[i][<span class="number">5</span>]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> int(sc[j]) &lt; <span class="number">60</span>:</span><br><span class="line">                <span class="comment">#   不及格的科目绩点为0</span></span><br><span class="line">                GPAlist.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#   计算单科绩点</span></span><br><span class="line">                GPAlist.append((int(sc[j]) - <span class="number">50</span>) / <span class="number">10</span> * float(scorenp[i][<span class="number">2</span>]))</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            coursenum += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    scoresum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt;= scorenum:</span><br><span class="line">        <span class="keyword">if</span> scorenp[i][<span class="number">1</span>] != <span class="string">"必修课程"</span> <span class="keyword">or</span> scorenp[i][<span class="number">6</span>] == <span class="string">"是"</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        sum += GPAlist[j]</span><br><span class="line">        scoresum += float(scorenp[i][<span class="number">2</span>])</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    GPA = sum / scoresum</span><br><span class="line">    print(<span class="string">"平均绩点："</span> + str(GPA))</span><br><span class="line">    <span class="keyword">return</span> GPA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#   根据当前日期设置查询学期</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setSemester</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ddlxn</span><br><span class="line">    <span class="keyword">global</span> ddlxq</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        localtime = time.localtime(time.time())  <span class="comment"># 获取当前日期</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#   第一学期是从当年9月到次年2月，第二学期则是从当年3月到8月</span></span><br><span class="line">        <span class="keyword">if</span> (int((localtime.tm_mon) &gt;= <span class="number">9</span> <span class="keyword">and</span> int(localtime.tm_mon) &lt;= <span class="number">12</span>) <span class="keyword">or</span> (</span><br><span class="line">                int(localtime.tm_mon) &gt;= <span class="number">1</span> <span class="keyword">and</span> int(localtime.tm_mon) &lt;= <span class="number">2</span>)):</span><br><span class="line">            <span class="comment"># if (str(localtime.tm_year) == "2020" and int((localtime.tm_mon) &gt;= 7)):</span></span><br><span class="line">            <span class="comment">#     print("您已毕业，无须监控成绩！")</span></span><br><span class="line">            <span class="comment">#     sys.exit(0)</span></span><br><span class="line">            <span class="keyword">if</span> (int(localtime.tm_mon) &gt;= <span class="number">1</span> <span class="keyword">and</span> int(localtime.tm_mon) &lt;= <span class="number">2</span>):</span><br><span class="line">                ddlxn = str(localtime.tm_year - <span class="number">1</span>) + <span class="string">'-'</span> + str(int(localtime.tm_year))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ddlxn = str(localtime.tm_year) + <span class="string">'-'</span> + str(int(localtime.tm_year) + <span class="number">1</span>)</span><br><span class="line">            ddlxq = <span class="string">'1'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ddlxn = str(int(localtime.tm_year) - <span class="number">1</span>) + <span class="string">'-'</span> + str(localtime.tm_year)</span><br><span class="line">            ddlxq = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    setSemester()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        searchCount = <span class="number">1</span></span><br><span class="line">        print(<span class="string">'欢迎使用大连大学成绩查询助手！'</span>)</span><br><span class="line">        print(<span class="string">'正在检查网络...'</span>)</span><br><span class="line">        <span class="keyword">if</span> isConnected():</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">r''</span> + DstDir + <span class="string">'\\ScoreHelper\\uinfo.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> file:</span><br><span class="line">                udick = pickle.load(file)</span><br><span class="line">                sname = udick[<span class="string">'sname'</span>]</span><br><span class="line">                sid = udick[<span class="string">'sid'</span>]</span><br><span class="line">                spwd = udick[<span class="string">'spwd'</span>]</span><br><span class="line">                email_send_to = udick[<span class="string">'email_send_to'</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">#   构造登录地址</span></span><br><span class="line">            final_url = <span class="string">'http://'</span> + url_head + \</span><br><span class="line">                        check_for_redirects(<span class="string">'http://'</span> + url_head + <span class="string">'/default2.aspx'</span>)</span><br><span class="line">            final_url_head = final_url[<span class="number">0</span>:<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line">            loginCount = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> login():</span><br><span class="line">                <span class="keyword">if</span> loginCount &gt; <span class="number">3</span>:</span><br><span class="line">                    <span class="comment">#   超过三次未登录自动更换网址</span></span><br><span class="line">                    url_head = <span class="string">"202.199.155."</span> + str(random.randint(<span class="number">33</span>, <span class="number">37</span>))</span><br><span class="line">                    final_url = <span class="string">'http://'</span> + url_head + \</span><br><span class="line">                                check_for_redirects(<span class="string">'http://'</span> + url_head + <span class="string">'/default2.aspx'</span>)</span><br><span class="line">                    final_url_head = final_url[<span class="number">0</span>:<span class="number">48</span>]</span><br><span class="line">                    loginCount = <span class="number">0</span></span><br><span class="line">                loginCount += <span class="number">1</span></span><br><span class="line">                print(<span class="string">"正在等待重试..."</span>)</span><br><span class="line">                time.sleep(<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            get_RequiredCourse_num()</span><br><span class="line">            getScore()</span><br><span class="line">            counter = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> scorenum &lt;= required_course_num:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> scorenum == required_course_num:</span><br><span class="line">                    print(<span class="string">"本学期成绩查询完成！"</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> counter &gt; <span class="number">0</span>:</span><br><span class="line">                    getScore()</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="comment"># if os.path.exists(r'' + DstDir + '\\ScoreHelper'):</span></span><br><span class="line">        <span class="comment">#     os.remove(r'' + DstDir + '\\ScoreHelper')</span></span><br><span class="line">        os.mkdir(<span class="string">r''</span> + DstDir + <span class="string">'\\ScoreHelper'</span>)  <span class="comment"># 注：针对Windows目录结构</span></span><br><span class="line">        print(<span class="string">'这是你第一次使用，请按提示输入信息，以后可不必再次输入~'</span>)</span><br><span class="line">        sid = input(<span class="string">'请输入学号：'</span>)</span><br><span class="line">        sname = input(<span class="string">'请输入姓名：'</span>)</span><br><span class="line">        <span class="comment"># 隐藏密码</span></span><br><span class="line">        <span class="comment"># spwd = getpass.getpass('请输入密码：')</span></span><br><span class="line">        spwd = input(<span class="string">'请输入密码：'</span>)</span><br><span class="line">        email_send_to = input(<span class="string">'请输入要将成绩发送到的邮箱地址：'</span>)</span><br><span class="line">        udick = &#123;<span class="string">'sname'</span>: sname, <span class="string">'sid'</span>: sid,</span><br><span class="line">                 <span class="string">'spwd'</span>: spwd, <span class="string">'email_send_to'</span>: email_send_to&#125;</span><br><span class="line">        file = open(<span class="string">r''</span> + DstDir + <span class="string">'\\ScoreHelper\\uinfo.bin'</span>, <span class="string">'wb'</span>)</span><br><span class="line">        pickle.dump(udick, file)</span><br><span class="line">        file.close()</span><br><span class="line">        final_url = <span class="string">'http://'</span> + url_head + \</span><br><span class="line">                    check_for_redirects(<span class="string">'http://'</span> + url_head + <span class="string">'/default2.aspx'</span>)</span><br><span class="line">        final_url_head = final_url[<span class="number">0</span>:<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment">#   登录失败，重试</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> login():</span><br><span class="line">            sname = input(<span class="string">'请输入姓名：'</span>)</span><br><span class="line">            sid = input(<span class="string">'请输入学号：'</span>)</span><br><span class="line">            <span class="comment"># spwd = getpass.getpass('请输入密码：')</span></span><br><span class="line">            spwd = input(<span class="string">'请输入密码：'</span>)</span><br><span class="line">            email_send_to = input(<span class="string">'请输入要将成绩发送到的邮箱地址：'</span>)</span><br><span class="line">            udick = &#123;<span class="string">'sname'</span>: sname, <span class="string">'sid'</span>: sid,</span><br><span class="line">                     <span class="string">'spwd'</span>: spwd, <span class="string">'email_send_to'</span>: email_send_to&#125;</span><br><span class="line">            file = open(<span class="string">r''</span> + DstDir + <span class="string">'\\ScoreHelper\\uinfo.bin'</span>, <span class="string">'wb'</span>)</span><br><span class="line">            pickle.dump(udick, file)</span><br><span class="line">            file.close()</span><br><span class="line">            final_url = <span class="string">'http://'</span> + url_head + \</span><br><span class="line">                        check_for_redirects(<span class="string">'http://'</span> + url_head + <span class="string">'/default2.aspx'</span>)</span><br><span class="line">            final_url_head = final_url[<span class="number">0</span>:<span class="number">48</span>]</span><br><span class="line">        get_RequiredCourse_num()</span><br><span class="line">        getScore()</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> scorenum &lt;= required_course_num:</span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> scorenum == required_course_num:</span><br><span class="line">                print(<span class="string">"本学期成绩查询完成！"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> counter &gt; <span class="number">0</span>:</span><br><span class="line">                getScore()</span><br><span class="line">            print(scorenum)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> subprocess.CalledProcessError:</span><br><span class="line">        print(<span class="string">"网络连接不正常！请检查网络！"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        print(<span class="string">"失败！可能是你没有完成教学评价！没有完成教学评价则无法查看成绩！或用户中途取消或网络故障。"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># if os.path.exists(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg'):</span></span><br><span class="line">        <span class="comment">#     os.remove(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg')</span></span><br><span class="line">        print(<span class="string">"程序将在3秒后退出..."</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img data-src="/images/Screenshot2018-12-29-00-11.png" alt="" title="电脑端运行截图"></p><p><img data-src="/images/Screenshot_2018-07-26-16-10-33-543_com.netease.mo.png" alt="" title="该学期最后一次查询发送成功 截图"></p><p><img data-src="/images/Screenshot_2018-12-29-00-00-27-699_com.netease.mo.png" alt="" title="最近一次运行截图"></p><h1 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h1><ul><li><p>当百度云识别不成功时，为了防止网页错误，我设置了3秒间隔重试登录</p></li><li><p>当多次识别不成功时，程序可能结束</p></li><li><p>关于自动判断学期的功能，我是根据我个人的毕业时间来算的结束监控的年月日期，请按需修改</p></li><li><p>当教务网关闭以及断网的时候本程序就不灵了。。。</p></li><li><p>由于session有时间限制，所以每隔一段时间（约27小时）就要重新登录</p></li></ul><h1 id="本程序需要改进的一些功能"><a href="#本程序需要改进的一些功能" class="headerlink" title="本程序需要改进的一些功能"></a>本程序需要改进的一些功能</h1><ul><li>程序被停止后需要立即重新运行（在完善中）</li></ul><h1 id="修复日志"><a href="#修复日志" class="headerlink" title="修复日志"></a>修复日志</h1><ul><li>2019-1-2 修复日期计算错误的问题</li></ul><hr><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><h2 id="新增python控制自动运行-bat文件功能，使程序得以无休止运行"><a href="#新增python控制自动运行-bat文件功能，使程序得以无休止运行" class="headerlink" title="新增python控制自动运行.bat文件功能，使程序得以无休止运行"></a>新增python控制自动运行.bat文件功能，使程序得以无休止运行</h2><ul><li><p>battle.bat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@echo off </span><br><span class="line"></span><br><span class="line">cd  ./</span><br><span class="line"></span><br><span class="line">start python 成绩监控并推送.py</span><br></pre></td></tr></table></figure></li><li><p>startpy.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># startpy.py</span></span><br><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSth</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 把爬虫程序放在这个类里</span></span><br><span class="line">    print(<span class="string">'这个程序要开始疯狂的运转啦'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">            command = path + <span class="string">'/battle.bat'</span></span><br><span class="line">            os.system(command)</span><br><span class="line">    <span class="keyword">except</span> (IOError, Exception) <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    path = os.getcwd()</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    timeCount = <span class="number">0</span></span><br><span class="line">    doSth()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> timeCount &lt; <span class="number">27</span>:</span><br><span class="line">        timeCount += <span class="number">1</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"程序第"</span>,end=<span class="string">""</span>)</span><br><span class="line">        print(count,end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"次执行"</span>)</span><br><span class="line">        <span class="keyword">if</span> timeCount == <span class="number">27</span>:</span><br><span class="line">            timeCount = <span class="number">0</span></span><br><span class="line">            <span class="comment"># doSth()</span></span><br><span class="line">        <span class="comment"># 每隔1小时检测一次</span></span><br><span class="line">        time.sleep(<span class="number">3600</span>)</span><br></pre></td></tr></table></figure></li><li>startpy.py运行截图：<br><img data-src="/images/screenshot2019-01-13-18-59.png" alt=""></li></ul><h1 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h1><h2 id="更新-2019-2-12"><a href="#更新-2019-2-12" class="headerlink" title="更新(2019-2-12)"></a>更新(2019-2-12)</h2><h3 id="将验证码图片颜色翻转，提高识别准确率"><a href="#将验证码图片颜色翻转，提高识别准确率" class="headerlink" title="将验证码图片颜色翻转，提高识别准确率"></a>将验证码图片颜色翻转，提高识别准确率</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#   图像转换并识别</span><br><span class="line">def image_util(img):</span><br><span class="line">    new_im = img.convert(&quot;RGB&quot;)  # 将验证码图片转换成24位图片</span><br><span class="line">    new_im.save(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode1.jpg&apos;)  # 将24位图片保存到本地</span><br><span class="line"></span><br><span class="line">    arr = np.array(Image.open(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode1.jpg&apos;).convert(&quot;L&quot;))</span><br><span class="line"></span><br><span class="line">    b = 255 - arr</span><br><span class="line">    im = Image.fromarray(b.astype(&apos;uint8&apos;))  # 翻转</span><br><span class="line"></span><br><span class="line">    # d = 255 * (arr / 255) ** 2</span><br><span class="line">    # im = Image.fromarray(d.astype(&apos;uint8&apos;))  # 灰度</span><br><span class="line"></span><br><span class="line">    #  此处验证过，翻转比灰度识别率更高</span><br><span class="line">    im.save(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode2.jpg&apos;)</span><br></pre></td></tr></table></figure><h2 id="更新-2019-2-15"><a href="#更新-2019-2-15" class="headerlink" title="更新(2019-2-15)"></a>更新(2019-2-15)</h2><h3 id="更改重试次数限制，当出现三次登录不成功时，更换网址重新登录"><a href="#更改重试次数限制，当出现三次登录不成功时，更换网址重新登录" class="headerlink" title="更改重试次数限制，当出现三次登录不成功时，更换网址重新登录"></a>更改重试次数限制，当出现三次登录不成功时，更换网址重新登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    ...</span><br><span class="line">    loginCount = 0</span><br><span class="line">    while not login():</span><br><span class="line">    if loginCount &gt; 3:</span><br><span class="line">        #   超过三次未登录自动更换网址</span><br><span class="line">        url_head = &quot;202.199.155.&quot; + str(random.randint(33, 37))</span><br><span class="line">        final_url = &apos;http://&apos; + url_head + \</span><br><span class="line">                    check_for_redirects(&apos;http://&apos; + url_head + &apos;/default2.aspx&apos;)</span><br><span class="line">        final_url_head = final_url[0:48]</span><br><span class="line">        loginCount = 0</span><br><span class="line">    loginCount += 1</span><br><span class="line">    print(&quot;正在等待重试...&quot;)</span><br><span class="line">    time.sleep(3)</span><br><span class="line">    continue</span><br><span class="line"></span><br><span class="line">    get_RequiredCourse_num()</span><br><span class="line">    getScore()</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;本程序模拟登录正方教务系统获取本人当前学期成绩（也可以手动改学期学年），20分钟检测一次，当有新成绩公布时就发送到邮箱，本程序用到的是我学校的教务网网址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本项目GitHub地址&lt;a href=&quot;https://github.com/0202zc/grade_sender&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;大连大学成绩监控查询脚本&lt;/a&gt;
    
    </summary>
    
      <category term="Python学习" scheme="http://0202zc.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="网络爬虫" scheme="http://0202zc.github.io/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
