<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>L..z、℃的博客</title>
  
  <subtitle>Be unfazed by defeat.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0202zc.github.io/"/>
  <updated>2020-02-29T04:34:22.347Z</updated>
  <id>http://0202zc.github.io/</id>
  
  <author>
    <name>0202zc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>环路检测</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm-linked-list-cycle-lcci/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm-linked-list-cycle-lcci/</id>
    <published>2020-02-29T04:29:05.000Z</published>
    <updated>2020-02-29T04:34:22.347Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/linked-list-cycle-lcci/" target="_blank" rel="noopener">面试题 02.08. Linked List Cycle LCCI</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong><code>head = [3,2,0,-4]</code>, <code>pos = 1</code><br><strong>输出：</strong>tail connects to node index 1<br><strong>解释：</strong>链表中有一个环，其尾部连接到第二个节点。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1,2]</code>, <code>pos = 0</code><br><strong>输出：</strong>tail connects to node index 0<br><strong>解释：</strong>链表中有一个环，其尾部连接到第一个节点。</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p><strong>输入：</strong><code>head = [1]</code>, <code>pos = -1</code><br><strong>输出：</strong>no cycle<br><strong>解释：</strong>链表中没有环。</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>经典的快慢指针问题，这里给出C的解法。</p><blockquote><ol><li>设置快慢指针</li></ol></blockquote><blockquote><ol start="2"><li>找到第一次相遇【快慢指针相遇】</li></ol></blockquote><blockquote><ol start="3"><li>再出发慢指针【从头结点出发的慢指针与快指针】</li></ol></blockquote><blockquote><ol start="4"><li>相遇即所求</li></ol></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">slow</span> = <span class="title">head</span>, *<span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 快慢指针</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 如果相遇了就break</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fast到了链表尾部,说明链表无环</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 慢指针从头开始, 快慢指针再一次相遇就是在环的起点</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题 02.08. Linked List Cycle LCCI&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>重排链表</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm-reorder-list/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm-reorder-list/</id>
    <published>2020-02-29T03:19:36.000Z</published>
    <updated>2020-02-29T03:19:49.244Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. Reorder List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><hr><p>给定一个单链表 $L：L_0→L_1→…→Ln-1→L_n$ ，<br>将其重新排列后变为： $L_0→L_n→L_1→Ln-1→L_2→Ln-2→…$</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>示例 1:</strong></p><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4</code>, 重新排列为 <code>1-&gt;4-&gt;2-&gt;3</code>.</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, 重新排列为 <code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</p></blockquote><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><blockquote><p>给定链表 <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, 重新排列为 <code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</p></blockquote><p>通过观察，可以将重排链表分解为以下三个步骤：</p><ol><li>首先重新排列后，链表的中心节点会变为最后一个节点。所以需要先找到链表的中心节点：<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. 链表的中间结点</a></li><li>可以按照中心节点将原始链表划分为左右两个链表。<ol><li>按照中心节点将原始链表划分为左右两个链表，左链表：<code>1-&gt;2-&gt;3</code> 右链表：<code>4-&gt;5</code>。</li><li>将右链表反转，就正好是重排链表交换的顺序，右链表反转：<code>5-&gt;4</code>。反转链表：<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></li></ol></li><li>合并两个链表，将右链表插入到左链表，即可重新排列成：<code>1-&gt;5-&gt;2-&gt;4-&gt;3</code>.</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用快慢指针,找出链表的中心节点</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过递归反转链表</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">L</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">p</span>;</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = head-&gt;next;</span><br><span class="line">        head-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = head;</span><br><span class="line">        head = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 合并两个链表，将右链表插入到左链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(struct ListNode* left, struct ListNode* right)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">leftTemp</span>, *<span class="title">rightTemp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge的循环时候条件应为: 当右链表为空的时候,就结束循环</span></span><br><span class="line">    <span class="comment">// 原因是: </span></span><br><span class="line">    <span class="comment">//     1.你取了中心节点的next为右链表的head, 那么两者的长度一定是  左链表 &gt; 右链表</span></span><br><span class="line">    <span class="comment">//     2. 当原始链表为:  奇数 左链表=右链表+1 ; 偶数 左链表=右链表+2</span></span><br><span class="line">    <span class="comment">// 所以: 只用判断右链表的节点是否为空就可以了,而不用判断左链表. 左链表的next肯定有值.</span></span><br><span class="line">    <span class="keyword">while</span>(right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//1. 保存next节点</span></span><br><span class="line">        leftTemp = left-&gt;next;</span><br><span class="line">        rightTemp = right-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将右链表的第一个节点插入到左链表中</span></span><br><span class="line">        <span class="comment">// 左链表：1-&gt;2-&gt;3 右链表：5-&gt;4 </span></span><br><span class="line">        <span class="comment">// 合并后的左链表：1-&gt;5-&gt;2-&gt;3</span></span><br><span class="line">        left-&gt;next = right;</span><br><span class="line">        right-&gt;next = leftTemp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 移动left和right指针</span></span><br><span class="line">        <span class="comment">// 左链表变为：2-&gt;3 右链表变为：4</span></span><br><span class="line">        left = leftTemp;</span><br><span class="line">        right = rightTemp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 使用快慢指针,找出链表的中心节点。</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3-&gt;4-&gt;5,中心节点为3</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">middle</span> = <span class="title">middleNode</span>(<span class="title">head</span>);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 将原始链表按照中心链表分割为两个链表，并将右链表反转</span></span><br><span class="line">    <span class="comment">// 2.1 原始链表：1-&gt;2-&gt;3-&gt;4-&gt;5 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">left</span> = <span class="title">head</span>, *<span class="title">right</span> = <span class="title">middle</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    middle-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 反转右链表</span></span><br><span class="line">    <span class="comment">//原始右链表：4-&gt;5 反转后：5-&gt;4</span></span><br><span class="line">    right = reverseList(right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 合并两个链表，将右链表插入到左链表</span></span><br><span class="line">    <span class="comment">// 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5 合并后：1-&gt;5-&gt;2-&gt;4-&gt;3</span></span><br><span class="line">    mergeList(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reorder-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;143. Reorder List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>链表的中间结点</title>
    <link href="http://0202zc.github.io/2020/02/29/algorithm-middle-of-the-linked-list/"/>
    <id>http://0202zc.github.io/2020/02/29/algorithm-middle-of-the-linked-list/</id>
    <published>2020-02-29T01:56:03.000Z</published>
    <updated>2020-02-29T03:08:32.007Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">876. Middle of the Linked List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong><code>[1,2,3,4,5]</code><br><strong>输出：</strong>此列表中的结点 <code>3</code> (序列化形式：[3,4,5])<br>返回的结点值为 <code>3</code> 。 (测评系统对该结点序列化表述是 [3,4,5])。<br>注意，我们返回了一个 <code>ListNode</code> 类型的对象 <code>ans</code>，这样：<br><code>ans.val = 3</code>, <code>ans.next.val = 4</code>, <code>ans.next.next.val = 5</code>, 以及 <code>ans.next.next.next = NULL</code>.</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong><code>[1,2,3,4,5,6]</code><br><strong>输出：</strong>此列表中的结点 <code>4</code> (序列化形式：[4,5,6])<br>由于该列表有两个中间结点，值分别为 <code>3</code> 和 <code>4</code>，我们返回第二个结点。</p></blockquote><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>先求出链表的长度 <code>length</code>，再进行计数遍历，遍历到 <code>length / 2</code> 为止，返回该结点。</p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">LinkLength</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(head != <span class="literal">NULL</span>)&#123;</span><br><span class="line">         head = head-&gt;next;</span><br><span class="line">         len++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> len;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">int</span> len = LinkLength(head);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>设置<strong>快慢指针</strong> <code>fast</code>，<code>slow</code>。其中 <code>fast</code> 的步长为 $2$，<code>slow</code> 的步长为 $1$，那么在相同时间的前提下 <code>fast</code> 走过的链表长度就是 <code>slow</code> 走过长度的<strong>两倍</strong>。当 <code>fast</code> 抵达链表末尾时，<code>slow</code> 恰好指向链表的中间结点，此时 <code>return slow</code>。</p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;876. Middle of the Linked List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="http://0202zc.github.io/2020/02/16/algorithm-remove-nth-node-from-end-of-list/"/>
    <id>http://0202zc.github.io/2020/02/16/algorithm-remove-nth-node-from-end-of-list/</id>
    <published>2020-02-16T04:28:04.000Z</published>
    <updated>2020-02-16T06:45:57.183Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个链表，删除链表的倒数第 $n$ 个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><blockquote><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong>n = 2</strong>.</p></blockquote><blockquote><p>当删除了倒数第二个节点后，链表变为 <strong>1-&gt;2-&gt;3-&gt;5</strong>.<br>说明：</p></blockquote><p>给定的 $n$ 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>快慢指针，快指针先走n步，然后快慢一起走，直到快指针走到最后，要注意的是可能是要删除第一个节点，这个时候可以直接返回<code>head -&gt; next</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head -&gt; next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast)&#123;</span><br><span class="line">        <span class="keyword">return</span> head -&gt; next;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast -&gt; next)&#123;</span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow -&gt; next = slow -&gt; next -&gt; next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h3><h4 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/" target="_blank" rel="noopener">面试题22. 链表中倒数第k个节点</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p><strong>示例：</strong></p><blockquote><p>给定一个链表: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong>k = 2</strong>.</p></blockquote><blockquote><p>返回链表 <strong>4-&gt;5</strong>.</p></blockquote><h5 id="思路-代码"><a href="#思路-代码" class="headerlink" title="思路 + 代码"></a>思路 + 代码</h5><p>与上面思路相同，使用快慢指针同步移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">getKthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span> = <span class="title">head</span>, *<span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; fast != <span class="literal">NULL</span>; i++)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">面试题06. 从尾到头打印链表</a></h4><h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p></blockquote><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol><li>先得到链表<code>head</code>的长度<code>len</code> –&gt; 用来动态申请数组<code>returnArray</code></li><li>遍历链表，把其中的元素赋值给数组<code>returnArray</code></li><li>数组内部进行逆置</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reversePrint</span><span class="params">(struct ListNode* head, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, i=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">int</span> *returnArray = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        returnArray[i++] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = returnArray[i];</span><br><span class="line">        returnArray[i] = returnArray[len - i - <span class="number">1</span>];</span><br><span class="line">        returnArray[len - i - <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    (*returnSize) = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> returnArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;19. Remove Nth Node From End of List&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>有序循环数组查找值</title>
    <link href="http://0202zc.github.io/2020/02/12/algorithm-ordering-and-circulate/"/>
    <id>http://0202zc.github.io/2020/02/12/algorithm-ordering-and-circulate/</id>
    <published>2020-02-12T06:01:34.000Z</published>
    <updated>2020-02-12T06:40:00.936Z</updated>
    
    <content type="html"><![CDATA[<p>有序循环数组查找<strong>指定值</strong><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个有序循环数组array[]，不知其升序还是降序，也不知其起点在哪里。请编程寻找指定元素。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>先通过中间值和最后一个或者第一个元素比较，找出局部有序范围，再通过<strong>二分查找</strong>局部有序段</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sortArrFindOne</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == target)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; arr[high]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target &amp;&amp; target &lt;= arr[high]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(arr, mid, high, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArrFindOne(arr, low, mid, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[low] &lt;= target &amp;&amp; target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> find(arr, low, mid, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sortArrFindOne(arr, mid, high, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>找局部有序（二分递归查找）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span>  + low;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> find(arr, mid + <span class="number">1</span>, high, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(arr, low, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有序循环数组查找&lt;strong&gt;指定值&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>反转字符串中的单词 III</title>
    <link href="http://0202zc.github.io/2020/02/10/algorithm-reverse-words-in-a-string-iii/"/>
    <id>http://0202zc.github.io/2020/02/10/algorithm-reverse-words-in-a-string-iii/</id>
    <published>2020-02-10T11:08:43.000Z</published>
    <updated>2020-02-10T12:26:24.900Z</updated>
    
    <content type="html"><![CDATA[<p>From LeetCode <a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii" target="_blank" rel="noopener">557. Reverse Words in a String III</a><br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: “Let’s take LeetCode contest”<br>输出: “s’teL ekat edoCteeL tsetnoc”<br><strong>注意：</strong>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h4><p>第一眼看上去是反转字符串，而反转字符串的形式有所不同——并不是整体反转，而是单个单词进行反转，所有单词相对位置不变。<br>(我第一次提交的时候没有注意到，因此有了以下代码)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++)&#123;</span><br><span class="line">    temp = s[i];</span><br><span class="line">    s[i] = s[len-i<span class="number">-1</span>];</span><br><span class="line">    s[len-i<span class="number">-1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此代码是反转整个字符串，与线性表的反转类似【见<a href="https://0202zc.github.io/2020/01/18/algorithm-reverse-linerlist/">就地逆置线性表元素</a>】</p><blockquote><p>输入：”Let’s take LeetCode contest”<br>输出：<font color="#CD5C5C">“tsetnoc edoCteeL ekat s’teL”</font><br>预期：<font color="#008000">“s’teL ekat edoCteeL tsetnoc”</font></p></blockquote><h4 id="正确解题思路"><a href="#正确解题思路" class="headerlink" title="正确解题思路"></a>正确解题思路</h4><ul><li>记录s的长度len</li><li>若s为空或只有一个字符，则直接返回</li><li>否则<ul><li>使用r记录翻转后的字符串，用start指向每一个单词的第一个字母，end指向该单词的最后一个字符（遇到空格或者结束符就停下）</li><li>将start到end之间的字符复制到r中</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>来源：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/solution/cyu-yan-by-kdurant/" target="_blank" rel="noopener">LeetCode - kdurant</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s) + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">1</span> || len == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * r = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);</span><br><span class="line">    <span class="keyword">char</span> *start = s, *end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++, s++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*s == <span class="string">' '</span> || *s == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(end = s - <span class="number">1</span>; end &gt;= start; end--)&#123;</span><br><span class="line">                r[index++] = *end;</span><br><span class="line">            &#125;</span><br><span class="line">            r[index++] = (*s == <span class="string">' '</span>) ? <span class="string">' '</span> : (*s = <span class="string">'\0'</span>);</span><br><span class="line">            start = s + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(n)$, 空间复杂度$O(n)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From LeetCode &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-words-in-a-string-iii&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;557. Reverse Words in a String III&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://0202zc.github.io/2020/02/09/algorithm-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://0202zc.github.io/2020/02/09/algorithm-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2020-02-09T03:10:32.000Z</published>
    <updated>2020-02-09T05:53:24.919Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 3. Longest Substring Without Repeating Characters<br><a id="more"></a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。<br><strong>示例 1:</strong></p><blockquote><p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题主要用到思路是：滑动窗口</p><p>什么是滑动窗口？</p><p>其实就是一个队列,比如例题中的 <code>abcabcbb</code>，进入这个队列（窗口）为 <code>abc</code> 满足题目要求，当再进入 <code>a</code>，队列变成了 <code>abca</code>，这时候不满足要求。所以，我们要移动这个队列！</p><p>如何移动？</p><p>我们只要把队列的左边的元素移出就行了，直到满足题目要求！</p><p>一直维持这样的队列，找出队列出现最长的长度时候，求出解！</p><p>时间复杂度：$O(n)$</p><p><img data-src="https://pic.leetcode-cn.com/d7a5c09ca134fed8250408fb1bbde0032ae4ecc45a1be3133e5c1855bcb2bbe7-1.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/c94cc222f6d272a20c72e9eb23bf664f8967f38bd6c53d0b396c82e2951b27b5-2.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/c10a1b15727ca49bf991690c40eb5db94a9199a81a8162f86a7f0f283ad8198b-3.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/d5aba4bfea1d0b0d6fc31fb6cefd8b2e5489bcf7e1b77b81cc74cea3ec7c5853-4.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/215d944bde59087836aa4f5aad4514177fd1acc9707386413e40678a8406262e-5.jpg" alt=""><br><img data-src="https://pic.leetcode-cn.com/3acbd78605394f8dbf3ce96f25867e73851837224ef65596ad354500b0e3a181-6.jpg" alt=""></p><p><em>图片来源：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-cshi-xian-/" target="_blank" rel="noopener">无重复字符的最长子串 c++实现三种解法 多重循环，hashmap优化，桶优化</a></em></p><h4 id="滑动窗口题目"><a href="#滑动窗口题目" class="headerlink" title="滑动窗口题目"></a>滑动窗口题目</h4><ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank">30. 串联所有单词的子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. 至多包含两个不同字符的最长子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank">239. 滑动窗口最大值</a></li><li><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range/" target="_blank">632. 最小区间</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-subsequence/" target="_blank">727. 最小窗口子序列</a></li></ul><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j, k, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(k = i;k&lt;j;k++)</span><br><span class="line">            <span class="keyword">if</span>(s[k] == s[j]) &#123;</span><br><span class="line">                i = k+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(j - i + <span class="number">1</span> &gt; max)</span><br><span class="line">            max = j - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 3. Longest Substring Without Repeating Characters&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>操作系统、计算机网络、数据库系统概论等相关问题</title>
    <link href="http://0202zc.github.io/2020/02/05/os-network-db-questions/"/>
    <id>http://0202zc.github.io/2020/02/05/os-network-db-questions/</id>
    <published>2020-02-05T02:33:46.000Z</published>
    <updated>2020-02-05T03:32:37.456Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统、计算机网络、数据库系统概论等相关问题<br><a id="more"></a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="1-中断和陷入有什么异同？"><a href="#1-中断和陷入有什么异同？" class="headerlink" title="1. 中断和陷入有什么异同？"></a>1. 中断和陷入有什么异同？</h3><ol><li>外中断时指来自处理机和内存外部的中断,如I/O中断、定时器中断、外部信号中断等。狭义上也叫中断;</li><li>内中断主要指在处理机和内存内部产生的中断,也称陷入,如校验错、页面失效、溢出、除数为零等;</li><li>中断和陷阱的主要区别:<br>  (1) 陷入通常由处理机正在执行的现行指令引起,而中断则是由与现行指令无关的中断源引起的。<br>  (2) 陷阱处理程序提供的服务为当前进程所用,而中断处理程序提供的服务则不是为了当前进程的。<br>  (3) CPU在执行完一条指令之后,下一条指令开始之前响应中断,而在一条指令执行中也可以响应陷阱。</li></ol><h3 id="2-父子进程是否可以并发运行？"><a href="#2-父子进程是否可以并发运行？" class="headerlink" title="2. 父子进程是否可以并发运行？"></a>2. 父子进程是否可以并发运行？</h3><p>可以</p><h3 id="3-在没有程序运行时-CPU在做什么？"><a href="#3-在没有程序运行时-CPU在做什么？" class="headerlink" title="3. 在没有程序运行时, CPU在做什么？"></a>3. 在没有程序运行时, CPU在做什么？</h3><p>只要计算机打开着，CPU一定都在不停处理进程。在Windows系统下至少rundll32.exe这个程序是持续运行的。在linux下kernel也是会持续运行的。运行进程个数为零的时候有没有呢？有，那就是计算机关机的时候。</p><h3 id="4-设备驱动器是否属于操作系统，它的作用是什么？"><a href="#4-设备驱动器是否属于操作系统，它的作用是什么？" class="headerlink" title="4. 设备驱动器是否属于操作系统，它的作用是什么？"></a>4. 设备驱动器是否属于操作系统，它的作用是什么？</h3><p>不是，驱动程序是另外安装的软件，是操作系统控制并且和硬件之间通讯的桥梁（程序）</p><h3 id="5-线程、进程、程序和任务的区别"><a href="#5-线程、进程、程序和任务的区别" class="headerlink" title="5. 线程、进程、程序和任务的区别?"></a>5. 线程、进程、程序和任务的区别?</h3><ol><li>任务是最抽象的， 是一个一般性的术语， 指由软件完成的一个活动。一个任务既可以是一个进程,也可以是一个线程。简而言之,它指的是一系列共同达到某一目的的操  作。例如,读取数据并将数据放入内存中。这个任务可以作为一个进程来实现,也可以作为一个线程（或作为一个中断任务）来实现。   </li><li>进程常常被定义为程序的执行。可以把一个进程看成是一个独立的程序,在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。  </li><li>线程则是某一进程中一路单独运行的程序。也就是说， 线程存在于进程之中。一个进程由一个或多个线程构成， 各线程共享相同的代码和全局数据， 但各有其自己的堆栈。由于堆栈是每个线程一个， 所以局部变量对每一线程来说是私有的。由于所有线程共享同样的代码和全局数据，它们比进程更紧密，比单独的进程间更趋向于相互作用,线程间的相互作用更容易些,因为它们本身就有某些供通信用的共享内存：进程的全局数据进程的全局数据进程的全局数据进程的全局数据</li><li>程序只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体。</li></ol><h3 id="6-处理中断的过程"><a href="#6-处理中断的过程" class="headerlink" title="6. 处理中断的过程"></a>6. 处理中断的过程</h3><p>请求中断→响应中断→关闭中断→保留断点→中断源识别→保护现场→中断服务子程序→恢复现场→中断返回</p><h3 id="7-分页、分段、段页式的特点，为什么要引入？"><a href="#7-分页、分段、段页式的特点，为什么要引入？" class="headerlink" title="7. 分页、分段、段页式的特点，为什么要引入？"></a>7. 分页、分段、段页式的特点，为什么要引入？</h3><p>分页是为了提高内存的利用率，提高计算机性能，且分页通过硬件机制来实现，对用户完全透明。分段是为了方便编程，信息保护和共享、动态增长及动态链接等多方面的需要。段页式是两者的结合。</p><h3 id="8-计算机系统怎样实现存储保护？"><a href="#8-计算机系统怎样实现存储保护？" class="headerlink" title="8. 计算机系统怎样实现存储保护？"></a>8. 计算机系统怎样实现存储保护？</h3><ol><li>防止地址越界（对进程所产生的地址必须加以检查，发生越界时产生中断，由操作系统<br>进行相应处理）</li><li>防止操作越权（对属于自己区域的信息，可读可写：对公共区域中允许共享的信息或获得授权可使用的信息，可读而不可修改；对未授权使用的信息，不可读，不可写）</li></ol><h3 id="9-MMU-是-Memory-Management-Unit-的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。"><a href="#9-MMU-是-Memory-Management-Unit-的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。" class="headerlink" title="9. MMU 是 Memory Management Unit 的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。"></a>9. MMU 是 Memory Management Unit 的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。</h3><h3 id="10-多线程，真的提高了效率吗？"><a href="#10-多线程，真的提高了效率吗？" class="headerlink" title="10. 多线程，真的提高了效率吗？"></a>10. 多线程，真的提高了效率吗？</h3><p>多线程效率，我认为未必会高，而且有时候相反会低。<br>多线程并不是为了提高效率，而是不必等待  可以并行执行多条数据。<br>可以这么想：我们通过 xp 系统复制文件。你可以复制一份文件  这叫是单线呈，但是你要等这个复制完了才能复制另一份文件，而且不能多复制。这样很难受，所以你可以选择多复制文件,这就是多线程。但复制多份文件用的时间未必会比一份一份文件所用时间少。只是它合理利用了时间进行了多个操作。<br>如果是买票系统  就会用到多线呈。买票是同时进行的，如果一个用户一个用户等下去不是办法，所以可以多个用户同时买票，效率也就提高了。这里的效率不是执行的效率  而是时间的合理利用,多个线呈同时进行。</p><h3 id="11-中断的作用"><a href="#11-中断的作用" class="headerlink" title="11. 中断的作用"></a>11. 中断的作用</h3><p>中断是计算机系统结构一个重要的组成部分。在中断机制中的硬件部分(中断装置)<br>的作用就是在 CPU 每执行完一条指令后，判别是否有事件发生，如果没有事件发生，CPU<br>继续执行；若有事件发生，中断装置中断原先占用 CPU 的程序的执行，把被中断程序的断<br>点保存起来，让操作系统的处理服务程序占用 CPU 对事件进行处理，处理完后，再让被中<br>断的程序继续占用 CPU 执行下去。</p><h3 id="12-DMA-的优先级为什么比-CPU-的优先级高？"><a href="#12-DMA-的优先级为什么比-CPU-的优先级高？" class="headerlink" title="12. DMA 的优先级为什么比 CPU 的优先级高？"></a>12. DMA 的优先级为什么比 CPU 的优先级高？</h3><p>因为 DMA 请求得不到及时响应，I/O 传输数据可能会丢失</p><h3 id="13-虚拟内存容量由什么决定？"><a href="#13-虚拟内存容量由什么决定？" class="headerlink" title="13. 虚拟内存容量由什么决定？"></a>13. 虚拟内存容量由什么决定？</h3><p>虚拟存储区的容量与物理主存大小无关，而受限于计算机的地址结构和可用磁盘容量。</p><h3 id="14-RAID-的工作原理"><a href="#14-RAID-的工作原理" class="headerlink" title="14. RAID 的工作原理"></a>14. RAID 的工作原理</h3><p>RAID（独立磁盘冗余阵列（Redundant Array of Independent Disks））通过条带化存储和奇偶校验两个措施来实现其冗余和容错的目标。条带化存储意味着可以一次写入一个数据块的方式将文件写入多个磁盘。条带化存储技术将数据分开写入多个驱动器，从而提高数据传输速率并缩短磁盘处理总时间。这种系统非常适用于交易处理、但可靠性却很差，因为系统的可靠性等于最差的单个驱动器的可靠性。<br>奇偶校验通过在传输后对所有数据进行冗余校验可以确保数据的有效性。<br>利用奇偶校验，当 RAID 系统的一个磁盘发生故障时，其它磁盘能够重建该故障磁盘。在这两种情况中，这些功能对于操作系统都是透明的。由磁盘阵列控制器（DAC）进行条带化存储和奇偶校验控制。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="1-计算机网络和分布式计算机系统的区别"><a href="#1-计算机网络和分布式计算机系统的区别" class="headerlink" title="1. 计算机网络和分布式计算机系统的区别?"></a>1. 计算机网络和分布式计算机系统的区别?</h3><p>两者在计算机硬件连接、系统拓朴结构和通信控制等方面基本都是一样的,它们都具有通信和资源共享的功能。<br>区别关键在于:分布式计算机系统是在分布式计算机操作系统支持下,进行分布式数据库处理的,也就是说各互联的计算机可以互相协调工作,共同完成一项任务,多台计算机上并行运行。且具有透明性,用户不知道数据、资源的具体位置,整个网络中所有计算机就像是一台计算机一样;而计算机网络却不具备这种功能,计算机网络系统中的各计算机通常是各自独立进行工作的。</p><h3 id="2-波特和比特的区别"><a href="#2-波特和比特的区别" class="headerlink" title="2. 波特和比特的区别?"></a>2. 波特和比特的区别?</h3><p>波特是码元传输的踵率单位,说明每秒传多少个码元。码元传输速率也称为调制速率、波形速率或符号速率。<br>比恃是信息量的单位,与码元的传输速率”波特”是两个完全不同的概念。<br>但是,信息的传输速率”比特/秒”与码元的传输速率”波特”在数量上却有一定的关系。</p><h3 id="3-TCP-IP网络协议核心以及如何引出overeverything"><a href="#3-TCP-IP网络协议核心以及如何引出overeverything" class="headerlink" title="3. TCP/IP网络协议核心以及如何引出overeverything"></a>3. TCP/IP网络协议核心以及如何引出overeverything</h3><p>TCP/IP（传输控制协议/网间协议）是一种网络通信协议，它规范了网络上的所有通信设备，尤其是一个主机与另一个主机之间的数据往来格式以及传送方式。TCP/IP是INTERNET的基础协议，也是一种电脑数据打包和寻址的标准方法。<br>核心是OSI模型，共七层，第7层应用层，第6层表示层，第5层会话层，第4层传输层，第3层网络层，第2层数据链路层，第1层物理层，从第七层传到第一层，接受方则相反。 上三层总称应用层，用来控制软件方面。 下四层总称数据流层，用来管理硬件。<br>everything over IP：everything均以IP为基础，以后的网络中的设备都用IP（现在的电话网络就不是）。over：以…为基础。<br>IP over everything：在现在的电通信网过渡到光通信网的过程中，IP、ATM、WDM会配合使用，渐渐过渡，既是IP over everything。over：凌驾于…之上。</p><h3 id="4-电路交换与分组交换区别"><a href="#4-电路交换与分组交换区别" class="headerlink" title="4. 电路交换与分组交换区别"></a>4. 电路交换与分组交换区别</h3><ol><li><p>电路交换是以电路为目的的交换方式，即通信双方要通过电路建立联系，建立后没挂断则电路一直保持，实时性高。</p><p>而分组交换是把信息分为若干分组，每个分组有分组头含有选路和控制信息，可以到达收信方，但是不能即时通信。</p></li><li><p>分组交换通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。</p><p>电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。</p></li><li><p>分组交换由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。</p><p>电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用低。</p><p>若要传送的数据量很大，且其传送时间远大于呼叫时间，<br>则采用电路交换较为合适；<br>当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。<br>从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，<br>其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。</p></li></ol><h3 id="5-IPV4-和-IPV6-的区别"><a href="#5-IPV4-和-IPV6-的区别" class="headerlink" title="5. IPV4 和 IPV6 的区别"></a>5. IPV4 和 IPV6 的区别</h3><p>（1）IPV6 地址长度为 128 比特，地址增大了 296 倍；<br>（2）灵活的 IP 报文头部格式。使用一系列固定格式的扩展头部取代了 IPV4 中可变长度的选项字段。IPV6 中选项部分的出现方式也有所变化，使路由器可以简单路过选项而不做任何处理，加快了报文处理速度。<br>（3）IPV6 简化了报文头部格式，字段只有 7 个，加快报文转发，提高了吞吐量；<br>（4）提高安全性。身份认证和隐私权是 IPV6 的关键特性。<br>（5）支持更多的服务类型；<br>（6）允许协议继续演变，增加新的功能，使之适应未来技术的发展。</p><h3 id="6-TCP-的拥塞控制与流量控制的功能和区别？"><a href="#6-TCP-的拥塞控制与流量控制的功能和区别？" class="headerlink" title="6. TCP 的拥塞控制与流量控制的功能和区别？"></a>6. TCP 的拥塞控制与流量控制的功能和区别？</h3><p>1拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。<br>2流量控制：指点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收.</p><h3 id="7-集线器-路由器和交换机有什么区别"><a href="#7-集线器-路由器和交换机有什么区别" class="headerlink" title="7. 集线器,路由器和交换机有什么区别."></a>7. 集线器,路由器和交换机有什么区别.</h3><p><strong>集线器</strong>工作在第一层（即物理层），它没有智能处理能力，对它来说，数据只是电流而已，<br>当一个端口的电流传到集线器中时，它只是简单地将电流传送到其他端口，至于其他端口连接的计算机接收不接收这些数据，它就不管了。<br><strong>交换机</strong>工作在第二层（即数据链路层），它要比集线器智能一些，对它来说，网络上的数据就是 MAC 地址的集合，它能分辨出帧中的源 MAC 地址和目的 MAC 地址，因此可以在任意两个端口间建立联系，但是交换机并不懂得 IP 地址，它只知道 MAC 地址。<br><strong>路由器</strong>工作在第三层（即网络层），它比交换机还要“聪明”一些，它能理解数据中的 IP 地址，如果它接收到一个数据包，就检查其中的 IP地址，如果目标地址是本地网络的就不理会，如果是其他网络的，就将数据包转发出本地网络。</p><h3 id="8-P2P-网络编程的特点"><a href="#8-P2P-网络编程的特点" class="headerlink" title="8. P2P 网络编程的特点"></a>8. P2P 网络编程的特点</h3><p>P2P（对等网络，是一种有别于传统 C/S 客户/服务器式的分布式网络）直接将人们联系起来，让人们通过互联网直接交互。P2P 使得网络上的沟通变得容易、更直接共享和交互，真正地消除中间商。P2P 就是人可以直接连接到其他用户的计算机、交换文件，而不是像过去那样连接到服务器去浏览与下载。</p><h3 id="9-DNS-的递归查询与迭代查询"><a href="#9-DNS-的递归查询与迭代查询" class="headerlink" title="9. DNS 的递归查询与迭代查询"></a>9. DNS 的递归查询与迭代查询</h3><ol><li>递归查询:<br>  一般客户机和服务器之间属递归查询，即当客户机向 DNS 服务器发出请求后,若 DNS 服务<br>  器本身不能解析,则会向另外的 DNS 服务器发出查询请求，得到结果后转交给客户机； </li><li>迭代查询(反复查询):<br>  一般 DNS 服务器之间属迭代查询，如：若 DNS2 不能响应 DNS1 的请求，则它会将 DNS3<br>  的 IP 给 DNS2，以便其再向 DNS3 发出请求；</li></ol><h3 id="10-ARP-协议的过程"><a href="#10-ARP-协议的过程" class="headerlink" title="10. ARP 协议的过程"></a>10. ARP 协议的过程</h3><p>ARP 协议是“Address Resolution Protocol”（地址解析协议）的缩写。在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的 MAC 地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的 MAC 地址。但这个目标 MAC 地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标 IP 地址转换成目标 MAC 地址的过程。 ARP 协议的基本功能就是通过目标设备的 IP 地址，查询目标设备的 MAC 地址，以保证通信的顺利进行。</p><h3 id="11-计算机网络的接入类型都有哪些？"><a href="#11-计算机网络的接入类型都有哪些？" class="headerlink" title="11. 计算机网络的接入类型都有哪些？"></a>11. 计算机网络的接入类型都有哪些？</h3><p>局域网、城域网、广域网和互联网四种</p><h3 id="12-中继器，集线器，交换机，网桥，网关，路由器的功能作用-区别到底是什么？"><a href="#12-中继器，集线器，交换机，网桥，网关，路由器的功能作用-区别到底是什么？" class="headerlink" title="12. 中继器，集线器，交换机，网桥，网关，路由器的功能作用,区别到底是什么？"></a>12. 中继器，集线器，交换机，网桥，网关，路由器的功能作用,区别到底是什么？</h3><p>中继器： 物理层， 适用于完全相同的两类网络的互连，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。<br>集线器：物理层，基本功能信息分发，它把一个端口接收的所有信号向所有端口分发出去。<br>一些集线器在分发之前将弱信号重新生成。<br>中继器与集线器的区别：区别在于集线器能够提供多端口服务，也称为多口中继器。<br>网桥：数据链路层， 网桥（Bridge）像一个聪明的中继器， 网桥是一种对帧进行转发的技术，根据 MAC 分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来。</p><h2 id="数据库系统概论"><a href="#数据库系统概论" class="headerlink" title="数据库系统概论"></a>数据库系统概论</h2><h3 id="1-数据库安全性与操作系统安全性的关系"><a href="#1-数据库安全性与操作系统安全性的关系" class="headerlink" title="1. 数据库安全性与操作系统安全性的关系?"></a>1. 数据库安全性与操作系统安全性的关系?</h3><p>安全性问题不是数据库系统所独有的,所有计算机系统都有这个问题.只是在数据库系统中<br>大量数据集中存放,而且为许多最终用户直接共享,从而使安全性问题更为突出.系统安全保<br>护措施是否有效是数据库系统的主要指标之一.数据库的安全性和计算机系统的安全性,包<br>括操作系统,网络系统的安全性是紧密联系,相互支持的</p><h3 id="2-SQL-主键约束和唯一约束有什么区别呢？"><a href="#2-SQL-主键约束和唯一约束有什么区别呢？" class="headerlink" title="2. SQL 主键约束和唯一约束有什么区别呢？"></a>2. SQL 主键约束和唯一约束有什么区别呢？</h3><p>主键不能为空而唯一可以为空相同的就是都不允许重复</p><h3 id="3-什么是基本表？什么是视图？两者的区别和联系是什么？"><a href="#3-什么是基本表？什么是视图？两者的区别和联系是什么？" class="headerlink" title="3. 什么是基本表？什么是视图？两者的区别和联系是什么？"></a>3. 什么是基本表？什么是视图？两者的区别和联系是什么？</h3><p>表是实实在在得保存数据的实体,写入的数据都保存在表中,而视图  是不保存数据的,也没有数据.视图就是一条  语句,实际上视图从表中去数据.只是给我们的感觉好像直接从表中  取得一样.  表可以建立各种触发器,可以建立索引,可以建立主健,约束等.  但是视图不能建立这些对象( 视图可以建立替代触发器)  .  表和视图可以更新, 但是视图的更新受到约束.  比如,group  by  和表连接生成的视图不能更新表是实实在在得  保存数据的实体,  写入的数据都保存在表中,  而视图是不保存数据的,  也没有数据.</p><h3 id="4-数据库索引"><a href="#4-数据库索引" class="headerlink" title="4. 数据库索引"></a>4. 数据库索引</h3><p>目的：提供多种存储路径，加快查找速度。<br>建立索引需要考虑的问题： 1.没有查询、统计的需要则不建 2.数据增删改频繁，系统会花费许多时间来维护索引，从而降低了查询效率。</p><h3 id="5-哪些视图是可以更新、哪些是不可以更新的"><a href="#5-哪些视图是可以更新、哪些是不可以更新的" class="headerlink" title="5. 哪些视图是可以更新、哪些是不可以更新的"></a>5. 哪些视图是可以更新、哪些是不可以更新的</h3><ol><li>简单视图<br>就是由一个表生成出来的视图，这种情况你更新她就和更新表一样。</li><li>二次加工出来的简单视图<br>仍然是一个表出来的视图，但是视图中存在通过函数或计算二次加工出来的其他字段。更新的时候只要不更新这些加工出来的字段也是可以更新的。</li><li>组合视图<br>通过表之间关联联合等出来的复杂视图。这种视图更新的时候要注意你所更新的列要来自同一个表，也是可以更新的。</li><li>静态视图<br>这种视图等同于表可以直接更新，但是更新的数据尽在视图中反映出来，不反映到原表。</li><li>其他视图<br>通过表函数等其他生成的更为复杂的视图。一般不可更新。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统、计算机网络、数据库系统概论等相关问题&lt;br&gt;
    
    </summary>
    
      <category term="计算机操作系统" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="计算机网络" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="数据库" scheme="http://0202zc.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="操作系统" scheme="http://0202zc.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="OS" scheme="http://0202zc.github.io/tags/OS/"/>
    
      <category term="计算机网络" scheme="http://0202zc.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="数据库" scheme="http://0202zc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>复试英语口语</title>
    <link href="http://0202zc.github.io/2020/02/02/English-speaking-test/"/>
    <id>http://0202zc.github.io/2020/02/02/English-speaking-test/</id>
    <published>2020-02-02T10:03:15.000Z</published>
    <updated>2020-02-02T10:49:37.811Z</updated>
    
    <content type="html"><![CDATA[<p>~2020.02.02~<br><a id="more"></a></p><h4 id="1-self-introduction-自我介绍"><a href="#1-self-introduction-自我介绍" class="headerlink" title="(1). self-introduction (自我介绍)"></a>(1). self-introduction (自我介绍)</h4><p>Good morning, my dear teachers and professors. I am very happy to introduce myself. I am 陈琪, a 22-year-old boy graduated from <u>Chongqing University of Posts and Telecommunications</u>. My major was <u>Computer Science and Technology</u>. And I am very kind-hearted as well and ready to help others especially when they are in troubles. Owing to my kindness I made a lot of friends in university. In my spare time I like sports such as Ping-pong .I also took some part-time jobs as a family tutor. One of my students got his mark improved through our joint effort and I was very proud of that.This is all for my self-introduction. If I am lucky enough to get the chance, I will devote all myself to my major and focus all of my energy on it.</p><h4 id="2-reasons-for-my-choice-考研原因"><a href="#2-reasons-for-my-choice-考研原因" class="headerlink" title="(2). reasons for my choice (考研原因)"></a>(2). reasons for my choice (考研原因)</h4><p>Firstly, I think my major is very <strong>practical and useful</strong>. Through four years’study in university I find the knowledge I have <strong>mastered</strong> is not enough to <strong>solve some specific problems</strong>. So I decide to further my education.<br>Secondly,I can broaden my horizon and enrich the knowledge in this field through the postgraduate education. It is an indispensable step for my self-development in the future as well. </p><h4 id="3-plans-in-the-postgraduate-study-研究生期间你的计划"><a href="#3-plans-in-the-postgraduate-study-研究生期间你的计划" class="headerlink" title="(3). plans in the postgraduate study (研究生期间你的计划)"></a>(3). plans in the postgraduate study (研究生期间你的计划)</h4><p>Because my dream is to be a scientist , so i want to further my study when i become postgraduate. May be i will be a teacher in the university  at first.That’s my simple plan.</p><h4 id="4-about-hometown-介绍你的家乡"><a href="#4-about-hometown-介绍你的家乡" class="headerlink" title="(4). about hometown (介绍你的家乡)"></a>(4). about hometown (介绍你的家乡)</h4><p>I come from ZiGong of Sichuan province,which is famous for its salt industry and dinosaur fossils.<br>Known as home of dinosaur. What’s more? It is also a city of lights. Every year,there are a lot of tourist traveling here.</p><h4 id="5-about-family-你的家庭"><a href="#5-about-family-你的家庭" class="headerlink" title="(5). about family (你的家庭)"></a>(5). about family (你的家庭)</h4><p>I have a happy family .In my family, there are five members: grandfather, father, mother.My family is just like a hand, and each of us like a finger.<br>Mother worker, Father teacher. They love me ,we live harmoniously.</p><h4 id="6-about-university-你的大学"><a href="#6-about-university-你的大学" class="headerlink" title="(6). about university (你的大学)"></a>(6). about university (你的大学)</h4><p>My university is Chongqing university of Post and Telecommunication .it has digital libraries and labs. My university is famous for its 3G research and it is located in a small mountain which is beautiful and full of cherry blossom.There a fresh airs and warm atmosphere.</p><h4 id="7-plans-after-graduation-毕业后有什么打算"><a href="#7-plans-after-graduation-毕业后有什么打算" class="headerlink" title="(7). plans after graduation (毕业后有什么打算)"></a>(7). plans after graduation (毕业后有什么打算)</h4><p>After my graduation, I want to find a job in Chengdu and make good use of the theories I will have learned from this university.I want to become a teacher of university or a scientist .if possible ,After graduation, I want to further my study for a Doctor’s degree. Then I’ll work for a research institute. What satisfies me most is to make contributions for the whole earth.</p><h4 id="8-What-is-your-greatest-strength-你最突出的优点是什么？"><a href="#8-What-is-your-greatest-strength-你最突出的优点是什么？" class="headerlink" title="(8).What is your greatest strength? (你最突出的优点是什么？)"></a>(8).What is your greatest strength? (你最突出的优点是什么？)</h4><p>I am good at math and programming, because i can solve a problem by myself independent and improve in a short time without others’ help.</p><h4 id="要求重复询问"><a href="#要求重复询问" class="headerlink" title="要求重复询问"></a>要求重复询问</h4><p>Sorry, I did not catch/follow your meaning. Pardon, please.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;~2020.02.02~&lt;br&gt;
    
    </summary>
    
      <category term="English" scheme="http://0202zc.github.io/categories/English/"/>
    
    
      <category term="English" scheme="http://0202zc.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>C语言中变量存储位置</title>
    <link href="http://0202zc.github.io/2020/02/01/C-variable-storage-2/"/>
    <id>http://0202zc.github.io/2020/02/01/C-variable-storage-2/</id>
    <published>2020-02-01T06:28:06.000Z</published>
    <updated>2020-02-01T06:44:12.011Z</updated>
    
    <content type="html"><![CDATA[<p>局部变量、静态局部变量、静态全局变量…<br><a id="more"></a></p><h3 id="一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？"><a href="#一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？" class="headerlink" title="一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？"></a>一、C语言中，常量存储在哪儿？<code>static</code>全局变量和<code>static</code>局部变量存储在哪儿？</h3><p>全局变量（外部变量）的说明之前再冠以<code>static</code>就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于</p><blockquote><p><strong>非静态全局变量的作用域是整个源程序，</strong><br><strong>当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的，</strong><br><strong>而静态全局变量则限制了其作用域。</strong><br><strong>即只在定义该变量的源文件内有效，</strong></p></blockquote><p>在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</p><h3 id="二、static全局变量与普通的全局变量有什么区别？"><a href="#二、static全局变量与普通的全局变量有什么区别？" class="headerlink" title="二、static全局变量与普通的全局变量有什么区别？"></a>二、<code>static</code>全局变量与普通的全局变量有什么区别？</h3><ul><li><strong><code>static</code>全局变量只初始化一次</strong>，防止在其他文件单元中被是引用。</li></ul><h3 id="三、static局部变量与普通的局部变量有什么区别？"><a href="#三、static局部变量与普通的局部变量有什么区别？" class="headerlink" title="三、static局部变量与普通的局部变量有什么区别？"></a>三、<code>static</code>局部变量与普通的局部变量有什么区别？</h3><ul><li><strong><code>static</code>局部变量只被初始化一次</strong>，下一次依据上一次结果值。</li></ul><h3 id="四、局部变量、静态局部变量、静态全局变量存储位置"><a href="#四、局部变量、静态局部变量、静态全局变量存储位置" class="headerlink" title="四、局部变量、静态局部变量、静态全局变量存储位置"></a>四、局部变量、静态局部变量、静态全局变量存储位置</h3><table><thead><tr><th>变量类型</th><th>存储位置</th></tr></thead><tbody><tr><td>局部变量</td><td>静态区（全局区）</td></tr><tr><td>局部静态变量</td><td>静态区（全局区）的常量区</td></tr><tr><td>全局静态变量</td><td>静态区（全局区）</td></tr></tbody></table><h3 id="五、各存储区的定义"><a href="#五、各存储区的定义" class="headerlink" title="五、各存储区的定义"></a>五、各存储区的定义</h3><ol><li><p><strong>栈区（stack）</strong> —— 由编译器自动分配释放，存放<u>函数的参数值，局部变量的值</u>等，其操作方式类似于数据结构中的栈。</p></li><li><p><strong>堆区（heap）</strong> —— 一般由程序员分配释放。若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p></li><li><p><strong>全局区（静态区）（static）</strong> —— <u>全局变零和静态变量</u>的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，- <em>程序结束后由系统释放</em>。</p></li><li><p><strong>文字常量区</strong> —— <u>常量字符串</u>就是放在这里的。- <em>程序结束后由系统释放</em>。</p></li><li><p><strong>程序代码区</strong> —— <u>存放函数体的二进制代码</u>。</p></li></ol><h3 id="六、NOTES"><a href="#六、NOTES" class="headerlink" title="六、NOTES"></a>六、NOTES</h3><ol><li><p><strong>栈</strong>，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。</p></li><li><p><strong>堆</strong>，就是那些由<code>new</code>分配的内存块，他们的释放编译器不去管，由应用程序控制，一般一个<code>new</code>就要对应一个<code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p></li><li><p><strong>自由存储区</strong>，就是那些由<code>malloc</code>分配的内存块，它和堆十分相似，不过它是用<code>free</code>来结束自己的生命。</p></li><li><p><strong>全局/静态存储区</strong>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，<em>在C++里面没有这个区分</em>，它们共同占用一块内存区。</p></li><li><p><strong>常量存储区</strong>，这是一块比较特殊的存储区，它们存放的是常量，<strong>不允许被修改</strong>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;局部变量、静态局部变量、静态全局变量…&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C语言效率问题</title>
    <link href="http://0202zc.github.io/2020/01/31/C-efficiency/"/>
    <id>http://0202zc.github.io/2020/01/31/C-efficiency/</id>
    <published>2020-01-31T15:13:35.000Z</published>
    <updated>2020-01-31T15:14:27.489Z</updated>
    
    <content type="html"><![CDATA[<p>来源：UESTC考研群<br><a id="more"></a></p><ul><li><p>编译器可以将代码编译为汇编语言，然后转换为机器语言，并且编译器可以在编译时进行优化，例如gcc可以进行五级优化</p></li><li><p>采用宏去定义一些函数，提高效率 比如#define MAX(x,y) ((x)&gt;(y)?(x):(y))</p></li><li><p>可以使用位操作来替代乘法除法 比如计算机网络中进行CRC检验</p></li><li><p>可以在程序效率低的地方嵌入汇编语言提高程序效率</p></li><li><p>可以使用指针直接操作内存，提高效率</p></li><li><p>可以使用内联函数（C99标准添加，之前宏定义）</p></li><li><p>可以使用寄存器变量（register），提高变量存取速度</p></li><li><p>复合的赋值运算符的使用，比如i-=1效率大于i=i-1，可以提高程序的编译效率</p></li><li><p>自增自减运算符的使用，比如i++和i–</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：UESTC考研群&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>指针与自增优先级的问题</title>
    <link href="http://0202zc.github.io/2020/01/29/C-pointer-and-increase/"/>
    <id>http://0202zc.github.io/2020/01/29/C-pointer-and-increase/</id>
    <published>2020-01-29T09:54:17.000Z</published>
    <updated>2020-01-29T10:04:00.283Z</updated>
    
    <content type="html"><![CDATA[<p>在我们面试时，经常会有一些关于运算符优先级的题目，今天就给大家展示一个常出现的例子。<br><a id="more"></a><br>问题：定义一个数组 <code>int a[10]={1,2,3,4,5,6,7,8,9,0}; int *p=a;</code> 则 <code>cout&lt;&lt;*p++&lt;&lt;endl;</code> </p><p>由此问题我们可以看出来，其想考察的是C++程序设计的运算符的优先级以及后自增的知识点。我们查看优先级表格表格可以得到后自增（<code>++</code>）运算符优先于取值运算符（<code>*</code>），因此<code>（*p++）</code>等价于<code>(*(p++))</code>。</p><p>求值顺序得到了，我们下面的任务就是要分析后自增的实现原理了，我们参考了《C++ primer 第五版》（503页）讲解的知识如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">strBlobPtr strBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">strBlobPtr为定义的一个类名，operator++（int）为重载后自增运算符，参数int为区分前自增还是后自增</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       strBlobPtr ret =*<span class="keyword">this</span>;</span><br><span class="line">       ++*<span class="keyword">this</span>;</span><br><span class="line">       <span class="keyword">return</span> ret;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，在后自增的运算符实现的步骤中，先返回值，再自增，因此（<code>*p++</code>）计算过程为先运算<code>p++</code>（结果为<code>p</code>指向的地址<code>a</code>）,再对指针求值<code>*p</code>,得到<code>a[0]</code>.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p=a;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*p:"</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*p++:"</span> &lt;&lt; *p++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们面试时，经常会有一些关于运算符优先级的题目，今天就给大家展示一个常出现的例子。&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C语言中变量存储类型和生存周期</title>
    <link href="http://0202zc.github.io/2020/01/28/C-variable-storage/"/>
    <id>http://0202zc.github.io/2020/01/28/C-variable-storage/</id>
    <published>2020-01-28T01:55:14.000Z</published>
    <updated>2020-01-28T03:33:46.819Z</updated>
    
    <content type="html"><![CDATA[<p>内容来自谭浩强的《C语言程序设计》总结<br><a id="more"></a></p><blockquote><p>原文链接：<a href="https://blog.csdn.net/wuyuzun/article/details/82432355" target="_blank" rel="noopener">https://blog.csdn.net/wuyuzun/article/details/82432355</a></p></blockquote><h3 id="几个重要概念"><a href="#几个重要概念" class="headerlink" title="几个重要概念"></a>几个重要概念</h3><ol><li><p>数据类型：浮点型，整型，字符型等都是一个数据类型；</p></li><li><p>数据存储类型：数据在内存中的存储方式；（这是本博文要讨论的重点）<br>注意：数据类型和数据存储类型都是针对于声明或定义的函数和变量而言的；</p></li><li><p>动态存储类型：变量或函数，在被使用时临时分配内存单元，在函数结束后所占用的内存单元将会被释放，例如局部变量；因此，动态存储的变量每次被调用时所占的内存单元的地址可能会发生改变；</p></li><li><p>静态存储类型：变量或函数，在程序运行期间编译器统一分配内存单元，直到程序结束分配的内存才被释放；例如：全局变量；</p></li></ol><h3 id="内存中供用户使用的存储空间"><a href="#内存中供用户使用的存储空间" class="headerlink" title="内存中供用户使用的存储空间"></a>内存中供用户使用的存储空间</h3><table><thead><tr><th>用户区</th><th>存储内容</th></tr></thead><tbody><tr><td>程序区</td><td>CPU指令</td></tr><tr><td>静态存储区</td><td>全部的全局变量，局部静态变量</td></tr><tr><td>动态存储区</td><td>被调用函数的形参；被调用函数中非局部静态变量；函数调用时的现场保护和返回地址等</td></tr></tbody></table><p><strong>注：</strong></p><ol><li>在平时编程过程中，一般对变量和函数的声明和定义都应同时指定数据类型和数据存储类型；如果我们没有对变量进行指定数据存储类型；</li><li>在定义全局变量和局部静态变量时，如果没有赋初始值，系统会默认为0；而动态变量们竟会被随机赋值；</li></ol><h3 id="局部变量的存储类型"><a href="#局部变量的存储类型" class="headerlink" title="局部变量的存储类型"></a>局部变量的存储类型</h3><h4 id="1-自动变量—auto"><a href="#1-自动变量—auto" class="headerlink" title="1. 自动变量—auto"></a>1. <strong>自动变量—auto</strong></h4><p>定义：函数中，包括复合语句内和形式参数在内的变量中，不被<code>static</code>限制的变量；</p><p>性质：动态存储类型，系统调用函数时临时分配内存单元；函数执行结束就占用的内存释放；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fun1(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span>  <span class="comment">//形式参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> b = <span class="number">0</span>;    <span class="comment">//函数内不被static限制,且函数每次被调用，b的值都会被赋0；</span></span><br><span class="line">    b++;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c;  <span class="comment">//函数内复合语句内；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img data-src="https://img-blog.csdn.net/20180906000827834?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eXV6dW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><p>注：大多数情况下，自动变量是可以直接省略<code>auto</code>的，系统也会默认为自动变量；</p><h4 id="2-静态局部变量—static"><a href="#2-静态局部变量—static" class="headerlink" title="2. 静态局部变量—static"></a>2. <strong>静态局部变量—static</strong></h4><p>定义：函数内被静态<code>static</code>限制的局部变量；静态局部变量在函数执行结束时，内存不被释放，函数下次被执行的时候，此变量的值并不改变；</p><p>性质：静态存储类型，函数每次被调用其值还是上次函数执行时的值，且默认的初始化的值是$0$；</p><p>举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fun1(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b=a;   <span class="comment">//第一次执行函数后被b被赋初值，</span></span><br><span class="line">                      <span class="comment">//以后再执行函数后b将不会再被赋值；</span></span><br><span class="line">    b--;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><img data-src="https://img-blog.csdn.net/20180906000326874?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d1eXV6dW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><h4 id="3-寄存器变量—register变量"><a href="#3-寄存器变量—register变量" class="headerlink" title="3. 寄存器变量—register变量"></a>3. <strong>寄存器变量—register变量</strong></h4><p>定义：存放在CPU寄存器中的变量；（寄存器存储类型也是随着函数的结束，内存被释放）</p><p>形式：<code>register int a = 1;</code> \将定义的a送到寄存器中；</p><p>说明：寄存器这个名词如果是学过单片机的同志肯定是知道的，对于单片机功能的实现，基本上都是靠配置寄存器实现的；寄存器是什么，参考<a href="https://blog.csdn.net/wuyuzun/article/details/74171359" target="_blank" rel="noopener">《存储器》</a>；</p><p>性质：CPU能够快速读写寄存器变量；</p><p>优点：一般来说，程序中定义，<strong>声明的变量是放在内存中的</strong>，例如全局变量存储在静态存储器中，对一个全局变量的每次读写操作都是CPU和内存之间的传输；但是寄存器变量是把变量存储在CPU的寄存器中，由于寄存器的读写传输速度很快，所以非常适合处理一些程序中被高频使用的变量；</p><p>缺点：CPU寄存器数量有限，不适合定义太多寄存器变量；</p><p><strong>注意：</strong><br>目前计算器处理速度越来越快，加上C语言IDE对于代码的优化越来越好，所以有时即使我们不去定义或声明一个寄存器变量，IDE也会把高频使用的变量默认声明为寄存器变量；所以在平时的编程时，并不用过于强调寄存器变量。</p><h3 id="全局变量的存储类型"><a href="#全局变量的存储类型" class="headerlink" title="全局变量的存储类型"></a>全局变量的存储类型</h3><p>外部变量：定义在函数外的变量，也可以说就是全局变量；</p><p>全局变量的有效域：自定义处起以下范围；</p><p>举例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>    <span class="comment">//全局变量a不被main()函数调用；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;    <span class="comment">//全局变量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span>   <span class="comment">//全局变量a可以被fun1()调用；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="1-同文件内扩展外部变量的作用域-—-extern"><a href="#1-同文件内扩展外部变量的作用域-—-extern" class="headerlink" title="1. 同文件内扩展外部变量的作用域 — extern"></a>1. <strong>同文件内扩展外部变量的作用域 — <code>extern</code></strong></h4><p><strong>举例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;   </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span>    <span class="comment">//全局变量a不被main()函数调用；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;    <span class="comment">//全局变量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span>   <span class="comment">//全局变量a可以被fun1()调用；</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在第二行语句以下的函数都可以调用变量<code>a</code>；外部变量声明也可以写成：“<code>extern a</code>”这种形式，因为<code>a</code>已经是已经定义过的变量；<br>注意：<code>extern</code>并不是定义变量，而是声明变量，这个关键字就是为了告诉编译器：本文件中已经定义这个变量；</p><h4 id="2-将外部变量的作用域扩展到其他文件–extern"><a href="#2-将外部变量的作用域扩展到其他文件–extern" class="headerlink" title="2. 将外部变量的作用域扩展到其他文件–extern"></a>2. <strong>将外部变量的作用域扩展到其他文件–extern</strong></h4><p><strong>怎样扩展</strong>：一个大的程序往往是由许多源文件和头文件组成，当不同文件要引用同一个外部变量时，方法是：在任意一个文件中定义外部变量，而在另一个文件中用<code>extern</code>对其进行“外部变量声明”；这样，在编译连接时编译器好知道这个变量来自于其他位置；如果说两个文件同时用了定义了相同名字的外部变量，那编译器连接时会报错；</p><p><strong>扩展的方式</strong>：当程序进行编译的时候，编译器遇到<code>extern</code>所声明的变量后，编译器会现在本文件中寻找此变量，如果找到了，就在此处扩展有效域，如果找不到，会进入其他文件进行寻找，找到后将有效域扩展其他文件，如果还找不到就按错误处理；</p><h4 id="3-静态外部（全局）变量–static"><a href="#3-静态外部（全局）变量–static" class="headerlink" title="3. 静态外部（全局）变量–static"></a>3. <strong>静态外部（全局）变量–static</strong></h4><p>定义：定义在函数外部的静态变量；</p><p>优点：被<code>static</code>限制的外部变量，编译时不会被其他文件发现，即使不同文件之间有同名的现象也没关系；如果确定一个外部变量不被其他文件引用，就可以直接加static，这一点很符合C语言模块化的思想，也提高了程序的可移植性；</p><p><strong>举例：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;  <span class="comment">//静态全局变量，只能在本文件中被调用；如果在其他文件被调用将会报错；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以：对于<code>static</code>来说，静态<strong>局部</strong>变量说明的是此变量的<strong>生存期</strong>；静态<strong>外部</strong>变量说明的是此变量的<strong>作用域</strong>；</p><h4 id="三个概念："><a href="#三个概念：" class="headerlink" title="三个概念："></a><strong>三个概念：</strong></h4><p><strong>生存期</strong>：一个变量值在<strong>某一时刻</strong>是存在的，则这个时期就是这个变量的生存期；<br><strong>作用域</strong>：一个变量在<strong>某个文件或函数范围内</strong>是有效的，则这个范围就是这个变量的作用域；<br><strong>可见性</strong>：在一个变量的作用域可以<strong>引用</strong>该变量，则说这个变量在这个作用域是可见的，这么一个性质就是可见性；</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>存储类型（即存储类型关键字）是数据在内存中的存储方式，有四种：<code>auto</code>，<code>static</code>，<code>extern</code>，<code>register</code>。</li></ol><p><code>auto</code>和<code>register</code>用于声明内部变量，<code>auto</code>变量存储在<strong>栈</strong>中；<code>extern</code>用于声明外部变量，<code>static</code>用于声明内部和外部变量，<code>extern</code>和<code>static</code>变量存储在静态存储区中。内部变量默认是<code>auto</code>类型，外部变量默认是<code>extern</code>类型。</p><ol start="2"><li><p>C语言中，常量存储在常量区，该区数据可读不可写。<br><code>static</code>全局变量和<code>static</code>局部变量都存储在全局数据区。</p></li><li><p>C语言中，除了关键字，还有单词类型（语法符号）：标识符、运算符、分隔符、常量、注释符。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容来自谭浩强的《C语言程序设计》总结&lt;br&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://0202zc.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>二分查找算法细节详解</title>
    <link href="http://0202zc.github.io/2020/01/27/algorithm-binary-search/"/>
    <id>http://0202zc.github.io/2020/01/27/algorithm-binary-search/</id>
    <published>2020-01-27T04:37:40.000Z</published>
    <updated>2020-01-27T05:28:17.252Z</updated>
    
    <content type="html"><![CDATA[<p>From LeetCode 34. Find First and Last Position of Element in Sorted Array<br><a id="more"></a></p><blockquote><p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/</a><br>来源：力扣（LeetCode）</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我相信对很多读者朋友来说，编写二分查找的算法代码属于玄学编程，虽然看起来很简单，就是会出错，要么会漏个等号，要么少加个 1。</p><p>不要气馁，因为二分查找其实并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的：</p><blockquote><p>Although the basic idea of binary search is comparatively straightforward,<br>the details can be surprisingly tricky… </p></blockquote><p>这句话可以这样理解：<strong>思路很简单，细节是魔鬼。</strong></p><p>本文以问答的形式，探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。第一个场景是最简单的算法形式，解决 <a href="https://leetcode-cn.com/problems/binary-search/" target="_blank">这道题</a>，后两个场景就是本题。</p><p>而且，我们就是要深入细节，比如不等号是否应该带等号，<code>mid</code> 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p><h3 id="零、二分查找框架"><a href="#零、二分查找框架" class="headerlink" title="零、二分查找框架"></a>零、二分查找框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。</strong>本文都会使用 <code>else if</code>，旨在讲清楚，读者理解后可自行简化。</p><p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p><p>另外声明一下，计算 mid 时需要技巧防止溢出，即 <code>mid=left+(right-left)/2</code>。本文暂时忽略这个问题。</p><h3 id="一、寻找一个数（基本的二分搜索）"><a href="#一、寻找一个数（基本的二分搜索）" class="headerlink" title="一、寻找一个数（基本的二分搜索）"></a>一、寻找一个数（基本的二分搜索）</h3><p>这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为什么 <code>while</code> 循环的条件中是 <strong>&lt;=</strong>，而不是 <strong>&lt;</strong> ？</li></ol><p>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length-1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p><p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p><p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」</strong>。</p><p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">     <span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure></p><p>但如果没找到，就需要 <code>while</code> 循环终止，然后返回 -1。那 <code>while</code> 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p><p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 $[right + 1, right]$，或者带个具体的数字进去 $[3, 2]$，<strong>可见这时候搜索区间为空</strong>，因为没有数字既大于等于 $3$ 又小于等于 $2$ 的吧。所以这时候 <code>while</code> 循环终止是正确的，直接返回 -1 即可。</p><p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 $[left, right]$，或者带个具体的数字进去 $[2, 2]$，这时候搜索区间非空，还有一个数 $2$，但此时 while 循环终止了。也就是说这区间 $[2, 2]$ 被漏掉了，索引 $2$ 没有被搜索，如果这时候直接返回 $-1$ 就是错误的。</p><p>当然，如果你非要用 <code>while(left &lt; right)</code> 也可以，我们已经知道了出错的原因，就打个补丁好了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>为什么 <code>left = mid + 1</code>，<code>right = mid - 1</code>？我看有的代码是 <code>right = mid</code> 或者 <code>left = mid</code>，没有这些加加减减，到底怎么回事，怎么判断？</li></ol><p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p><p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 $[left, right]$。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，如何确定下一步的搜索区间呢？</p><p>当然是 $[left, mid - 1]$ 或者 $[mid + 1, right]$ 对不对？因为 <code>mid</code> 已经搜索过，应该从搜索区间中去除。</p><ol start="3"><li>此算法有什么缺陷？</li></ol><p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p><p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target = 2</code>，此算法返回的索引是 $2$，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 $1$，或者我想得到 <code>target</code> 的右侧边界，即索引 $3$，这样的话此算法是无法处理的。</p><p>这样的需求很常见。你也许会说，找到一个 <code>target</code>，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。</p><p>我们后续的算法就来讨论这两种二分查找的算法。</p><h3 id="二、寻找左侧边界的二分搜索"><a href="#二、寻找左侧边界的二分搜索" class="headerlink" title="二、寻找左侧边界的二分搜索"></a>二、寻找左侧边界的二分搜索</h3><p>直接看代码，其中的标记是需要注意的细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>为什么 <code>while(left &lt; right)</code> 而不是 <code>&lt;=</code> ?</li></ol><p>答：用相同的方法分析，因为 <code>right = nums.length</code> 而不是 <code>nums.length - 1</code> 。因此每次循环的「搜索区间」是 <code>[left, right)</code> 左闭右开。</p><p><code>while(left &lt; right)</code> 终止的条件是 <code>left == right</code>，此时搜索区间 <code>[left, left)</code> 为空，所以可以正确终止。</p><ol start="2"><li>为什么没有返回 <code>-1</code> 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？</li></ol><p>答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：</p><p><img data-src="https://pic.leetcode-cn.com/0ee763a9e3b27dddf9c60ffe7e17db7160d2910d7bca591af8f3e3202d0f19ea-file_1560274288808" alt=""></p><p>对于这个数组，算法会返回 $1$。这个 $1$ 的含义可以这样解读：<code>nums</code> 中小于 $2$ 的元素有 $1$ 个。</p><p>比如对于有序数组 <code>nums = [2,3,5,7]</code>, <code>target = 1</code>，算法会返回 $0$<code>，含义是：nums</code> 中小于 $1$ 的元素有 $0$ 个。</p><p>再比如说 <code>nums</code> 不变，<code>target = 8</code>，算法会返回 $4$，含义是：<code>nums</code> 中小于 $8$ 的元素有 $4$ 个。</p><p>综上可以看出，函数的返回值（即 <code>left</code> 变量的值）取值区间是闭区间 $[0, nums.length]$，所以我们简单添加两行代码就能在正确的时候 <code>return -1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 类似之前算法的处理方式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>为什么 <code>left = mid + 1</code>，<code>right = mid</code> ？和之前的算法不一样？</li></ol><p>答：这个很好解释，因为我们的「搜索区间」是 $[left, right)$ 左闭右开，所以当 <code>nums[mid]</code> 被检测之后，下一步的搜索区间应该去掉 <code>mid</code> 分割成两个区间，即 $[left, mid)$ 或 $[mid + 1, right)$。</p><ol start="4"><li>为什么该算法能够搜索左侧边界？</li></ol><p>答：关键在于对于 <code>nums[mid] == target</code> 这种情况的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">    right = mid;</span><br></pre></td></tr></table></figure></p><p>可见，找到 <code>target</code> 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 $[left, mid)$ 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><p>可见，找到 <code>target</code> 时不要立即返回，而是缩小「搜索区间」的上界 <code>right</code>，在区间 $[left, mid)$ 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。</p><ol start="5"><li>为什么返回 <code>left</code> 而不是 <code>right？</code></li></ol><p>答：都是一样的，因为 <code>while</code> 终止的条件是 <code>left == right</code>。</p><h3 id="三、寻找右侧边界的二分查找"><a href="#三、寻找右侧边界的二分查找" class="headerlink" title="三、寻找右侧边界的二分查找"></a>三、寻找右侧边界的二分查找</h3><p>寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>为什么这个算法能够找到右侧边界？</li></ol><p>答：类似地，关键点还是这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>当 <code>nums[mid] == target</code> 时，不要立即返回，而是增大「搜索区间」的下界 <code>left</code>，使得区间不断向右收缩，达到锁定右侧边界的目的。</p><ol start="2"><li>为什么最后返回 <code>left - 1</code> 而不像左侧边界的函数，返回 <code>left</code>？而且我觉得这里既然是搜索右侧边界，应该返回 <code>right</code> 才对。</li></ol><p>答：首先，<code>while</code> 循环的终止条件是 <code>left == right</code>，所以 <code>left</code> 和 <code>right</code> 是一样的，你非要体现右侧的特点，返回 <code>right - 1</code> 好了。</p><p>至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 这样想: mid = left - 1</span></span><br></pre></td></tr></table></figure><p><img data-src="https://pic.leetcode-cn.com/dc975e6d3c8b9d0ee5453ce9253d5ee3b2b3ee6461a5183d3922d52724873709-file_1560274288798" alt=""></p><p>因为我们对 left 的更新必须是 <code>left = mid + 1</code>，就是说 <code>while</code> 循环结束时，<code>nums[left]</code> 一定不等于 <code>target</code> 了，而 <code>nums[left-1]</code> 可能是 <code>target</code>。</p><p>至于为什么 <code>left</code> 的更新必须是 <code>left = mid + 1</code>，同左侧边界搜索，就不再赘述。</p><ol start="3"><li>为什么没有返回 $-1$ 的操作？如果 <code>nums</code> 中不存在 <code>target</code> 这个值，怎么办？</li></ol><p>答：类似之前的左侧边界搜索，因为 <code>while</code> 的终止条件是 <code>left == right</code>，就是说 <code>left</code> 的取值范围是 $[0, nums.length]$，所以可以添加两行代码，正确地返回 $−1$：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span>)  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left-<span class="number">1</span>] == target ? (left-<span class="number">1</span>) : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h3><p>来梳理一下这些细节差异的因果逻辑：</p><p>第一个，最基本的二分查找算法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length - <span class="number">1</span></span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+<span class="number">1</span> 和 right = mid<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure></p><p>第二个，寻找左侧边界的二分查找：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure></p><p>第三个，寻找右侧边界的二分查找：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + <span class="number">1</span></span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure></p><p>如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。</p><p>通过本文，你学会了：</p><p>分析二分查找代码时，不要出现 <code>else</code>，全部展开成 <code>else if</code> 方便理解。</p><p>注意「搜索区间」和 <code>while</code> 的终止条件，如果存在漏掉的元素，记得在最后检查。</p><p>如需要搜索左右边界，只要在<code>nums[mid] == target</code> 时做修改即可。搜索右侧时需要减一。</p><p>以后就算遇到其他的二分查找变形，运用这几点技巧，也能保证你写出正确的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From LeetCode 34. Find First and Last Position of Element in Sorted Array&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>合并有序线性表</title>
    <link href="http://0202zc.github.io/2020/01/26/algorithm-merge-list/"/>
    <id>http://0202zc.github.io/2020/01/26/algorithm-merge-list/</id>
    <published>2020-01-26T03:13:54.000Z</published>
    <updated>2020-01-27T03:51:50.390Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 21. Merge Two Sorted Lists &amp; 88. Merge Sorted Array<br><a id="more"></a></p><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p><blockquote><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素<br>终止条件：两条链表分别名为<code>l1</code>和<code>l2</code>，当<code>l1</code>为空或<code>l2</code>为空时结束<br>返回值：每一层调用都返回排序好的链表头<br>本级递归内容：如果<code>l1</code>的$val$值更小，则将<code>l1-&gt;next</code>与排序好的链表头相接，<code>l2</code>同理<br>$O(m+n)$，<code>m</code>为<code>l1</code>的长度，<code>n</code>为<code>l2</code>的长度</p><h4 id="画解"><a href="#画解" class="headerlink" title="画解"></a>画解</h4><p><img data-src="https://pic.leetcode-cn.com/7ddaf1beb64fdef4393cc6ebd0dfd1723b97d2c183ab5c8414c0898027623a00-frame_00001.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/f4b7e354473d2bf28283ac3c410bc81e9f7ecb35f14189de9fadc041452c2653-frame_00002.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/001e4c2fdd8b5d725bc25df6373f7590404d9ef16efdea6e3700b68c23500a7a-frame_00003.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/5fbc72d56f32a8b1bc34db4bbd1588abebb4942348d8ea22fdb60724c8e4986c-frame_00004.png" alt=""></p><ul><li>作者：guanpengchn</li><li>链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/</a></li><li>来源：力扣（LeetCode）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val &lt;= l2-&gt;val)&#123;</span><br><span class="line">        l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br><strong>说明:</strong></p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</li></ul><p><strong>示例:</strong></p><blockquote><p>输入:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p></blockquote><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>因为<code>nums1</code>的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去<br>设置指针<code>len1</code>和<code>len2</code>分别指向<code>nums1</code>和<code>nums2</code>的有数字尾部，从尾部值开始比较遍历，同时设置指针<code>len</code>指向<code>nums1</code>的最末尾，每次遍历比较值大小之后，则进行填充<br>当<code>len1 &lt; 0</code>时遍历结束，此时<code>nums2</code>中海油数据未拷贝完全，将其直接拷贝到<code>nums1</code>的前面，最后得到结果数组<br>时间复杂度：$O(m+n)$</p><h4 id="画解-1"><a href="#画解-1" class="headerlink" title="画解"></a>画解</h4><p><img data-src="https://pic.leetcode-cn.com/2b89af59204b9e77445e33b9613be7f61bcd2a1b0a07c0bde2e2b50603d5efff-1.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/bc8d62acb39e43526e7844b62724f43d6193570d9952a96277f55b02cbe4e525-2.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/b72c52702e7b932eefbf0459630038a0120bf51cdf0f744bed7bdd317a739677-3.png" alt=""><br><img data-src="https://pic.leetcode-cn.com/5b0376aed4cf530afc60594379b030511adb22661b4ba7892601d194b6426200-4.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作者：guanpengchn</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/hua-jie-suan-fa-88-he-bing-liang-ge-you-xu-shu-zu-/</span></span><br><span class="line"><span class="comment">// 来源：力扣（LeetCode）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(len1 &gt;= <span class="number">0</span> &amp;&amp; len2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码</span></span><br><span class="line">            nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1</span></span><br><span class="line">        System.arraycopy(nums2, <span class="number">0</span>, nums1, <span class="number">0</span>, len2 + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 21. Merge Two Sorted Lists &amp;amp; 88. Merge Sorted Array&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>复试笔试C语言重要简答题</title>
    <link href="http://0202zc.github.io/2020/01/25/algorithm-short-answers-about-C/"/>
    <id>http://0202zc.github.io/2020/01/25/algorithm-short-answers-about-C/</id>
    <published>2020-01-25T08:45:37.000Z</published>
    <updated>2020-01-31T12:44:29.254Z</updated>
    
    <content type="html"><![CDATA[<p>来源：UESTC考研群<br><a id="more"></a></p><h3 id="从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。"><a href="#从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。" class="headerlink" title="从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。"></a>从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。</h3><ul><li><p><strong>使用指针</strong>：有些程序用其他语言也可以实现，但C能够更有效地实现；有些程序无法用其它语言实现，如直接访问硬件，但C却可以。正因为指针可以拥有类似于汇编的寻址方式，所以可以使程序更高效。</p></li><li><p><strong>使用宏函数</strong>：宏函数仅仅作为预先写好的代码嵌入到当前程序，不会产生函数调用，所以仅仅是占用了空间，而使程序可以高效运行。在频繁调用同⼀个宏函数的时候，该现象尤其突出。函数和宏函数的区别就在于，宏函数占用了大量的空间，而函数占用了时间。</p><ul><li>宏函数的例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (a &gt; b ? a : b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxNum = MAX(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The max num is : %d\n"</span>, maxNum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用位操作</strong>：位操作可以减少除法和取模的运算。在计算机程序中数据的位是可以操作的最小数据单位，理论上可以用“位运算”来完成所有的运算和操作。灵活的位操作可以有效地提高程序运行的效率。</p></li><li><p>循环嵌套中将较<strong>长</strong>循环设为<strong>内置</strong>循环，较<strong>短</strong>循环设为<strong>外置</strong>循环，以减少cpu跨切循环层的次数，提高程序的运行效率。(操作系统页面置换相关，减少页面置换次数)</p></li><li><p>将汇编指令嵌入到C语言程序中，<strong>汇编语言是效率最高的计算机语言</strong>，因此为了获得程序的高效率，可以在C语言程序中嵌入汇编，从而充分利用高级语言和汇编语言各⾃的特点。</p></li><li><p>在C语言程序中可以<strong>调用系统API</strong>，接近底层，从而提高程序的运行效率。</p></li><li><p>⼀般情况下，C语言源程序中的每⼀行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中⼀部分内容进行编译，此时就需要在程序中加上条件，让编译器<strong>只对满足条件的代码进行编译</strong>，将不满足条件的代码舍弃，这就是<em>条件编译</em>。</p></li></ul><h3 id="请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int）"><a href="#请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int）" class="headerlink" title="请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int）"></a>请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int）</h3><ul><li>算术运算式中，低类型能够转换为高类型（自动类型转换）。</li><li>赋值表达式中，右边表达式的值<u>⾃动隐式转换</u>为左边变量的类型，并赋值给它。</li><li>函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。</li><li>函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋给调用函数。</li></ul><h4 id="小题：float如何四舍五入转化成int"><a href="#小题：float如何四舍五入转化成int" class="headerlink" title="小题：float如何四舍五入转化成int"></a>小题：float如何四舍五入转化成int</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)(f + <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组越界会产生什么后果？"><a href="#数组越界会产生什么后果？" class="headerlink" title="数组越界会产生什么后果？"></a>数组越界会产生什么后果？</h3><p>越界访问有可能把数据放到已经存储了重要数据的内存单元，也就是<strong>改写了本来不许改写的数据</strong>，如果这个数据是系统的重要数据，有可能<strong>导致系统运行紊乱甚至是崩溃</strong>。当然如果这个数据并不重要，那么越界访问的后果就不明显或者是没有影响。避免的方法是对数组的下标严格检测，判断组数下标是否越界，用指针访问数组时要注意判断<strong>指针的指向是否已超过数组下标的最大值</strong>。</p><h3 id="值传递和地址传递"><a href="#值传递和地址传递" class="headerlink" title="值传递和地址传递"></a>值传递和地址传递</h3><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>被调函数的形参作为被调函数的<strong>局部变量</strong>处理，即在内存的堆栈中开辟空间以存放由主调函数放进来的实参的值，从而成为了实参的一个<strong>拷贝</strong>。<br>其特点是被调函数对形参的任何操作都是作为<strong>局部变量</strong>进行，<u>不会影响</u>主调函数的实参变量的值。</p><h4 id="地址传递"><a href="#地址传递" class="headerlink" title="地址传递"></a>地址传递</h4><p>被调函数的形参虽然也作为局部变量在堆栈中开辟了内存空间，但是这是存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成<strong>间接寻址</strong>，即通过<strong>堆栈中存放的地址</strong>访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。</p><h3 id="C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？"><a href="#C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？" class="headerlink" title="C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？"></a>C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储位置</th></tr></thead><tbody><tr><td style="text-align:center">常量</td><td style="text-align:center">常量区</td></tr><tr><td style="text-align:center">静态局部变量</td><td style="text-align:center">全局数据区</td></tr><tr><td style="text-align:center">静态局部变量</td><td style="text-align:center">全局数据区</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：UESTC考研群&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>删除排序数组中的重复项与移除元素</title>
    <link href="http://0202zc.github.io/2020/01/24/algorithm-remove-elements/"/>
    <id>http://0202zc.github.io/2020/01/24/algorithm-remove-elements/</id>
    <published>2020-01-24T06:54:54.000Z</published>
    <updated>2020-01-24T09:52:48.401Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 26. Remove Duplicates from Sorted Array &amp; 27. remove elements<br><a id="more"></a></p><h3 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用$O(1)$额外空间的条件下完成。</p><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5><blockquote><p>给定数组 <code>nums = [1,1,2]</code>,<br>函数应该返回新的长度<code>2</code>, 并且原数组<code>nums</code>的前两个元素被修改为<code>1, 2</code>。<br>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5><p>给定<code>nums = [0,0,1,1,1,2,2,3,3,4]</code>,</p><p>函数应该返回新的长度<code>5</code>, 并且原数组<code>nums</code>的前五个元素被修改为<code>0, 1, 2, 3, 4</code>。</p><p>你不需要考虑数组中超出新长度后面的元素。</p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p><strong>“拷贝覆盖”</strong><br><img data-src="/images/algorithm/Remove-Elements-1.jpg" alt=""><br>如上图所示，用count来记录元素应该覆盖的步长：<br>在i位置时，</p><ul><li>若<code>nums[i] == nums[i + 1]</code>，则<code>count++</code></li><li>否则，<code>countinue</code><br><em>此处用了arr[]来记录每个元素应该移动的步长</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)&#123;  <span class="comment">//空数组直接返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> arr[numsSize];</span><br><span class="line">    arr[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i - <span class="number">1</span>] == nums[i]) &#123;</span><br><span class="line">             count++;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i]=count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">         nums[i - arr[i]] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数组<code>nums</code>和一个值<code>val</code>，你需要<strong>原地</strong>移除所有数值等于<code>val</code>的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用$O(1)$额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><h4 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h4><p>同样是“拷贝覆盖”<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">//空数组直接返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numsSize; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i - count] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numsSize - count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 26. Remove Duplicates from Sorted Array &amp;amp; 27. remove elements&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C语言一些要点总结</title>
    <link href="http://0202zc.github.io/2020/01/23/algorithm-something-about-C/"/>
    <id>http://0202zc.github.io/2020/01/23/algorithm-something-about-C/</id>
    <published>2020-01-23T02:39:09.000Z</published>
    <updated>2020-01-30T05:07:19.590Z</updated>
    
    <content type="html"><![CDATA[<p>复试笔试C语言一些要点<br><a id="more"></a></p><h3 id="C语言短路求值（逻辑与、逻辑或）"><a href="#C语言短路求值（逻辑与、逻辑或）" class="headerlink" title="C语言短路求值（逻辑与、逻辑或）"></a>C语言短路求值（逻辑与、逻辑或）</h3><h4 id="逻辑或的短路"><a href="#逻辑或的短路" class="headerlink" title="逻辑或的短路"></a>逻辑或的短路</h4><p>首先上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="number">1</span> || (a = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：</p><blockquote><p>a = 1<br>a = 1</p></blockquote><p>逻辑或的表现形式如下：<br><code>expression1 || exexpression2</code></p><p>这⾥用到了逻辑或，由于逻辑或的短路，expression1为true，则后⾯的expression2（即：(a=0) ）不再求值，整个表达式的结果为true，所以a的值仍为1，没有改变。【即：一真为真】</p><h4 id="逻辑与的短路"><a href="#逻辑与的短路" class="headerlink" title="逻辑与的短路"></a>逻辑与的短路</h4><p>⾸先看如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="number">0</span> &amp;&amp; (a = <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果如下：</p><blockquote><p>a = 1<br>a = 1</p></blockquote><p>逻辑与的表现形式如下：<br><code>expression1 &amp;&amp; expression2</code></p><p>上述代码中用到了逻辑与，由于逻辑与的短路，<code>expression1</code>为<code>false</code>，则后面的<code>expression2</code>不再求值，整个的结果为<code>false</code>，所以a的值没有改变。【即：一假则假】</p><h3 id="Eratosthenes筛选法"><a href="#Eratosthenes筛选法" class="headerlink" title="Eratosthenes筛选法"></a>Eratosthenes筛选法</h3><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>解释一：<br>给出要筛选数值的范围$n$，找出<code>sqrt(n)</code>以内的素数$p_1, p_2, … , p_k$。</p><ul><li>先把1删除（现今数学界1既不是质数也不是合数）</li><li>读取队列中当前最小的数2，然后把2的倍数删去</li><li>读取队列中当前最小的数3，然后把3的倍数删去</li><li>读取队列中当前最小的数5，然后把5的倍数删去</li><li>读取队列中当前最小的数7，然后把7的倍数删去</li><li>不断重复下去…直到需求的范围内所有的数均删除或读取<br>注：此处的队列并非数据结构队列，如需保留运算结果，处于存储空间的充分利用以及大量删除操作的实施，建议采用链表的数据结构。<br>【来源：百度百科】</li></ul><p>解释二：</p><ol><li>取最小的数$2$，并声明它是素数，同时筛去它及它的所有倍数；</li><li>取未筛去的数中的最小者，声明它是素数，同时筛去它及它的所有倍数；</li><li>重复步骤2，至筛中无数为止，得到所有素数。</li></ol><p>筛法实际上是筛去合数，留下素数。</p><h5 id="一位数组举例"><a href="#一位数组举例" class="headerlink" title="一位数组举例"></a>一位数组举例</h5><p><img data-src="/images/algorithm/something-about-C-1.jfif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C Language</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">/*i表示整数和对应的下标*/</span></span><br><span class="line"><span class="keyword">int</span> j; <span class="comment">/*j表示正要处理的质数，j之前的已处理，j之后的未处理*/</span></span><br><span class="line"><span class="keyword">int</span> k; <span class="comment">/*k表示正在处理的j的倍数从2开始到j*k&lt;SIZE*/</span></span><br><span class="line"><span class="keyword">int</span> a[SIZE]; <span class="comment">/*下标表示整数内容判断是否为质数*/</span></span><br><span class="line"><span class="keyword">int</span> *p; <span class="comment">/*控制循环*/</span></span><br><span class="line"><span class="keyword">for</span>(p = a; p &lt; a+SIZE; ++p) &#123; <span class="comment">/*初始化数组全是TRUE*/</span></span><br><span class="line">*p = TRUE;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>] = a[<span class="number">1</span>] = FALSE; <span class="comment">/*设置前面两个是不是质数的数的状态为FALSE，即0和1不是质数*/</span></span><br><span class="line">i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; SIZE) &#123; <span class="comment">/*找到下一个质数*/</span></span><br><span class="line"><span class="keyword">while</span>(a[i++] == TRUE) &#123;</span><br><span class="line">j = i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(k = <span class="number">2</span>; j*k &lt; SIZE &amp;&amp; i &lt; SIZE; ++k) &#123; <span class="comment">/*处理质数的倍数*/</span></span><br><span class="line">a[j*k] = FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(p = a; p &lt; a+SIZE; ++p) &#123; <span class="comment">/*打印出质数*/</span></span><br><span class="line"><span class="keyword">if</span>(*p == TRUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%8d"</span>, p-a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vec_flag(n, <span class="literal">true</span>);</span><br><span class="line">    vec_flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    vec_flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="built_in">sqrt</span>(n);i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vec_flag[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; n; j += i) &#123;</span><br><span class="line">                vec_flag[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count(vec_flag.begin(), vec_flag.end(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_int_iter</span><span class="params">()</span>:</span><span class="comment">#生成器生成从3开始的无限奇数序列</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = n + <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">_not_divisible</span><span class="params">(n)</span>:</span><span class="comment">#定义筛选函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x:x % n &gt; <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">primes</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>          <span class="comment">#先返回一个2</span></span><br><span class="line">    it = _int_iter() <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = next(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = filter(_not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> primes():<span class="comment">#构造循环条件，使之可以输出任何范围的素数序列</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1000</span>:</span><br><span class="line">        print(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="关于void"><a href="#关于void" class="headerlink" title="关于void *"></a>关于void *</h3><h4 id="void的含义"><a href="#void的含义" class="headerlink" title="void的含义"></a>void的含义</h4><p><code>void</code>即“无类型”，<code>void *</code>则为“无类型指针”，可以指向任何数据类型</p><h4 id="void指针的使用规范"><a href="#void指针的使用规范" class="headerlink" title="void指针的使用规范"></a>void指针的使用规范</h4><ul><li><code>void</code>指针可以指向任意类型的数据，亦即可用任意数据类型的指针对<code>void</code>指针赋值。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p_int;</span><br><span class="line"><span class="keyword">void</span> *p_void;</span><br><span class="line">p_void = p_int; <span class="comment">/*但是不能 p_int = p_void*/</span></span><br></pre></td></tr></table></figure></li></ul><p>如果要将<code>p_void</code>赋给其他类型指针，则需要强制类型转换如：<code>p_int = (int *)p_void;</code></p><ul><li>在ANSIC标准中，不允许对<code>void</code>指针进行算术运算如<code>p_void++</code>或<code>p_void += 1</code>等，而在GNU中则允许。因为在缺省情况下，GNU认为<code>void *</code>与<code>char *</code>⼀样。<code>sizeof(*pvoid ) == sizeof(char)</code>.</li><li>由于<code>void</code>指针可以指向任意类型的数据，亦即可用任意数据类型的指针对<code>void</code>指针赋值，因此还可以用<code>void</code>指针来作为函数形参，这样函数就可以接受任意数据类型的指针作为参数。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *buffer, <span class="keyword">int</span> c, <span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;复试笔试C语言一些要点&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C/C++" scheme="http://0202zc.github.io/tags/C-C/"/>
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>寻找旋转排序数组中的最小值</title>
    <link href="http://0202zc.github.io/2020/01/22/algorithm-Find-Minimum-in-Rotated-Sorted-Array/"/>
    <id>http://0202zc.github.io/2020/01/22/algorithm-Find-Minimum-in-Rotated-Sorted-Array/</id>
    <published>2020-01-22T03:21:36.000Z</published>
    <updated>2020-02-28T15:18:26.619Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode上的一道题目：153. 寻找旋转排序数组中的最小值<br><a id="more"></a><br>来源：<br><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xi/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。<br>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。<br>请找出其中最小的元素。<br>你可以假设数组中不存在重复元素。</p></blockquote><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><blockquote><p>输入: [3,4,5,1,2]<br>输出: 1</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><blockquote><p>输入: [4,5,6,7,0,1,2]<br>输出: 0</p></blockquote><h3 id="方法：二分查找"><a href="#方法：二分查找" class="headerlink" title="方法：二分查找"></a>方法：二分查找</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>一种暴力的解法是搜索整个数组，找到其中的最小元素，这样的时间复杂度是 $O(N)$ 其中 $N$ 是给定数组的大小。</p><p>一个非常棒的解决该问题的办法是使用<code>二分搜索</code>。在二分搜索中，我们找到区间的中间点并根据某些条件决定去区间左半部分还是右半部分搜索。</p><p>由于给定的数组是有序的，我们就可以使用二分搜索。然而，数组被旋转了，所以简单的使用二分搜索并不可行。</p><p>我们希望找到旋转排序数组的最小值，如果数组没有被旋转呢？如何检验这一点呢？</p><p>如果数组没有被旋转，是升序排列，就满足 <code>last element &gt; first element</code>。</p><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-1.png" alt=""></p><p>上图例子中 <code>7 &gt; 2</code> 。说明数组仍然是有序的，没有被旋转。</p><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-2.png" alt=""></p><p>上面的例子中 <code>3 &lt; 4</code>，因此数组旋转过了。这是因为原先的数组为 <code>[2, 3, 4, 5, 6, 7]</code>，通过旋转较小的元素 <code>[2, 3]</code> 移到了后面，也就是 [4, 5, 6, 7, <code>2, 3</code>]。因此旋转数组中第一个元素 <code>[4]</code> 变得比最后一个元素大。</p><p>这意味着在数组中你会发现一个变化的点，这个点会帮助我们解决这个问题，我们称其为<code>变化点</code>。</p><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-3.png" alt=""></p><p>在这个改进版本的二分搜索算法中，我们需要找到这个点。下面是关于<code>变化点</code>的特点：</p><blockquote><p>所有变化点左侧元素 &gt; 数组第一个元素<br>所有变化点右侧元素 &lt; 数组第一个元素</p></blockquote><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol><li><p>找到数组的中间元素<code>mid</code>。</p></li><li><p>如果<code>中间元素 &gt; 数组第一个元素</code>，我们需要在<code>mid</code>右边搜索变化点。</p></li><li><p>如果<code>中间元素 &lt; 数组第一个元素</code>，我们需要在<code>mid</code>做边搜索变化点。</p></li></ol><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-4.png" alt=""></p><p>上面的例子中，中间元素<code>6</code>比第一个元素<code>4</code>大，因此在中间点右侧继续搜索。</p><ol start="4"><li><p>当我们找到变化点时停止搜索，当以下条件满足任意一个即可：<br><code>nums[mid] &gt; nums[mid + 1]</code>，因此<strong>mid+1</strong>是最小值。</p><p><code>nums[mid - 1] &gt; nums[mid]</code>，因此<strong>mid</strong>是最小值。</p></li></ol><p><img data-src="/images/algorithm/Find-Minimum-in-Rotated-Sorted-Array-5.png" alt=""></p><p>在上面的例子中，标记左右区间端点。中间元素为<code>2</code>，之后的元素是<code>7</code>满足<code>7 &gt; 2</code>也就是<code>nums[mid - 1] &gt; nums[mid]</code>。因此找到变化点也就是最小元素为<code>2</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the list has just one element then return that element.</span></span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initializing left and right pointers.</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the last element is greater than the first element then there is no rotation.</span></span><br><span class="line">    <span class="comment">// e.g. 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 7. Already sorted array.</span></span><br><span class="line">    <span class="comment">// Hence the smallest element is first element. A[0]</span></span><br><span class="line">    <span class="keyword">if</span> (nums[right] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Binary search way</span></span><br><span class="line">    <span class="keyword">while</span> (right &gt;= left) &#123;</span><br><span class="line">      <span class="comment">// Find the mid element</span></span><br><span class="line">      <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the mid element is greater than its next element then mid+1 element is the smallest</span></span><br><span class="line">      <span class="comment">// This point would be the point of change. From higher to lower value.</span></span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the mid element is lesser than its previous element then mid element is the smallest</span></span><br><span class="line">      <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &gt; nums[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[mid];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the mid elements value is greater than the 0th element this means</span></span><br><span class="line">      <span class="comment">// the least value is still somewhere to the right as we are still dealing with elements</span></span><br><span class="line">      <span class="comment">// greater than nums[0]</span></span><br><span class="line">      <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if nums[0] is greater than the mid value then this means the smallest value is somewhere to</span></span><br><span class="line">        <span class="comment">// the left</span></span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h5><ul><li>时间复杂度：和二分搜索一样$O(logN)$</li><li>空间复杂度：$O(1)$</li></ul><h5 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h5><ol><li><p>判断最小的数是否在第一个位置，若是则返回<code>nums[0]</code>；</p></li><li><p>否则，选取中间位置mid的数和right位置的数进行比较，若<code>nums[mid] &lt; nums[r]</code>，说明最小的数在mid之前，<code>right = mid</code>；反之，令<code>left = mid + 1</code>；</p></li><li><p>重复进行，直到<code>left &gt;= right</code>。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">if</span>(nums[left] &lt; nums[right])</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[right])</span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">//nums[mid]已经比nums[right]大，故不再考虑nums[mid]</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;      <span class="comment">//nums[mid]比nums[right]小，表示nums[mid]可能是最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode上的一道题目：153. 寻找旋转排序数组中的最小值&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>最小公倍数&amp;最大公因数</title>
    <link href="http://0202zc.github.io/2020/01/21/algorithm-LCM&amp;GCD/"/>
    <id>http://0202zc.github.io/2020/01/21/algorithm-LCM&amp;GCD/</id>
    <published>2020-01-21T03:08:28.000Z</published>
    <updated>2020-01-24T09:52:50.425Z</updated>
    
    <content type="html"><![CDATA[<p>几个数共有的倍数叫做这几个数的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。约数和倍数都表示一个整数与另一个整数的关系，不能单独存在。<br><a id="more"></a></p><h3 id="求最大公因数算法"><a href="#求最大公因数算法" class="headerlink" title="求最大公因数算法"></a>求最大公因数算法</h3><p>求最大公约数有多种方法，常见的有<strong>质因数分解法</strong>、<strong>短除法</strong>、<strong>辗转相除法</strong>、<strong>更相减损法</strong>。<br>下面介绍辗转相除法（欧几里德算法）</p><blockquote><p>有两整数a和b：<br>① a%b得余数temp<br>② 若temp=0，则b即为两数的最大公因数<br>③ 若temp≠0，则令a=b，b=temp，再回去执行①</p></blockquote><p>例如，求27和15的最大公因数过程为：</p><blockquote><p>27÷15=1 余12<br>15÷12=1 余3<br>12÷3=4 余0<br>因此，3即为最大公因数</p></blockquote><h4 id="代码实现如下："><a href="#代码实现如下：" class="headerlink" title="代码实现如下："></a>代码实现如下：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求a，b的最大公因数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        temp = a % b;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(temp != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求最小公倍数算法"><a href="#求最小公倍数算法" class="headerlink" title="求最小公倍数算法"></a>求最小公倍数算法</h3><blockquote><p><strong>最小公倍数 = 两整数的乘积 ÷ 最大公约数</strong></p></blockquote><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求m和n的最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCM</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, c;</span><br><span class="line">    x = m; y = n;</span><br><span class="line">    <span class="keyword">while</span>(m != <span class="number">0</span>) &#123;</span><br><span class="line">        c = n % m;</span><br><span class="line">        n = m;</span><br><span class="line">        m = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x * y / n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个数共有的倍数叫做这几个数的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。约数和倍数都表示一个整数与另一个整数的关系，不能单独存在。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://0202zc.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://0202zc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Algorithm" scheme="http://0202zc.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
