<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法集（改）]]></title>
    <url>%2F2020%2F03%2F07%2F%E7%AE%97%E6%B3%95%E9%9B%86(%E6%94%B9)%2F</url>
    <content type="text"><![CDATA[对算法集.doc的整理，好像都是真题（一部分算法题，一部分是填空、改错等） 筛选法求素数1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#define SIZE 100#define PWIDTH 10int main()&#123; char sieve[SIZE]; int i, n, printcol; for (i=0; i&lt;SIZE; i++) &#123; sieve[i]=0; &#125; //存放100以内的素数标识 sieve[0]=1; //1表示不是素数 printcol=0; //行计数 for (n=1; n&lt;=SIZE; n++) &#123; if (sieve[n-1]==0) &#123; printf("%d ",n); if (++printcol &gt;= PWIDTH) &#123; putchar('\n'); printcol=0; &#125; for (i=n; i&lt;=SIZE; i=i+n) &#123; sieve[i-1]=1; &#125; &#125; &#125; printf("\n"); return 0;&#125; 字符串交换1234567891011121314151617#include &lt;stdio.h&gt;void swap(char **p, char **q)&#123; char *temp; temp=*p; *p=*q; *q=temp;&#125;int main()&#123; char *str1="aaaa",*str2="bbb"; swap(&amp;str1,&amp;str2); puts(str1); puts(str2); return 0;&#125; 约瑟夫环123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#define N 100int main()&#123; int i,j,k,a[N+1],*p; for (i=0,p=a;p&lt;=a+N; i++,p++) &#123; *p=i; &#125;//填充序号 p=a+1;//取值 k=N;//统计剩余人数 for (j=1;k!=1;p++) &#123; if (p&gt;a+N) &#123; p=a+1; &#125;//若越界，返回数组首部，开始下一轮 if (*p!=0) &#123; if (j%3==0)&#123; *p=0; k--; j=0; &#125;//判断是否为3 j++; &#125;//判断是否被推出 &#125; for (i=1; i&lt;=N; i++) &#123; if (a[i]!=0) &#123; printf("最后剩下的数字是：%d\n",a[i]); &#125; &#125; return 0;&#125; 求第k小12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#define MAXN 10int search(int a[],int n,int k);int main()&#123; int a[MAXN]=&#123;3,3,1,3,3,0,0,2,1,3&#125;,n; printf("输入n值：\n"); scanf("%d",&amp;n); printf("%d \n",search(a,10,n)); for (int i=0; i&lt;10; i++) &#123; printf("%d ",a[i]); &#125; printf("\n"); return 0;&#125;int search(int a[],int n,int k)&#123; int low,high,i,j,t; k--; low=0; high=n-1; do&#123; i=low; j=high; t=a[low]; do&#123; while (i&lt;j&amp;&amp;t&lt;=a[j]) &#123; j--; &#125; a[i]=a[j]; while (i&lt;j&amp;&amp;t&gt;a[i]) &#123; i++; &#125; a[j]=a[i]; &#125;while(i&lt;j); if (i==k) &#123; return t; &#125;else if(i&lt;k)&#123; low=i+1; &#125;else&#123; high=i-1; &#125; &#125;while(low&lt;high); return a[low];&#125; 将字符串中的数字提取到数组中12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;int find_int(int *arr,char *pc);int main()&#123; int arr[10]; char s[]="ues11tc2015jsj320#"; for(int i=0;i&lt;find_int(arr,s);i++)&#123; printf("%d ",arr[i]); &#125; return 0;&#125;int find_int(int *arr,char *pc)&#123; int i=0,j=0,k=0,sum=0; while(pc[i]!='\0')&#123; if ('0'&lt;=pc[i]&amp;&amp;pc[i]&lt;='9') &#123; k=1; sum=sum*10+pc[i]-'0'; &#125;else if(k==1)&#123; k=0; arr[j++]=sum; sum=0; &#125;else&#123; k=0; &#125; i++; &#125; return j;&#125; 输入20个数（浮点+整型），逆序存放到单链表中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct node&#123; int flag; union&#123; int x; float y; &#125;data; struct node *next;&#125;node;node *L;node* Creatlist(int n);int main()&#123; int n=4; node *r; r=Creatlist(n); while (r) &#123; if (r-&gt;flag==0) &#123; printf("%d ",r-&gt;data.x); &#125;else&#123; printf("%.1f ",r-&gt;data.y); &#125; r=r-&gt;next; &#125; return 0;&#125;node* Creatlist(int n)&#123; int i=0,f; node *L,*p; L=NULL; while (i&lt;n) &#123; printf("输入第%d个数字的标志位：",i); scanf("%d",&amp;f); //若标志位0，则输入整型，否则输入浮点型 p=(node*)malloc(sizeof(node)); p-&gt;flag=f; printf("输入数据:"); if (f==0) &#123; scanf("%d",&amp;p-&gt;data.x); &#125;else&#123; scanf("%f",&amp;p-&gt;data.y); &#125; p-&gt;next=L; L=p; i++; &#125; return L;&#125; 求最高分分数学生的编号12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define N 10typedef struct student&#123; int num; int score;&#125;stu;void HighScore(stu *p);int main()&#123; stu arr[N]; HighScore(arr); return 0;&#125;void HighScore(stu *p)&#123; int i=0,max=0; stu *r,q; while(i&lt;N)&#123; printf("请输入学生的编号和分数: \n"); scanf("%d,%d",&amp;p[i].num,&amp;p[i].score); i++; &#125; printf("\n"); for(i=0;i&lt;N-1;i++)&#123; r=&amp;p[i]; for (int j=i+1; j&lt;N; j++) &#123; if(p[j].score&lt;p[i].score)&#123; r=&amp;p[j]; &#125; &#125;//一轮遍历找出余下数据中的最小者 //交换数据 q.num=r-&gt;num; q.score=r-&gt;score; r-&gt;num=p[i].num; r-&gt;score=p[i].score; p[i].num=q.num; p[i].score=q.score; &#125; max=p[N-1].score; for (i=N-1; i&gt;=0; i--) &#123; if(p[i].score==max)&#123; printf("%d %d\n",p[i].num,p[i].score); &#125; &#125;&#125; 字符数组逆置1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; char str[] = "abcdefg"; printf("%s\n", str); char p; int len = (int)strlen(str); for (int i = 0; i &lt; len / 2; i++) &#123; p = *(str + i); *(str + i) = *(str + len - i-1); *(str + len - i-1) = p; &#125; printf("%s\n", str); return 0;&#125; 2个字符串是否相等1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;int main()&#123; char str1[100],str2[100]; char *p,*q; printf("输入两个字符串，中间用,隔开\n"); scanf("%s,%s",str1,str2); printf("%s,%s",str1,str2); getchar(); p = str1; q = str2; if(*p!=*q)&#123; printf("\n两个字符串不相等\n"); &#125; else&#123; while((*p==*q)&amp;&amp;(*p!='\0')&amp;&amp;(*q!='\0'))&#123; p++; q++; &#125; if((*p=='\0')&amp;&amp;(*q=='\0'))&#123; printf("\n两个字符串相等\n"); &#125;else&#123; printf("\n两个字符串不相等\n"); &#125; &#125; return 0;&#125; 传地址12345678910111213#include &lt;stdio.h&gt;int func(int *t)&#123; return (*t-- = 3) - 1;&#125;//t得到p的地址1，地址1中内容为3 函数返回2 t移动到地址0int main()&#123; int arr[]=&#123;10,7,5&#125;; int *p=arr + 1; //p得到数组的地址1 printf("%d\n",func(p) + *p); //p依旧在地址1 其值为3 return 0;&#125; 地址理解123456789101112#include &lt;stdio.h&gt;int main()&#123; int arr[3]=&#123;5,3,1&#125;; int *p=&amp;arr[1]; p[1]=*p-1+(p[-1]=3); for (int i=0; i&lt;3; i++) &#123; printf("%d ",arr[i]); &#125; return 0;&#125; 一个交错级数求和1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;double sum(int x,int n);int main()&#123; int x,n; printf("输入数值x及项数n：\n"); scanf("%d %d",&amp;x,&amp;n); printf("%f\n",sum(x,n)); return 0;&#125;double sum(int x,int n)&#123; int i; double a,b,s; s=1.0; a=b=1; for (i=1; i&lt;=n; i++) &#123; a=a*x; b=b*i; if (i%2==0) &#123; s=s+a/b; &#125;else s=s-a/b; &#125; return s;&#125; 去掉字符串中的字母数字和重复项12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;void del(char *str);char arr[81];int main()&#123; char *s="UE&amp;&amp;&amp;stc2018##@%"; del(s); printf("%s\n",arr); return 0;&#125;void del(char *str)&#123; int i=0; while((*str)!=0)&#123; if (('a'&lt;=*str &amp;&amp; *str&lt;='z')||('A'&lt;=*str&amp;&amp;*str&lt;='Z')||('0'&lt;=*str&amp;&amp;*str&lt;='9')) &#123; //arr[i]=*str; str++; //i++; &#125; else&#123; while (*str==*(str+1)) &#123; str++; &#125; arr[i]=*str; str++; i++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文链表]]></title>
    <url>%2F2020%2F03%2F02%2Falgorithm-palindrome-linked-list%2F</url>
    <content type="text"><![CDATA[LeetCode 234. Palindrome Linked List 题目描述编写一个函数，检查输入的链表是否是回文的。 示例 1： 输入： 1-&gt;2输出： false 示例 2： 输入： 1-&gt;2-&gt;2-&gt;1输出： true 解题思路1、找中点的同时，将前半部倒序；2、比较。时间复杂度：$O(1)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */bool isPalindrome(struct ListNode* head)&#123; if(!head || !head-&gt;next) return true; struct ListNode *fast = head, *slow = head, *L = malloc(sizeof(struct ListNode)); L-&gt;next = NULL; while(fast &amp;&amp; fast-&gt;next) &#123; //找中点 slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; //同时对前面进行反转（头插法） head-&gt;next = L-&gt;next; L-&gt;next = head; head = slow; &#125; //slow指向后半部分头结点，head指向前半部分头结点 if(fast) slow = slow-&gt;next; head = L-&gt;next; //前半部分和后半部分进行比较 while(head)&#123; if(head-&gt;val != slow-&gt;val) return false; head = head-&gt;next; slow = slow-&gt;next; &#125; return true;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制链表转整数]]></title>
    <url>%2F2020%2F03%2F01%2Falgoritm-convert-binary-number-in-a-linked-list-to-integer%2F</url>
    <content type="text"><![CDATA[LeetCode 1290. Convert Binary Number in a Linked List to Integer 题目描述给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 示例 1： 输入：head = [1,0,1]输出：5解释：二进制数 (101) 转化为十进制数 (5) 示例 2： 输入：head = [0]输出：0 示例 3： 输入：head = [1]输出：1 示例 4： 输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]输出：18880 示例 5： 输入：head = [0,0]输出：0 提示： 链表不为空。 链表的结点总数不超过 30。 每个结点的值不是 0 就是 1。 解题思路采用位运算，result &lt;&lt; 1 就相当于 result * 2, result |= 1（result |= 0） 相当于 result++（不变） 代码1234567891011121314151617/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */int getDecimalValue(struct ListNode* head)&#123; struct ListNode* cur = head; int ans = 0; while (cur != NULL) &#123; ans = ans * 2 + cur-&gt;val; cur = cur-&gt;next; &#125; return ans;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环路检测]]></title>
    <url>%2F2020%2F02%2F29%2Falgorithm-linked-list-cycle-lcci%2F</url>
    <content type="text"><![CDATA[LeetCode 面试题 02.08. Linked List Cycle LCCI 题目描述给定一个有环链表，实现一个算法返回环路的开头节点。有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 解题思路经典的快慢指针问题，这里给出C的解法。 设置快慢指针 找到第一次相遇【快慢指针相遇】 再出发慢指针【从头结点出发的慢指针与快指针】 相遇即所求 代码123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode *detectCycle(struct ListNode *head) &#123; struct ListNode *slow = head, *fast = head; // 快慢指针 while (fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; // 如果相遇了就break if (slow == fast) break; &#125; // fast到了链表尾部,说明链表无环 if (fast == NULL || fast-&gt;next == NULL) return NULL; // 慢指针从头开始, 快慢指针再一次相遇就是在环的起点 slow = head; while (slow != fast)&#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重排链表]]></title>
    <url>%2F2020%2F02%2F29%2Falgorithm-reorder-list%2F</url>
    <content type="text"><![CDATA[LeetCode 143. Reorder List 题目描述 给定一个单链表 $L：L_0→L_1→…→Ln-1→L_n$ ，将其重新排列后变为： $L_0→L_n→L_1→Ln-1→L_2→Ln-2→…$ 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 解题思路 给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 通过观察，可以将重排链表分解为以下三个步骤： 首先重新排列后，链表的中心节点会变为最后一个节点。所以需要先找到链表的中心节点：876. 链表的中间结点 可以按照中心节点将原始链表划分为左右两个链表。 按照中心节点将原始链表划分为左右两个链表，左链表：1-&gt;2-&gt;3 右链表：4-&gt;5。 将右链表反转，就正好是重排链表交换的顺序，右链表反转：5-&gt;4。反转链表：206. 反转链表 合并两个链表，将右链表插入到左链表，即可重新排列成：1-&gt;5-&gt;2-&gt;4-&gt;3. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */// 1. 使用快慢指针,找出链表的中心节点struct ListNode* middleNode(struct ListNode* head)&#123; struct ListNode* fast = head, *slow = head; while(fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125;// 2. 通过递归反转链表struct ListNode* reverseList(struct ListNode* head)&#123; if(!head || !head-&gt;next) return head; struct ListNode *L = malloc(sizeof(struct ListNode)), *p; L-&gt;next = NULL; while(head != NULL) &#123; p = head-&gt;next; head-&gt;next = L-&gt;next; L-&gt;next = head; head = p; &#125; return L-&gt;next;&#125;// 3. 合并两个链表，将右链表插入到左链表void mergeList(struct ListNode* left, struct ListNode* right)&#123; struct ListNode *leftTemp, *rightTemp; // merge的循环时候条件应为: 当右链表为空的时候,就结束循环 // 原因是: // 1.你取了中心节点的next为右链表的head, 那么两者的长度一定是 左链表 &gt; 右链表 // 2. 当原始链表为: 奇数 左链表=右链表+1 ; 偶数 左链表=右链表+2 // 所以: 只用判断右链表的节点是否为空就可以了,而不用判断左链表. 左链表的next肯定有值. while(right != NULL)&#123; //1. 保存next节点 leftTemp = left-&gt;next; rightTemp = right-&gt;next; // 2. 将右链表的第一个节点插入到左链表中 // 左链表：1-&gt;2-&gt;3 右链表：5-&gt;4 // 合并后的左链表：1-&gt;5-&gt;2-&gt;3 left-&gt;next = right; right-&gt;next = leftTemp; // 3. 移动left和right指针 // 左链表变为：2-&gt;3 右链表变为：4 left = leftTemp; right = rightTemp; &#125;&#125;void reorderList(struct ListNode* head)&#123; if(!head || !head-&gt;next) return head; // 1. 使用快慢指针,找出链表的中心节点。 // 1-&gt;2-&gt;3-&gt;4-&gt;5,中心节点为3 struct ListNode *middle = middleNode(head); // 2. 将原始链表按照中心链表分割为两个链表，并将右链表反转 // 2.1 原始链表：1-&gt;2-&gt;3-&gt;4-&gt;5 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5 struct ListNode *left = head, *right = middle-&gt;next; middle-&gt;next = NULL; // 2.2 反转右链表 //原始右链表：4-&gt;5 反转后：5-&gt;4 right = reverseList(right); // 3. 合并两个链表，将右链表插入到左链表 // 左链表：1-&gt;2-&gt;3 右链表：4-&gt;5 合并后：1-&gt;5-&gt;2-&gt;4-&gt;3 mergeList(left, right);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表的中间结点]]></title>
    <url>%2F2020%2F02%2F29%2Falgorithm-middle-of-the-linked-list%2F</url>
    <content type="text"><![CDATA[LeetCode 876. Middle of the Linked List 题目描述给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 思路思路一先求出链表的长度 length，再进行计数遍历，遍历到 length / 2 为止，返回该结点。 代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */ int LinkLength(struct ListNode* head)&#123; int len = 0; while(head != NULL)&#123; head = head-&gt;next; len++; &#125; return len; &#125;struct ListNode* middleNode(struct ListNode* head)&#123; if(!head || !head-&gt;next) return head; int len = LinkLength(head); struct ListNode* p = head; for(int i = 0; i &lt; len / 2; i++)&#123; p = p-&gt;next; &#125; return p;&#125; 思路二设置快慢指针 fast，slow。其中 fast 的步长为 $2$，slow 的步长为 $1$，那么在相同时间的前提下 fast 走过的链表长度就是 slow 走过长度的两倍。当 fast 抵达链表末尾时，slow 恰好指向链表的中间结点，此时 return slow。 代码1234567891011121314151617/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* middleNode(struct ListNode* head)&#123; struct ListNode* fast = head, *slow = head; while (fast != NULL &amp;&amp; fast-&gt;next != NULL)&#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除链表的倒数第N个节点]]></title>
    <url>%2F2020%2F02%2F16%2Falgorithm-remove-nth-node-from-end-of-list%2F</url>
    <content type="text"><![CDATA[LeetCode 19. Remove Nth Node From End of List 题目描述给定一个链表，删除链表的倒数第 $n$ 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明： 给定的 $n$ 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路快慢指针，快指针先走n步，然后快慢一起走，直到快指针走到最后，要注意的是可能是要删除第一个节点，这个时候可以直接返回head -&gt; next 代码1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* removeNthFromEnd(struct ListNode* head, int n)&#123; if(!head || !head -&gt; next) return NULL; struct ListNode * fast = head, *slow = head; for(int i = 0; i &lt; n; i++)&#123; fast = fast -&gt; next; &#125; if(!fast)&#123; return head -&gt; next; &#125; while(fast -&gt; next)&#123; fast = fast -&gt; next; slow = slow -&gt; next; &#125; slow -&gt; next = slow -&gt; next -&gt; next; return head;&#125; 类似题目面试题22. 链表中倒数第k个节点题目描述输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2. 返回链表 4-&gt;5. 思路 + 代码与上面思路相同，使用快慢指针同步移动 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; */struct ListNode* getKthFromEnd(struct ListNode* head, int k)&#123; if(!head) return NULL; struct ListNode *fast = head, *slow = head; for(int i = 0; i &lt; k &amp;&amp; fast != NULL; i++)&#123; fast = fast-&gt;next; &#125; while(fast)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125; 面试题06. 从尾到头打印链表题目描述输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2]输出：[2,3,1] 思路 先得到链表head的长度len –&gt; 用来动态申请数组returnArray 遍历链表，把其中的元素赋值给数组returnArray 数组内部进行逆置 123456789101112131415161718192021222324252627282930313233343536/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * struct ListNode *next; * &#125;; *//** * Note: The returned array must be malloced, assume caller calls free(). */int* reversePrint(struct ListNode* head, int* returnSize)&#123; int len = 0, i=0; struct ListNode *p = head; while(p)&#123; len++; p=p-&gt;next; &#125; p = head; int *returnArray = (int *)malloc(len * sizeof(int)); while(p)&#123; returnArray[i++] = p-&gt;val; p = p-&gt;next; &#125; for(i=0;i&lt;len/2;i++)&#123; int temp = returnArray[i]; returnArray[i] = returnArray[len - i - 1]; returnArray[len - i - 1] = temp; &#125; (*returnSize) = len; return returnArray;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有序循环数组查找值]]></title>
    <url>%2F2020%2F02%2F12%2Falgorithm-ordering-and-circulate%2F</url>
    <content type="text"><![CDATA[有序循环数组查找指定值 题目描述一个有序循环数组array[]，不知其升序还是降序，也不知其起点在哪里。请编程寻找指定元素。 思路 先通过中间值和最后一个或者第一个元素比较，找出局部有序范围，再通过二分查找局部有序段 123456789101112131415161718int sortArrFindOne(int arr[], int low, int high, int target) &#123; int mid = (high + low) / 2; if(arr[mid] == target) return mid; if (arr[mid] &lt; arr[high]) &#123; if (arr[mid] &lt; target &amp;&amp; target &lt;= arr[high]) &#123; return find(arr, mid, high, target); &#125; else &#123; return sortArrFindOne(arr, low, mid, target); &#125; &#125; else &#123; if (arr[low] &lt;= target &amp;&amp; target &lt; arr[mid]) &#123; return find(arr, low, mid, target); &#125; else &#123; return sortArrFindOne(arr, mid, high, target); &#125; &#125;&#125; 找局部有序（二分递归查找）123456789int find(int arr[], int low, int high, int target) &#123; int mid = (high - low) / 2 + low; if (arr[mid] == target) return mid; if (arr[mid] &lt; target) &#123; return find(arr, mid + 1, high, target); &#125; else &#123; return find(arr, low, mid - 1, target); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反转字符串中的单词 III]]></title>
    <url>%2F2020%2F02%2F10%2Falgorithm-reverse-words-in-a-string-iii%2F</url>
    <content type="text"><![CDATA[From LeetCode 557. Reverse Words in a String III 题目描述给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: “Let’s take LeetCode contest”输出: “s’teL ekat edoCteeL tsetnoc”注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 思路误区第一眼看上去是反转字符串，而反转字符串的形式有所不同——并不是整体反转，而是单个单词进行反转，所有单词相对位置不变。(我第一次提交的时候没有注意到，因此有了以下代码)1234567891011char * reverseWords(char * s)&#123; int len = strlen(s); int i; char temp; for(i=0; i&lt;len/2; i++)&#123; temp = s[i]; s[i] = s[len-i-1]; s[len-i-1] = temp; &#125; return s;&#125; 此代码是反转整个字符串，与线性表的反转类似【见就地逆置线性表元素】 输入：”Let’s take LeetCode contest”输出：“tsetnoc edoCteeL ekat s’teL”预期：“s’teL ekat edoCteeL tsetnoc” 正确解题思路 记录s的长度len 若s为空或只有一个字符，则直接返回 否则 使用r记录翻转后的字符串，用start指向每一个单词的第一个字母，end指向该单词的最后一个字符（遇到空格或者结束符就停下） 将start到end之间的字符复制到r中 代码来源：LeetCode - kdurant 1234567891011121314151617181920char * reverseWords(char * s)&#123; int len = strlen(s) + 1, index = 0; if(len == 1 || len == 2) return s; char * r = (char *)malloc(len); char *start = s, *end; for(int i = 0; i &lt; len; i++, s++)&#123; if(*s == ' ' || *s == '\0')&#123; for(end = s - 1; end &gt;= start; end--)&#123; r[index++] = *end; &#125; r[index++] = (*s == ' ') ? ' ' : (*s = '\0'); start = s + 1; &#125; &#125; return r;&#125; 时间复杂度$O(n)$, 空间复杂度$O(n)$]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长子串]]></title>
    <url>%2F2020%2F02%2F09%2Falgorithm-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[LeetCode 3. Longest Substring Without Repeating Characters 题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 思路这道题主要用到思路是：滑动窗口 什么是滑动窗口？ 其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！ 如何移动？ 我们只要把队列的左边的元素移出就行了，直到满足题目要求！ 一直维持这样的队列，找出队列出现最长的长度时候，求出解！ 时间复杂度：$O(n)$ 图片来源：无重复字符的最长子串 c++实现三种解法 多重循环，hashmap优化，桶优化 滑动窗口题目 3. 无重复字符的最长子串 30. 串联所有单词的子串 76. 最小覆盖子串 159. 至多包含两个不同字符的最长子串 209. 长度最小的子数组 239. 滑动窗口最大值 567. 字符串的排列 632. 最小区间 727. 最小窗口子序列 代码1234567891011121314int lengthOfLongestSubstring(char * s)&#123; int size = strlen(s); int i=0, j, k, max = 0; for(j = 0; j &lt; size; j++) &#123; for(k = i;k&lt;j;k++) if(s[k] == s[j]) &#123; i = k+1; break; &#125; if(j - i + 1 &gt; max) max = j - i + 1; &#125; return max;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统、计算机网络、数据库系统概论等相关问题]]></title>
    <url>%2F2020%2F02%2F05%2Fos-network-db-questions%2F</url>
    <content type="text"><![CDATA[操作系统、计算机网络、数据库系统概论等相关问题 操作系统1. 中断和陷入有什么异同？ 外中断时指来自处理机和内存外部的中断,如I/O中断、定时器中断、外部信号中断等。狭义上也叫中断; 内中断主要指在处理机和内存内部产生的中断,也称陷入,如校验错、页面失效、溢出、除数为零等; 中断和陷阱的主要区别: (1) 陷入通常由处理机正在执行的现行指令引起,而中断则是由与现行指令无关的中断源引起的。 (2) 陷阱处理程序提供的服务为当前进程所用,而中断处理程序提供的服务则不是为了当前进程的。 (3) CPU在执行完一条指令之后,下一条指令开始之前响应中断,而在一条指令执行中也可以响应陷阱。 2. 父子进程是否可以并发运行？可以 3. 在没有程序运行时, CPU在做什么？只要计算机打开着，CPU一定都在不停处理进程。在Windows系统下至少rundll32.exe这个程序是持续运行的。在linux下kernel也是会持续运行的。运行进程个数为零的时候有没有呢？有，那就是计算机关机的时候。 4. 设备驱动器是否属于操作系统，它的作用是什么？不是，驱动程序是另外安装的软件，是操作系统控制并且和硬件之间通讯的桥梁（程序） 5. 线程、进程、程序和任务的区别? 任务是最抽象的， 是一个一般性的术语， 指由软件完成的一个活动。一个任务既可以是一个进程,也可以是一个线程。简而言之,它指的是一系列共同达到某一目的的操 作。例如,读取数据并将数据放入内存中。这个任务可以作为一个进程来实现,也可以作为一个线程（或作为一个中断任务）来实现。 进程常常被定义为程序的执行。可以把一个进程看成是一个独立的程序,在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。 线程则是某一进程中一路单独运行的程序。也就是说， 线程存在于进程之中。一个进程由一个或多个线程构成， 各线程共享相同的代码和全局数据， 但各有其自己的堆栈。由于堆栈是每个线程一个， 所以局部变量对每一线程来说是私有的。由于所有线程共享同样的代码和全局数据，它们比进程更紧密，比单独的进程间更趋向于相互作用,线程间的相互作用更容易些,因为它们本身就有某些供通信用的共享内存：进程的全局数据进程的全局数据进程的全局数据进程的全局数据 程序只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体。 6. 处理中断的过程请求中断→响应中断→关闭中断→保留断点→中断源识别→保护现场→中断服务子程序→恢复现场→中断返回 7. 分页、分段、段页式的特点，为什么要引入？分页是为了提高内存的利用率，提高计算机性能，且分页通过硬件机制来实现，对用户完全透明。分段是为了方便编程，信息保护和共享、动态增长及动态链接等多方面的需要。段页式是两者的结合。 8. 计算机系统怎样实现存储保护？ 防止地址越界（对进程所产生的地址必须加以检查，发生越界时产生中断，由操作系统进行相应处理） 防止操作越权（对属于自己区域的信息，可读可写：对公共区域中允许共享的信息或获得授权可使用的信息，可读而不可修改；对未授权使用的信息，不可读，不可写） 9. MMU 是 Memory Management Unit 的缩写，中文名是内存管理单元，它是中央处理器（CPU）中用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权。10. 多线程，真的提高了效率吗？多线程效率，我认为未必会高，而且有时候相反会低。多线程并不是为了提高效率，而是不必等待 可以并行执行多条数据。可以这么想：我们通过 xp 系统复制文件。你可以复制一份文件 这叫是单线呈，但是你要等这个复制完了才能复制另一份文件，而且不能多复制。这样很难受，所以你可以选择多复制文件,这就是多线程。但复制多份文件用的时间未必会比一份一份文件所用时间少。只是它合理利用了时间进行了多个操作。如果是买票系统 就会用到多线呈。买票是同时进行的，如果一个用户一个用户等下去不是办法，所以可以多个用户同时买票，效率也就提高了。这里的效率不是执行的效率 而是时间的合理利用,多个线呈同时进行。 11. 中断的作用中断是计算机系统结构一个重要的组成部分。在中断机制中的硬件部分(中断装置)的作用就是在 CPU 每执行完一条指令后，判别是否有事件发生，如果没有事件发生，CPU继续执行；若有事件发生，中断装置中断原先占用 CPU 的程序的执行，把被中断程序的断点保存起来，让操作系统的处理服务程序占用 CPU 对事件进行处理，处理完后，再让被中断的程序继续占用 CPU 执行下去。 12. DMA 的优先级为什么比 CPU 的优先级高？因为 DMA 请求得不到及时响应，I/O 传输数据可能会丢失 13. 虚拟内存容量由什么决定？虚拟存储区的容量与物理主存大小无关，而受限于计算机的地址结构和可用磁盘容量。 14. RAID 的工作原理RAID（独立磁盘冗余阵列（Redundant Array of Independent Disks））通过条带化存储和奇偶校验两个措施来实现其冗余和容错的目标。条带化存储意味着可以一次写入一个数据块的方式将文件写入多个磁盘。条带化存储技术将数据分开写入多个驱动器，从而提高数据传输速率并缩短磁盘处理总时间。这种系统非常适用于交易处理、但可靠性却很差，因为系统的可靠性等于最差的单个驱动器的可靠性。奇偶校验通过在传输后对所有数据进行冗余校验可以确保数据的有效性。利用奇偶校验，当 RAID 系统的一个磁盘发生故障时，其它磁盘能够重建该故障磁盘。在这两种情况中，这些功能对于操作系统都是透明的。由磁盘阵列控制器（DAC）进行条带化存储和奇偶校验控制。 计算机网络1. 计算机网络和分布式计算机系统的区别?两者在计算机硬件连接、系统拓朴结构和通信控制等方面基本都是一样的,它们都具有通信和资源共享的功能。区别关键在于:分布式计算机系统是在分布式计算机操作系统支持下,进行分布式数据库处理的,也就是说各互联的计算机可以互相协调工作,共同完成一项任务,多台计算机上并行运行。且具有透明性,用户不知道数据、资源的具体位置,整个网络中所有计算机就像是一台计算机一样;而计算机网络却不具备这种功能,计算机网络系统中的各计算机通常是各自独立进行工作的。 2. 波特和比特的区别?波特是码元传输的踵率单位,说明每秒传多少个码元。码元传输速率也称为调制速率、波形速率或符号速率。比恃是信息量的单位,与码元的传输速率”波特”是两个完全不同的概念。但是,信息的传输速率”比特/秒”与码元的传输速率”波特”在数量上却有一定的关系。 3. TCP/IP网络协议核心以及如何引出overeverythingTCP/IP（传输控制协议/网间协议）是一种网络通信协议，它规范了网络上的所有通信设备，尤其是一个主机与另一个主机之间的数据往来格式以及传送方式。TCP/IP是INTERNET的基础协议，也是一种电脑数据打包和寻址的标准方法。核心是OSI模型，共七层，第7层应用层，第6层表示层，第5层会话层，第4层传输层，第3层网络层，第2层数据链路层，第1层物理层，从第七层传到第一层，接受方则相反。 上三层总称应用层，用来控制软件方面。 下四层总称数据流层，用来管理硬件。everything over IP：everything均以IP为基础，以后的网络中的设备都用IP（现在的电话网络就不是）。over：以…为基础。IP over everything：在现在的电通信网过渡到光通信网的过程中，IP、ATM、WDM会配合使用，渐渐过渡，既是IP over everything。over：凌驾于…之上。 4. 电路交换与分组交换区别 电路交换是以电路为目的的交换方式，即通信双方要通过电路建立联系，建立后没挂断则电路一直保持，实时性高。 而分组交换是把信息分为若干分组，每个分组有分组头含有选路和控制信息，可以到达收信方，但是不能即时通信。 分组交换通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。 电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。 分组交换由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。 电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用低。 若要传送的数据量很大，且其传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。 5. IPV4 和 IPV6 的区别（1）IPV6 地址长度为 128 比特，地址增大了 296 倍；（2）灵活的 IP 报文头部格式。使用一系列固定格式的扩展头部取代了 IPV4 中可变长度的选项字段。IPV6 中选项部分的出现方式也有所变化，使路由器可以简单路过选项而不做任何处理，加快了报文处理速度。（3）IPV6 简化了报文头部格式，字段只有 7 个，加快报文转发，提高了吞吐量；（4）提高安全性。身份认证和隐私权是 IPV6 的关键特性。（5）支持更多的服务类型；（6）允许协议继续演变，增加新的功能，使之适应未来技术的发展。 6. TCP 的拥塞控制与流量控制的功能和区别？1拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。2流量控制：指点对点通信量的控制，是端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收. 7. 集线器,路由器和交换机有什么区别.集线器工作在第一层（即物理层），它没有智能处理能力，对它来说，数据只是电流而已，当一个端口的电流传到集线器中时，它只是简单地将电流传送到其他端口，至于其他端口连接的计算机接收不接收这些数据，它就不管了。交换机工作在第二层（即数据链路层），它要比集线器智能一些，对它来说，网络上的数据就是 MAC 地址的集合，它能分辨出帧中的源 MAC 地址和目的 MAC 地址，因此可以在任意两个端口间建立联系，但是交换机并不懂得 IP 地址，它只知道 MAC 地址。路由器工作在第三层（即网络层），它比交换机还要“聪明”一些，它能理解数据中的 IP 地址，如果它接收到一个数据包，就检查其中的 IP地址，如果目标地址是本地网络的就不理会，如果是其他网络的，就将数据包转发出本地网络。 8. P2P 网络编程的特点P2P（对等网络，是一种有别于传统 C/S 客户/服务器式的分布式网络）直接将人们联系起来，让人们通过互联网直接交互。P2P 使得网络上的沟通变得容易、更直接共享和交互，真正地消除中间商。P2P 就是人可以直接连接到其他用户的计算机、交换文件，而不是像过去那样连接到服务器去浏览与下载。 9. DNS 的递归查询与迭代查询 递归查询: 一般客户机和服务器之间属递归查询，即当客户机向 DNS 服务器发出请求后,若 DNS 服务 器本身不能解析,则会向另外的 DNS 服务器发出查询请求，得到结果后转交给客户机； 迭代查询(反复查询): 一般 DNS 服务器之间属迭代查询，如：若 DNS2 不能响应 DNS1 的请求，则它会将 DNS3 的 IP 给 DNS2，以便其再向 DNS3 发出请求； 10. ARP 协议的过程ARP 协议是“Address Resolution Protocol”（地址解析协议）的缩写。在局域网中，网络中实际传输的是“帧”，帧里面是有目标主机的 MAC 地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的 MAC 地址。但这个目标 MAC 地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是主机在发送帧前将目标 IP 地址转换成目标 MAC 地址的过程。 ARP 协议的基本功能就是通过目标设备的 IP 地址，查询目标设备的 MAC 地址，以保证通信的顺利进行。 11. 计算机网络的接入类型都有哪些？局域网、城域网、广域网和互联网四种 12. 中继器，集线器，交换机，网桥，网关，路由器的功能作用,区别到底是什么？中继器： 物理层， 适用于完全相同的两类网络的互连，主要功能是通过对数据信号的重新发送或者转发，来扩大网络传输的距离。集线器：物理层，基本功能信息分发，它把一个端口接收的所有信号向所有端口分发出去。一些集线器在分发之前将弱信号重新生成。中继器与集线器的区别：区别在于集线器能够提供多端口服务，也称为多口中继器。网桥：数据链路层， 网桥（Bridge）像一个聪明的中继器， 网桥是一种对帧进行转发的技术，根据 MAC 分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来。 数据库系统概论1. 数据库安全性与操作系统安全性的关系?安全性问题不是数据库系统所独有的,所有计算机系统都有这个问题.只是在数据库系统中大量数据集中存放,而且为许多最终用户直接共享,从而使安全性问题更为突出.系统安全保护措施是否有效是数据库系统的主要指标之一.数据库的安全性和计算机系统的安全性,包括操作系统,网络系统的安全性是紧密联系,相互支持的 2. SQL 主键约束和唯一约束有什么区别呢？主键不能为空而唯一可以为空相同的就是都不允许重复 3. 什么是基本表？什么是视图？两者的区别和联系是什么？表是实实在在得保存数据的实体,写入的数据都保存在表中,而视图 是不保存数据的,也没有数据.视图就是一条 语句,实际上视图从表中去数据.只是给我们的感觉好像直接从表中 取得一样. 表可以建立各种触发器,可以建立索引,可以建立主健,约束等. 但是视图不能建立这些对象( 视图可以建立替代触发器) . 表和视图可以更新, 但是视图的更新受到约束. 比如,group by 和表连接生成的视图不能更新表是实实在在得 保存数据的实体, 写入的数据都保存在表中, 而视图是不保存数据的, 也没有数据. 4. 数据库索引目的：提供多种存储路径，加快查找速度。建立索引需要考虑的问题： 1.没有查询、统计的需要则不建 2.数据增删改频繁，系统会花费许多时间来维护索引，从而降低了查询效率。 5. 哪些视图是可以更新、哪些是不可以更新的 简单视图就是由一个表生成出来的视图，这种情况你更新她就和更新表一样。 二次加工出来的简单视图仍然是一个表出来的视图，但是视图中存在通过函数或计算二次加工出来的其他字段。更新的时候只要不更新这些加工出来的字段也是可以更新的。 组合视图通过表之间关联联合等出来的复杂视图。这种视图更新的时候要注意你所更新的列要来自同一个表，也是可以更新的。 静态视图这种视图等同于表可以直接更新，但是更新的数据尽在视图中反映出来，不反映到原表。 其他视图通过表函数等其他生成的更为复杂的视图。一般不可更新。]]></content>
      <categories>
        <category>计算机操作系统</category>
        <category>计算机网络</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
        <tag>计算机网络</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复试英语口语]]></title>
    <url>%2F2020%2F02%2F02%2FEnglish-speaking-test%2F</url>
    <content type="text"><![CDATA[~2020.02.02~ (1). self-introduction (自我介绍)Good morning, my dear teachers and professors. I am very happy to introduce myself. I am 陈琪, a 22-year-old boy graduated from Chongqing University of Posts and Telecommunications. My major was Computer Science and Technology. And I am very kind-hearted as well and ready to help others especially when they are in troubles. Owing to my kindness I made a lot of friends in university. In my spare time I like sports such as Ping-pong .I also took some part-time jobs as a family tutor. One of my students got his mark improved through our joint effort and I was very proud of that.This is all for my self-introduction. If I am lucky enough to get the chance, I will devote all myself to my major and focus all of my energy on it. (2). reasons for my choice (考研原因)Firstly, I think my major is very practical and useful. Through four years’study in university I find the knowledge I have mastered is not enough to solve some specific problems. So I decide to further my education.Secondly,I can broaden my horizon and enrich the knowledge in this field through the postgraduate education. It is an indispensable step for my self-development in the future as well. (3). plans in the postgraduate study (研究生期间你的计划)Because my dream is to be a scientist , so i want to further my study when i become postgraduate. May be i will be a teacher in the university at first.That’s my simple plan. (4). about hometown (介绍你的家乡)I come from ZiGong of Sichuan province,which is famous for its salt industry and dinosaur fossils.Known as home of dinosaur. What’s more? It is also a city of lights. Every year,there are a lot of tourist traveling here. (5). about family (你的家庭)I have a happy family .In my family, there are five members: grandfather, father, mother.My family is just like a hand, and each of us like a finger.Mother worker, Father teacher. They love me ,we live harmoniously. (6). about university (你的大学)My university is Chongqing university of Post and Telecommunication .it has digital libraries and labs. My university is famous for its 3G research and it is located in a small mountain which is beautiful and full of cherry blossom.There a fresh airs and warm atmosphere. (7). plans after graduation (毕业后有什么打算)After my graduation, I want to find a job in Chengdu and make good use of the theories I will have learned from this university.I want to become a teacher of university or a scientist .if possible ,After graduation, I want to further my study for a Doctor’s degree. Then I’ll work for a research institute. What satisfies me most is to make contributions for the whole earth. (8).What is your greatest strength? (你最突出的优点是什么？)I am good at math and programming, because i can solve a problem by myself independent and improve in a short time without others’ help. 要求重复询问Sorry, I did not catch/follow your meaning. Pardon, please.]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中变量存储位置]]></title>
    <url>%2F2020%2F02%2F01%2FC-variable-storage-2%2F</url>
    <content type="text"><![CDATA[局部变量、静态局部变量、静态全局变量… 一、C语言中，常量存储在哪儿？static全局变量和static局部变量存储在哪儿？全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于 非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的，而静态全局变量则限制了其作用域。即只在定义该变量的源文件内有效， 在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。 二、static全局变量与普通的全局变量有什么区别？ static全局变量只初始化一次，防止在其他文件单元中被是引用。 三、static局部变量与普通的局部变量有什么区别？ static局部变量只被初始化一次，下一次依据上一次结果值。 四、局部变量、静态局部变量、静态全局变量存储位置 变量类型 存储位置 局部变量 静态区（全局区） 局部静态变量 静态区（全局区）的常量区 全局静态变量 静态区（全局区） 五、各存储区的定义 栈区（stack） —— 由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。 堆区（heap） —— 一般由程序员分配释放。若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 全局区（静态区）（static） —— 全局变零和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，- 程序结束后由系统释放。 文字常量区 —— 常量字符串就是放在这里的。- 程序结束后由系统释放。 程序代码区 —— 存放函数体的二进制代码。 六、NOTES 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由应用程序控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。 自由存储区，就是那些由malloc分配的内存块，它和堆十分相似，不过它是用free来结束自己的生命。 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分，它们共同占用一块内存区。 常量存储区，这是一块比较特殊的存储区，它们存放的是常量，不允许被修改。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言效率问题]]></title>
    <url>%2F2020%2F01%2F31%2FC-efficiency%2F</url>
    <content type="text"><![CDATA[来源：UESTC考研群 编译器可以将代码编译为汇编语言，然后转换为机器语言，并且编译器可以在编译时进行优化，例如gcc可以进行五级优化 采用宏去定义一些函数，提高效率 比如#define MAX(x,y) ((x)&gt;(y)?(x):(y)) 可以使用位操作来替代乘法除法 比如计算机网络中进行CRC检验 可以在程序效率低的地方嵌入汇编语言提高程序效率 可以使用指针直接操作内存，提高效率 可以使用内联函数（C99标准添加，之前宏定义） 可以使用寄存器变量（register），提高变量存取速度 复合的赋值运算符的使用，比如i-=1效率大于i=i-1，可以提高程序的编译效率 自增自减运算符的使用，比如i++和i–]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针与自增优先级的问题]]></title>
    <url>%2F2020%2F01%2F29%2FC-pointer-and-increase%2F</url>
    <content type="text"><![CDATA[在我们面试时，经常会有一些关于运算符优先级的题目，今天就给大家展示一个常出现的例子。问题：定义一个数组 int a[10]={1,2,3,4,5,6,7,8,9,0}; int *p=a; 则 cout&lt;&lt;*p++&lt;&lt;endl; 由此问题我们可以看出来，其想考察的是C++程序设计的运算符的优先级以及后自增的知识点。我们查看优先级表格表格可以得到后自增（++）运算符优先于取值运算符（*），因此（*p++）等价于(*(p++))。 求值顺序得到了，我们下面的任务就是要分析后自增的实现原理了，我们参考了《C++ primer 第五版》（503页）讲解的知识如下： 123456789strBlobPtr strBlobPtr::operator++(int) &#123; /*strBlobPtr为定义的一个类名，operator++（int）为重载后自增运算符，参数int为区分前自增还是后自增*/ strBlobPtr ret =*this; ++*this; return ret; &#125; 我们发现，在后自增的运算符实现的步骤中，先返回值，再自增，因此（*p++）计算过程为先运算p++（结果为p指向的地址a）,再对指针求值*p,得到a[0].123456789#include&lt;iostream&gt;using namespace std;int main() &#123; int a[10] = &#123;1,2,3,4,5,6,7,8,9,0&#125;; int *p=a; cout &lt;&lt; "*p:" &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; "*p++:" &lt;&lt; *p++ &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中变量存储类型和生存周期]]></title>
    <url>%2F2020%2F01%2F28%2FC-variable-storage%2F</url>
    <content type="text"><![CDATA[内容来自谭浩强的《C语言程序设计》总结 原文链接：https://blog.csdn.net/wuyuzun/article/details/82432355 几个重要概念 数据类型：浮点型，整型，字符型等都是一个数据类型； 数据存储类型：数据在内存中的存储方式；（这是本博文要讨论的重点）注意：数据类型和数据存储类型都是针对于声明或定义的函数和变量而言的； 动态存储类型：变量或函数，在被使用时临时分配内存单元，在函数结束后所占用的内存单元将会被释放，例如局部变量；因此，动态存储的变量每次被调用时所占的内存单元的地址可能会发生改变； 静态存储类型：变量或函数，在程序运行期间编译器统一分配内存单元，直到程序结束分配的内存才被释放；例如：全局变量； 内存中供用户使用的存储空间 用户区 存储内容 程序区 CPU指令 静态存储区 全部的全局变量，局部静态变量 动态存储区 被调用函数的形参；被调用函数中非局部静态变量；函数调用时的现场保护和返回地址等 注： 在平时编程过程中，一般对变量和函数的声明和定义都应同时指定数据类型和数据存储类型；如果我们没有对变量进行指定数据存储类型； 在定义全局变量和局部静态变量时，如果没有赋初始值，系统会默认为0；而动态变量们竟会被随机赋值； 局部变量的存储类型1. 自动变量—auto定义：函数中，包括复合语句内和形式参数在内的变量中，不被static限制的变量； 性质：动态存储类型，系统调用函数时临时分配内存单元；函数执行结束就占用的内存释放；12345678910111213141516171819#include &lt;stdio.h&gt;int fun1(int a);void main()&#123; for(int i=0;i&lt;5;i++) printf("%d\n",fun1(5));&#125;int fun1(int a) //形式参数&#123; auto int b = 0; //函数内不被static限制,且函数每次被调用，b的值都会被赋0； b++; &#123; int c; //函数内复合语句内； &#125; return b;&#125; 运行结果： 注：大多数情况下，自动变量是可以直接省略auto的，系统也会默认为自动变量； 2. 静态局部变量—static定义：函数内被静态static限制的局部变量；静态局部变量在函数执行结束时，内存不被释放，函数下次被执行的时候，此变量的值并不改变； 性质：静态存储类型，函数每次被调用其值还是上次函数执行时的值，且默认的初始化的值是$0$； 举例：1234567891011121314151617#include &lt;stdio.h&gt;int fun1(int a);void main()&#123; for(int i=0;i&lt;5;i++) printf("%d\n",fun1(5));&#125;int fun1(int a)&#123; static int b=a; //第一次执行函数后被b被赋初值， //以后再执行函数后b将不会再被赋值； b--; return b;&#125; 输出结果： 3. 寄存器变量—register变量定义：存放在CPU寄存器中的变量；（寄存器存储类型也是随着函数的结束，内存被释放） 形式：register int a = 1; \将定义的a送到寄存器中； 说明：寄存器这个名词如果是学过单片机的同志肯定是知道的，对于单片机功能的实现，基本上都是靠配置寄存器实现的；寄存器是什么，参考《存储器》； 性质：CPU能够快速读写寄存器变量； 优点：一般来说，程序中定义，声明的变量是放在内存中的，例如全局变量存储在静态存储器中，对一个全局变量的每次读写操作都是CPU和内存之间的传输；但是寄存器变量是把变量存储在CPU的寄存器中，由于寄存器的读写传输速度很快，所以非常适合处理一些程序中被高频使用的变量； 缺点：CPU寄存器数量有限，不适合定义太多寄存器变量； 注意：目前计算器处理速度越来越快，加上C语言IDE对于代码的优化越来越好，所以有时即使我们不去定义或声明一个寄存器变量，IDE也会把高频使用的变量默认声明为寄存器变量；所以在平时的编程时，并不用过于强调寄存器变量。 全局变量的存储类型外部变量：定义在函数外的变量，也可以说就是全局变量； 全局变量的有效域：自定义处起以下范围； 举例：123456789101112#include &lt;stdio.h&gt;void main() //全局变量a不被main()函数调用；&#123;&#125;int a=10; //全局变量avoid fun1() //全局变量a可以被fun1()调用；&#123;&#125; 1. 同文件内扩展外部变量的作用域 — extern举例：12345678910#include &lt;stdio.h&gt;extern int a; void main() //全局变量a不被main()函数调用；&#123;&#125;int a=10; //全局变量avoid fun1() //全局变量a可以被fun1()调用；&#123;&#125; 在第二行语句以下的函数都可以调用变量a；外部变量声明也可以写成：“extern a”这种形式，因为a已经是已经定义过的变量；注意：extern并不是定义变量，而是声明变量，这个关键字就是为了告诉编译器：本文件中已经定义这个变量； 2. 将外部变量的作用域扩展到其他文件–extern怎样扩展：一个大的程序往往是由许多源文件和头文件组成，当不同文件要引用同一个外部变量时，方法是：在任意一个文件中定义外部变量，而在另一个文件中用extern对其进行“外部变量声明”；这样，在编译连接时编译器好知道这个变量来自于其他位置；如果说两个文件同时用了定义了相同名字的外部变量，那编译器连接时会报错； 扩展的方式：当程序进行编译的时候，编译器遇到extern所声明的变量后，编译器会现在本文件中寻找此变量，如果找到了，就在此处扩展有效域，如果找不到，会进入其他文件进行寻找，找到后将有效域扩展其他文件，如果还找不到就按错误处理； 3. 静态外部（全局）变量–static定义：定义在函数外部的静态变量； 优点：被static限制的外部变量，编译时不会被其他文件发现，即使不同文件之间有同名的现象也没关系；如果确定一个外部变量不被其他文件引用，就可以直接加static，这一点很符合C语言模块化的思想，也提高了程序的可移植性； 举例：123456#include &lt;stdio.h&gt;static int a; //静态全局变量，只能在本文件中被调用；如果在其他文件被调用将会报错；void main()&#123;&#125; 所以：对于static来说，静态局部变量说明的是此变量的生存期；静态外部变量说明的是此变量的作用域； 三个概念：生存期：一个变量值在某一时刻是存在的，则这个时期就是这个变量的生存期；作用域：一个变量在某个文件或函数范围内是有效的，则这个范围就是这个变量的作用域；可见性：在一个变量的作用域可以引用该变量，则说这个变量在这个作用域是可见的，这么一个性质就是可见性； 总结 存储类型（即存储类型关键字）是数据在内存中的存储方式，有四种：auto，static，extern，register。 auto和register用于声明内部变量，auto变量存储在栈中；extern用于声明外部变量，static用于声明内部和外部变量，extern和static变量存储在静态存储区中。内部变量默认是auto类型，外部变量默认是extern类型。 C语言中，常量存储在常量区，该区数据可读不可写。static全局变量和static局部变量都存储在全局数据区。 C语言中，除了关键字，还有单词类型（语法符号）：标识符、运算符、分隔符、常量、注释符。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找算法细节详解]]></title>
    <url>%2F2020%2F01%2F27%2Falgorithm-binary-search%2F</url>
    <content type="text"><![CDATA[From LeetCode 34. Find First and Last Position of Element in Sorted Array 作者：labuladong链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/来源：力扣（LeetCode） 思路我相信对很多读者朋友来说，编写二分查找的算法代码属于玄学编程，虽然看起来很简单，就是会出错，要么会漏个等号，要么少加个 1。 不要气馁，因为二分查找其实并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的： Although the basic idea of binary search is comparatively straightforward,the details can be surprisingly tricky… 这句话可以这样理解：思路很简单，细节是魔鬼。 本文以问答的形式，探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。第一个场景是最简单的算法形式，解决 这道题，后两个场景就是本题。 而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。 零、二分查找框架123456789101112131415int binarySearch(int[] nums, int target) &#123; int left = 0, right = ...; while(...) &#123; int mid = (right + left) / 2; if (nums[mid] == target) &#123; ... &#125; else if (nums[mid] &lt; target) &#123; left = ... &#125; else if (nums[mid] &gt; target) &#123; right = ... &#125; &#125; return ...;&#125; 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。 其中 ... 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。 另外声明一下，计算 mid 时需要技巧防止溢出，即 mid=left+(right-left)/2。本文暂时忽略这个问题。 一、寻找一个数（基本的二分搜索）这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。 123456789101112131415int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; // 注意 while(left &lt;= right) &#123; int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; // 注意 else if (nums[mid] &gt; target) right = mid - 1; // 注意 &#125; return -1;&#125; 为什么 while 循环的条件中是 &lt;=，而不是 &lt; ？ 答：因为初始化 right 的赋值是 nums.length-1，即最后一个元素的索引，而不是 nums.length。 这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。 我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」。 什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：12if(nums[mid] == target) return mid; 但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。 while(left &lt;= right) 的终止条件是 left == right + 1，写成区间的形式就是 $[right + 1, right]$，或者带个具体的数字进去 $[3, 2]$，可见这时候搜索区间为空，因为没有数字既大于等于 $3$ 又小于等于 $2$ 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。 while(left &lt; right) 的终止条件是 left == right，写成区间的形式就是 $[left, right]$，或者带个具体的数字进去 $[2, 2]$，这时候搜索区间非空，还有一个数 $2$，但此时 while 循环终止了。也就是说这区间 $[2, 2]$ 被漏掉了，索引 $2$ 没有被搜索，如果这时候直接返回 $-1$ 就是错误的。 当然，如果你非要用 while(left &lt; right) 也可以，我们已经知道了出错的原因，就打个补丁好了：12345//...while(left &lt; right) &#123; // ...&#125;return nums[left] == target ? left : -1; 为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？ 答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。 刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 $[left, right]$。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？ 当然是 $[left, mid - 1]$ 或者 $[mid + 1, right]$ 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。 此算法有什么缺陷？ 答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。 比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 $2$，没错。但是如果我想得到 target 的左侧边界，即索引 $1$，或者我想得到 target 的右侧边界，即索引 $3$，这样的话此算法是无法处理的。 这样的需求很常见。你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。 我们后续的算法就来讨论这两种二分查找的算法。 二、寻找左侧边界的二分搜索直接看代码，其中的标记是需要注意的细节： 1234567891011121314151617int left_bound(int[] nums, int target) &#123; if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left &lt; right) &#123; // 注意 int mid = (left + right) / 2; if (nums[mid] == target) &#123; right = mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid; // 注意 &#125; &#125; return left;&#125; 为什么 while(left &lt; right) 而不是 &lt;= ? 答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1 。因此每次循环的「搜索区间」是 [left, right) 左闭右开。 while(left &lt; right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？ 答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义： 对于这个数组，算法会返回 $1$。这个 $1$ 的含义可以这样解读：nums 中小于 $2$ 的元素有 $1$ 个。 比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 $0$，含义是：nums 中小于 $1$ 的元素有 $0$ 个。 再比如说 nums 不变，target = 8，算法会返回 $4$，含义是：nums 中小于 $8$ 的元素有 $4$ 个。 综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 $[0, nums.length]$，所以我们简单添加两行代码就能在正确的时候 return -1： 1234567while (left &lt; right) &#123; //...&#125;// target 比所有数都大if (left == nums.length) return -1;// 类似之前算法的处理方式return nums[left] == target ? left : -1; 为什么 left = mid + 1，right = mid ？和之前的算法不一样？ 答：这个很好解释，因为我们的「搜索区间」是 $[left, right)$ 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 $[left, mid)$ 或 $[mid + 1, right)$。 为什么该算法能够搜索左侧边界？ 答：关键在于对于 nums[mid] == target 这种情况的处理：12if (nums[mid] == target) right = mid; 可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 $[left, mid)$ 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。 可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 $[left, mid)$ 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。 为什么返回 left 而不是 right？ 答：都是一样的，因为 while 终止的条件是 left == right。 三、寻找右侧边界的二分查找寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注：12345678910111213141516int right_bound(int[] nums, int target) &#123; if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left &lt; right) &#123; int mid = (left + right) / 2; if (nums[mid] == target) &#123; left = mid + 1; // 注意 &#125; else if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid; &#125; &#125; return left - 1; // 注意&#125; 为什么这个算法能够找到右侧边界？ 答：类似地，关键点还是这里： 12if (nums[mid] == target) &#123; left = mid + 1; 当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。 为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。 答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。 至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断： 123if (nums[mid] == target) &#123; left = mid + 1; // 这样想: mid = left - 1 因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。 至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。 为什么没有返回 $-1$ 的操作？如果 nums 中不存在 target 这个值，怎么办？ 答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 $[0, nums.length]$，所以可以添加两行代码，正确地返回 $−1$： 12345while (left &lt; right) &#123; // ...&#125;if (left == 0) return -1;return nums[left-1] == target ? (left-1) : -1; 四、最后总结来梳理一下这些细节差异的因果逻辑： 第一个，最基本的二分查找算法：1234567因为我们初始化 right = nums.length - 1所以决定了我们的「搜索区间」是 [left, right]所以决定了 while (left &lt;= right)同时也决定了 left = mid+1 和 right = mid-1因为我们只需找到一个 target 的索引即可所以当 nums[mid] == target 时可以立即返回 第二个，寻找左侧边界的二分查找：12345678因为我们初始化 right = nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left &lt; right)同时也决定了 left = mid + 1 和 right = mid因为我们需找到 target 的最左侧索引所以当 nums[mid] == target 时不要立即返回而要收紧右侧边界以锁定左侧边界 第三个，寻找右侧边界的二分查找：1234567891011因为我们初始化 right = nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left &lt; right)同时也决定了 left = mid + 1 和 right = mid因为我们需找到 target 的最右侧索引所以当 nums[mid] == target 时不要立即返回而要收紧左侧边界以锁定右侧边界又因为收紧左侧边界时必须 left = mid + 1所以最后无论返回 left 还是 right，必须减一 如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。 通过本文，你学会了： 分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。 注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。 如需要搜索左右边界，只要在nums[mid] == target 时做修改即可。搜索右侧时需要减一。 以后就算遇到其他的二分查找变形，运用这几点技巧，也能保证你写出正确的代码。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合并有序线性表]]></title>
    <url>%2F2020%2F01%2F26%2Falgorithm-merge-list%2F</url>
    <content type="text"><![CDATA[LeetCode 21. Merge Two Sorted Lists &amp; 88. Merge Sorted Array 合并两个有序链表题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素终止条件：两条链表分别名为l1和l2，当l1为空或l2为空时结束返回值：每一层调用都返回排序好的链表头本级递归内容：如果l1的$val$值更小，则将l1-&gt;next与排序好的链表头相接，l2同理$O(m+n)$，m为l1的长度，n为l2的长度 画解 作者：guanpengchn 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/ 来源：力扣（LeetCode） 12345678910111213struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)&#123; if(l1 == NULL) return l2; if(l2 == NULL) return l1; if(l1-&gt;val &lt;= l2-&gt;val)&#123; l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; &#125; else &#123; l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; &#125;&#125; 合并两个有序数组题目描述给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 思路因为nums1的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去设置指针len1和len2分别指向nums1和nums2的有数字尾部，从尾部值开始比较遍历，同时设置指针len指向nums1的最末尾，每次遍历比较值大小之后，则进行填充当len1 &lt; 0时遍历结束，此时nums2中海油数据未拷贝完全，将其直接拷贝到nums1的前面，最后得到结果数组时间复杂度：$O(m+n)$ 画解 12345678910111213141516// 作者：guanpengchn// 链接：https://leetcode-cn.com/problems/merge-sorted-array/solution/hua-jie-suan-fa-88-he-bing-liang-ge-you-xu-shu-zu-/// 来源：力扣（LeetCode）class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int len1 = m - 1; int len2 = n - 1; int len = m + n - 1; while(len1 &gt;= 0 &amp;&amp; len2 &gt;= 0) &#123; // 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码 nums1[len--] = nums1[len1] &gt; nums2[len2] ? nums1[len1--] : nums2[len2--]; &#125; // 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1 System.arraycopy(nums2, 0, nums1, 0, len2 + 1); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复试笔试C语言重要简答题]]></title>
    <url>%2F2020%2F01%2F25%2Falgorithm-short-answers-about-C%2F</url>
    <content type="text"><![CDATA[来源：UESTC考研群 从C语言执行效率方便，简述下C语言采取了哪些措施提高执行效率。 使用指针：有些程序用其他语言也可以实现，但C能够更有效地实现；有些程序无法用其它语言实现，如直接访问硬件，但C却可以。正因为指针可以拥有类似于汇编的寻址方式，所以可以使程序更高效。 使用宏函数：宏函数仅仅作为预先写好的代码嵌入到当前程序，不会产生函数调用，所以仅仅是占用了空间，而使程序可以高效运行。在频繁调用同⼀个宏函数的时候，该现象尤其突出。函数和宏函数的区别就在于，宏函数占用了大量的空间，而函数占用了时间。 宏函数的例子：1234567#include &lt;stdio.h&gt;#define MAX(a,b) (a &gt; b ? a : b)int main() &#123; int maxNum = MAX(5, 6); printf("The max num is : %d\n", maxNum); return 0;&#125; 使用位操作：位操作可以减少除法和取模的运算。在计算机程序中数据的位是可以操作的最小数据单位，理论上可以用“位运算”来完成所有的运算和操作。灵活的位操作可以有效地提高程序运行的效率。 循环嵌套中将较长循环设为内置循环，较短循环设为外置循环，以减少cpu跨切循环层的次数，提高程序的运行效率。(操作系统页面置换相关，减少页面置换次数) 将汇编指令嵌入到C语言程序中，汇编语言是效率最高的计算机语言，因此为了获得程序的高效率，可以在C语言程序中嵌入汇编，从而充分利用高级语言和汇编语言各⾃的特点。 在C语言程序中可以调用系统API，接近底层，从而提高程序的运行效率。 ⼀般情况下，C语言源程序中的每⼀行代码都要参加编译。但有时候出于对程序代码优化的考虑，希望只对其中⼀部分内容进行编译，此时就需要在程序中加上条件，让编译器只对满足条件的代码进行编译，将不满足条件的代码舍弃，这就是条件编译。 请简述C语言的隐式类型转换发生的四种情况，并说明每种情况如何转换。（注：这里面还有个小题，float如何四舍五入转化成int） 算术运算式中，低类型能够转换为高类型（自动类型转换）。 赋值表达式中，右边表达式的值⾃动隐式转换为左边变量的类型，并赋值给它。 函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。 函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋给调用函数。 小题：float如何四舍五入转化成int1234567#include &lt;stdio.h&gt;int main() &#123; float f = 0.5; int i = (int)(f + 0.5); printf("%d\n", i); return 0;&#125; 数组越界会产生什么后果？越界访问有可能把数据放到已经存储了重要数据的内存单元，也就是改写了本来不许改写的数据，如果这个数据是系统的重要数据，有可能导致系统运行紊乱甚至是崩溃。当然如果这个数据并不重要，那么越界访问的后果就不明显或者是没有影响。避免的方法是对数组的下标严格检测，判断组数下标是否越界，用指针访问数组时要注意判断指针的指向是否已超过数组下标的最大值。 值传递和地址传递值传递被调函数的形参作为被调函数的局部变量处理，即在内存的堆栈中开辟空间以存放由主调函数放进来的实参的值，从而成为了实参的一个拷贝。其特点是被调函数对形参的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。 地址传递被调函数的形参虽然也作为局部变量在堆栈中开辟了内存空间，但是这是存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 C语言中，常量存储在哪里？静态局部变量和静态全局变量存储在哪里？ 类型 存储位置 常量 常量区 静态局部变量 全局数据区 静态局部变量 全局数据区]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[删除排序数组中的重复项与移除元素]]></title>
    <url>%2F2020%2F01%2F24%2Falgorithm-remove-elements%2F</url>
    <content type="text"><![CDATA[LeetCode 26. Remove Duplicates from Sorted Array &amp; 27. remove elements 删除排序数组中的重复项题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用$O(1)$额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2],函数应该返回新的长度2, 并且原数组nums的前两个元素被修改为1, 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:给定nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度5, 并且原数组nums的前五个元素被修改为0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 算法思路“拷贝覆盖”如上图所示，用count来记录元素应该覆盖的步长：在i位置时， 若nums[i] == nums[i + 1]，则count++ 否则，countinue此处用了arr[]来记录每个元素应该移动的步长 123456789101112131415161718int removeDuplicates(int* nums, int numsSize) &#123; int count = 0, i; if(numsSize == 0)&#123; //空数组直接返回0 return 0; &#125; int arr[numsSize]; arr[0]=0; for(i = 1; i &lt; numsSize; i++) &#123; if(nums[i - 1] == nums[i]) &#123; count++; &#125; arr[i]=count; &#125; for(i=0; i &lt; numsSize; i++)&#123; nums[i - arr[i]] = nums[i]; &#125; return numsSize - count;&#125; 移除元素题目描述给定一个数组nums和一个值val，你需要原地移除所有数值等于val的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用$O(1)$额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 算法思路同样是“拷贝覆盖”1234567891011121314int removeElement(int* nums, int numsSize, int val)&#123; int count = 0, i; if(numsSize == 0)&#123; return 0; //空数组直接返回0 &#125; for(i = 0; i &lt; numsSize; i++)&#123; if(nums[i] == val)&#123; count++; &#125; else &#123; nums[i - count] = nums[i]; &#125; &#125; return numsSize - count;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言一些要点总结]]></title>
    <url>%2F2020%2F01%2F23%2Falgorithm-something-about-C%2F</url>
    <content type="text"><![CDATA[复试笔试C语言一些要点 C语言短路求值（逻辑与、逻辑或）逻辑或的短路首先上代码：12345678#include &lt;stdio.h&gt;int main() &#123; int a = 1; printf("a = %d\n", a); 1 || (a = 0); printf("a = %d\n", a); return 0;&#125; 运行结果如下： a = 1a = 1 逻辑或的表现形式如下：expression1 || exexpression2 这⾥用到了逻辑或，由于逻辑或的短路，expression1为true，则后⾯的expression2（即：(a=0) ）不再求值，整个表达式的结果为true，所以a的值仍为1，没有改变。【即：一真为真】 逻辑与的短路⾸先看如下代码：12345678#include &lt;stdio.h&gt;int main() &#123; int a = 1; printf("a = %d\n", a); 0 &amp;&amp; (a = 3); printf("a = %d\n", a); return 0;&#125; 运行结果如下： a = 1a = 1 逻辑与的表现形式如下：expression1 &amp;&amp; expression2 上述代码中用到了逻辑与，由于逻辑与的短路，expression1为false，则后面的expression2不再求值，整个的结果为false，所以a的值没有改变。【即：一假则假】 Eratosthenes筛选法算法原理解释一：给出要筛选数值的范围$n$，找出sqrt(n)以内的素数$p_1, p_2, … , p_k$。 先把1删除（现今数学界1既不是质数也不是合数） 读取队列中当前最小的数2，然后把2的倍数删去 读取队列中当前最小的数3，然后把3的倍数删去 读取队列中当前最小的数5，然后把5的倍数删去 读取队列中当前最小的数7，然后把7的倍数删去 不断重复下去…直到需求的范围内所有的数均删除或读取注：此处的队列并非数据结构队列，如需保留运算结果，处于存储空间的充分利用以及大量删除操作的实施，建议采用链表的数据结构。【来源：百度百科】 解释二： 取最小的数$2$，并声明它是素数，同时筛去它及它的所有倍数； 取未筛去的数中的最小者，声明它是素数，同时筛去它及它的所有倍数； 重复步骤2，至筛中无数为止，得到所有素数。 筛法实际上是筛去合数，留下素数。 一位数组举例 代码123456789101112131415161718192021222324252627282930313233//C Language#include &lt;stdio.h&gt;#define TRUE 1#define FALSE 0#define SIZE 10000int main() &#123; int i; /*i表示整数和对应的下标*/ int j; /*j表示正要处理的质数，j之前的已处理，j之后的未处理*/ int k; /*k表示正在处理的j的倍数从2开始到j*k&lt;SIZE*/ int a[SIZE]; /*下标表示整数内容判断是否为质数*/ int *p; /*控制循环*/ for(p = a; p &lt; a+SIZE; ++p) &#123; /*初始化数组全是TRUE*/ *p = TRUE; &#125; a[0] = a[1] = FALSE; /*设置前面两个是不是质数的数的状态为FALSE，即0和1不是质数*/ i = 2; while(i &lt; SIZE) &#123; /*找到下一个质数*/ while(a[i++] == TRUE) &#123; j = i-1; break; &#125; for(k = 2; j*k &lt; SIZE &amp;&amp; i &lt; SIZE; ++k) &#123; /*处理质数的倍数*/ a[j*k] = FALSE; &#125; &#125; for(p = a; p &lt; a+SIZE; ++p) &#123; /*打印出质数*/ if(*p == TRUE) &#123; printf("%8d", p-a); &#125; &#125; printf("\n"); return 0;&#125; 123456789101112131415//C++int countPrimes(int n) &#123; vector&lt;bool&gt; vec_flag(n, true); vec_flag[0] = false; vec_flag[1] = false; for(int i = 2; i &lt; sqrt(n);i++) &#123; if(vec_flag[i])&#123; for(int j = i * i; j &lt; n; j += i) &#123; vec_flag[j] = false; &#125; &#125; &#125; return count(vec_flag.begin(), vec_flag.end(), true);&#125; 12345678910111213141516171819202122# Pythondef _int_iter():#生成器生成从3开始的无限奇数序列 n = 1 while True: n = n + 2 yield n def _not_divisible(n):#定义筛选函数 return lambda x:x % n &gt; 0 def primes(): yield 2 #先返回一个2 it = _int_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列for n in primes():#构造循环条件，使之可以输出任何范围的素数序列 if n &lt; 1000: print(n) else: break 关于void *void的含义void即“无类型”，void *则为“无类型指针”，可以指向任何数据类型 void指针的使用规范 void指针可以指向任意类型的数据，亦即可用任意数据类型的指针对void指针赋值。例如：123int *p_int;void *p_void;p_void = p_int; /*但是不能 p_int = p_void*/ 如果要将p_void赋给其他类型指针，则需要强制类型转换如：p_int = (int *)p_void; 在ANSIC标准中，不允许对void指针进行算术运算如p_void++或p_void += 1等，而在GNU中则允许。因为在缺省情况下，GNU认为void *与char *⼀样。sizeof(*pvoid ) == sizeof(char). 由于void指针可以指向任意类型的数据，亦即可用任意数据类型的指针对void指针赋值，因此还可以用void指针来作为函数形参，这样函数就可以接受任意数据类型的指针作为参数。例如：12void *memcpy(void *dest, const void *src, size_t len);void *memset(void *buffer, int c, size_t num);]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找旋转排序数组中的最小值]]></title>
    <url>%2F2020%2F01%2F22%2Falgorithm-Find-Minimum-in-Rotated-Sorted-Array%2F</url>
    <content type="text"><![CDATA[LeetCode上的一道题目：153. 寻找旋转排序数组中的最小值来源：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/xun-zhao-xuan-zhuan-pai-lie-shu-zu-zhong-de-zui-xi/ 题目描述 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2]输出: 1 示例 2 输入: [4,5,6,7,0,1,2]输出: 0 方法：二分查找思路一种暴力的解法是搜索整个数组，找到其中的最小元素，这样的时间复杂度是 $O(N)$ 其中 $N$ 是给定数组的大小。 一个非常棒的解决该问题的办法是使用二分搜索。在二分搜索中，我们找到区间的中间点并根据某些条件决定去区间左半部分还是右半部分搜索。 由于给定的数组是有序的，我们就可以使用二分搜索。然而，数组被旋转了，所以简单的使用二分搜索并不可行。 我们希望找到旋转排序数组的最小值，如果数组没有被旋转呢？如何检验这一点呢？ 如果数组没有被旋转，是升序排列，就满足 last element &gt; first element。 上图例子中 7 &gt; 2 。说明数组仍然是有序的，没有被旋转。 上面的例子中 3 &lt; 4，因此数组旋转过了。这是因为原先的数组为 [2, 3, 4, 5, 6, 7]，通过旋转较小的元素 [2, 3] 移到了后面，也就是 [4, 5, 6, 7, 2, 3]。因此旋转数组中第一个元素 [4] 变得比最后一个元素大。 这意味着在数组中你会发现一个变化的点，这个点会帮助我们解决这个问题，我们称其为变化点。 在这个改进版本的二分搜索算法中，我们需要找到这个点。下面是关于变化点的特点： 所有变化点左侧元素 &gt; 数组第一个元素所有变化点右侧元素 &lt; 数组第一个元素 算法 找到数组的中间元素mid。 如果中间元素 &gt; 数组第一个元素，我们需要在mid右边搜索变化点。 如果中间元素 &lt; 数组第一个元素，我们需要在mid做边搜索变化点。 上面的例子中，中间元素6比第一个元素4大，因此在中间点右侧继续搜索。 当我们找到变化点时停止搜索，当以下条件满足任意一个即可：nums[mid] &gt; nums[mid + 1]，因此mid+1是最小值。 nums[mid - 1] &gt; nums[mid]，因此mid是最小值。 在上面的例子中，标记左右区间端点。中间元素为2，之后的元素是7满足7 &gt; 2也就是nums[mid - 1] &gt; nums[mid]。因此找到变化点也就是最小元素为2。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public int findMin(int[] nums) &#123; // If the list has just one element then return that element. if (nums.length == 1) &#123; return nums[0]; &#125; // initializing left and right pointers. int left = 0, right = nums.length - 1; // if the last element is greater than the first element then there is no rotation. // e.g. 1 &lt; 2 &lt; 3 &lt; 4 &lt; 5 &lt; 7. Already sorted array. // Hence the smallest element is first element. A[0] if (nums[right] &gt; nums[0]) &#123; return nums[0]; &#125; // Binary search way while (right &gt;= left) &#123; // Find the mid element int mid = left + (right - left) / 2; // if the mid element is greater than its next element then mid+1 element is the smallest // This point would be the point of change. From higher to lower value. if (nums[mid] &gt; nums[mid + 1]) &#123; return nums[mid + 1]; &#125; // if the mid element is lesser than its previous element then mid element is the smallest if (nums[mid - 1] &gt; nums[mid]) &#123; return nums[mid]; &#125; // if the mid elements value is greater than the 0th element this means // the least value is still somewhere to the right as we are still dealing with elements // greater than nums[0] if (nums[mid] &gt; nums[0]) &#123; left = mid + 1; &#125; else &#123; // if nums[0] is greater than the mid value then this means the smallest value is somewhere to // the left right = mid - 1; &#125; &#125; return -1; &#125;&#125; 时间复杂度分析 时间复杂度：和二分搜索一样$O(logN)$ 空间复杂度：$O(1)$ 或者 判断最小的数是否在第一个位置，若是则返回nums[0]； 否则，选取中间位置mid的数和right位置的数进行比较，若nums[mid] &lt; nums[r]，说明最小的数在mid之前，right = mid；反之，令left = mid + 1； 重复进行，直到left &gt;= right。 12345678910111213int findMin(int* nums, int numsSize)&#123; int left = 0, right = numsSize - 1, mid; if(nums[left] &lt; nums[right]) return nums[left]; while(left &lt; right) &#123; mid = (left + right) / 2; if(nums[mid] &gt; nums[right]) left = mid + 1; //nums[mid]已经比nums[right]大，故不再考虑nums[mid] else right = mid; //nums[mid]比nums[right]小，表示nums[mid]可能是最小值 &#125; return nums[left];&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小公倍数&最大公因数]]></title>
    <url>%2F2020%2F01%2F21%2Falgorithm-LCM%26GCD%2F</url>
    <content type="text"><![CDATA[几个数共有的倍数叫做这几个数的公倍数，其中除0以外最小的一个公倍数，叫做这几个数的最小公倍数。如果数a能被数b整除，a就叫做b的倍数，b就叫做a的约数。约数和倍数都表示一个整数与另一个整数的关系，不能单独存在。 求最大公因数算法求最大公约数有多种方法，常见的有质因数分解法、短除法、辗转相除法、更相减损法。下面介绍辗转相除法（欧几里德算法） 有两整数a和b：① a%b得余数temp② 若temp=0，则b即为两数的最大公因数③ 若temp≠0，则令a=b，b=temp，再回去执行① 例如，求27和15的最大公因数过程为： 27÷15=1 余1215÷12=1 余312÷3=4 余0因此，3即为最大公因数 代码实现如下：12345678910111213//求a，b的最大公因数int GCD(int a, int b) &#123; int temp; do &#123; temp = a % b; if(temp == 0) return b; else &#123; a = b; b = temp; &#125; &#125; while(temp != 0);&#125; 求最小公倍数算法 最小公倍数 = 两整数的乘积 ÷ 最大公约数 代码实现1234567891011//求m和n的最小公倍数int LCM(int m, int n) &#123; int x, y, c; x = m; y = n; while(m != 0) &#123; c = n % m; n = m; m = c; &#125; return (x * y / n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件分配方式之索引分配]]></title>
    <url>%2F2020%2F01%2F20%2Fos-index-assignment%2F</url>
    <content type="text"><![CDATA[磁盘空间分配的主要常用方法有三个：连续分配、链接分配和索引分配。本文主要讨论索引分配中处理索引块大小的问题。文件实际上是一种抽象数据类型，文件的实现就是研究文件的物理结构，即文件数据在物理存储设备上是如何分布和组织的。同一个问题有两个方面的回答：一是文件的分配方式，讲的是对磁盘非空闲块的管理；二是文件存储空间管理，将的是对磁盘空闲块的管理。索引分配解决了连续分配和链式分配中的许多问题。对于索引分配，每个文件在文件分配表中有一个一级索引，索引包含分配给文件的每个分区入口。典型地，文件索引在物理上并不是作为文件分配表的一部分存储的，相反，文件索引保存在一个单独的块中，文件分配表中改文件的入口指向这一块。分配可以基于大小固定的块，也可以基于大小可变的块。索引分配支持顺序访问和直接访问文件，因而是最普遍的一种文件分配方式。 索引分配解决了连接分配不能有效支持直接访问（FAT除外）的问题，它把每个文件的所有的盘块号都集中放在一起构成索引块（表），如下图所示。 每个文件都有其索引块，这是一个磁盘块地址的数组。索引表记录了文件的各个逻辑块对应的物理块。索引块的第i个条目指向文件的第i个块。目录条目包括索引块的地址。要读第i块，通过索引块的第i个条目的指针来查找和读入所需的块。创建文件时，索引块的所有项目都设为空。首次写入第i块时，先从空闲空间中取得一个块，再将其地址写到索引块的第i个条目。索引分配支持直接访问（随机访问），且没有外部碎片的问题，易于文件拓展。其缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此需要索引块尽可能小，但索引块太小就无法支持大文件。可采用以下机制来处理这个问题。 链接方案 一个块通常为一个磁盘块，因此它本身能直接读写。为了处理大文件，可以将多个索引块链接起来。 多层索引：使第一层索引块指向第二层索引块，第二层文件块指向文件块。根据实际要求可以继续到第三层或第四层。 最大文件长度 = 每层索引项个数之积 × 单个文件大小； 每层索引表最大不能超过一个磁盘块大小； K层索引，顶级索引表未调入内存，则访问K级索引需要K+1次读磁盘。【注：文件分配方式之链接分配的隐式分配，读入i号逻辑块，总共需要i+1次读磁盘I/O操作】 混合索引：多重索引分配方式相结合。 UNIX的文件系统采用三级索引机制。在文件控制块（FCB）中，设置了一个索引表，共有13个索引地址。其中，前10个为直接索引地址，后3个为间接索引地址，包括1个一级索引地址、1个二级索引地址和1个三级索引地址。 每一块中能记录的数据块数=512/4≈128一级索引时文件最大长度的字节数 = 128 × 512二级索引时文件最大长度的字节数 = 128×128 × 512三级索引时文件最大长度的字节数 = 128×128×128 × 512最大搜索文件的长度 = (10 + 128 + 128×128 + 128×128×128) × 512与多层索引方式不同，混合索引有个主索引表（13个地址项）【主索引表是索引节点的一部分】，若题目告知主索引表在内存中【主索引表在FCB中，FCB在内存中】，访问k级间址需要读磁盘k+1次（读取数据块1次）；若主索引表不在内存中，访问k级间址需要读磁盘k+2次。而多层索引没有主索引表，因此相当于直接从混合索引的一级间址开始读磁盘，故k层索引读磁盘k+1次。【以上是使用索引结点的次数】注： 与单个文件长度无关的因素：索引结点的总数【索引结点个数仅与文件个数有关，一个索引结点对应一个文件】 一个盘块号就有一个索引项 将文件描述信息从目录项中分离出来，有利于减少查找文件时的I/O信息量 各级索引表最大不能超过一个块 判断读磁盘次数时，注意顶级索引块是否已调入磁盘文件物理地址指的就是主索引表的始址例题：如有错误，欢迎指正！]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的应用]]></title>
    <url>%2F2020%2F01%2F19%2Falgorithm-btree%2F</url>
    <content type="text"><![CDATA[二叉树的系列应用 层次遍历求二叉树宽度、高度 1234567891011121314151617181920212223//设计一个非递归算法求以二叉链表存储的二叉树的高度、最大宽度//非递归：层次遍历，设置level记录当前结点所在层数，last指向下一层第一个结点的位置int Btdepth(BiTree T) &#123; if(!T) return 0; int front=-1, rear=-1; int last=0, level=0; int maxWidth=0; //记录最大宽度 BiTree Q[MaxSize]; Q[++rear]=T; //将根结点入队 BiTree p; while(front&lt;rear)&#123; //队不空，则循环 p=Q[++rear]; //队列元素出队，即正在访问的结点 if(p-&gt;lchild) Q[++rear]=p-&gt;lchild; if(p-&gt;rchild) Q[++rear]=p-&gt;rchild; if(front == last) 处理该层的最右结点，此时last指向该层最右结点 level++; 层数加1 last = rear; last指向下一层 maxWidth=maxWidth&gt;(last-front) ? maxWidth : (last-front); &#125; return level; &#125; 根结点左右子树叶子结点最远距离 123456789101112//递归：int ldep=0, rdep=0; //左右子树的高度int Btdepth2(BiTree *T) &#123; if(T == NULL) return 0; ldep=Btdepth2(T-&gt;lchild); rdep=Btdepth2(T-&gt;rchild); if(ldep&gt;rdep) return ldep+1; //树的高度为子树最大高度加根结点 else return rdep+1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[就地逆置线性表元素]]></title>
    <url>%2F2020%2F01%2F18%2Falgorithm-reverse-linerlist%2F</url>
    <content type="text"><![CDATA[本文分为线性表逆置操作的基本操作和扩展操作 基本操作顺序表 设计一个高效算法，将顺序表L的所有元素逆置，要求空间复杂度为O(1) 方法一扫描前半部分元素，对于L.data[i]（0&lt;i&lt;L.length/2），与后半部分对应元素L.data[L.length-i-1].data交换12345678void Reverse(SqList &amp;L) &#123; ElemType temp; for(int i=0;i&lt;L.length/2;i++) &#123; temp = L.data[i]; L.data[i] = L.data[L.length-i-1]; L.data[L.length-i-1] = temp; &#125;&#125; 方法二用两个指针i、j分别指向数组的前后123456789void Reverse(int *a[], int n)&#123; int i=0, j=n-1, temp; While(i&lt;j)&#123; temp=a[i]; a[i]=a[j]; a[j]=temp; i++; j--; &#125;&#125; 单链表逆置链表（带头结点L）用“头插法”。尾插时，最后一个结点的指针要置空。12345678910void Reverse(LinkList L) &#123; LinkNode *p=L-&gt;next, *q; L-&gt;next=NULL; while(p!=NULL)&#123; q=p-&gt;next; p-&gt;next=L-&gt;next; L-&gt;next=p; p=q; &#125;&#125; 双链表逆置双链表除了上述的步骤外，还多了两个指针，p的后继的前驱和p的前驱的后继12345678910111213void Reverse(DLinkList L) &#123; DLinkNode *p=L-&gt;next, *q; L-&gt;next=NULL; while(p!=NULL)&#123; q=p-&gt;next; p-&gt;next=L-&gt;next; if(p-&gt;next!=NULL) //第一个用“头插法”插入L的结点没有后继 P-&gt;next-&gt;prior=p; L-&gt;next=p; p-&gt;prior=L; p=q; &#125;&#125; 扩展操作两个顺序表位置互换 一维数组A[m+n]中一次存放两个线性表(a1, a2, …, am)和(b1, b2 , …, bn)。编写一个算法，将数组中两个线性表的位置互换—&gt;(b1,b2,…,bn, a1,a2,…,am) 算法思想：将A[m+n]中全部元素逆置为(bn, bn-1, …, b2, b1, am, am-1, …, a2, a1)，再对前n个元素和后m个元素分别逆置123456789101112131415161718void Reverse(int A[], int left, int right, int arraySize)&#123; //逆置(aleft, aleft+1, …, aright) if(left&gt;=right||right&gt;=arraySize) return; int mid=(left+right)/2; for(int i = 0; i&lt;= mid - left; i++)&#123; //这里i作为下标的增量 int temp=A[left+i]; A[left+i]=a[right-i]; A[right-i]=temp; &#125;&#125;void Exchange(int A[], int m, int n, int arraySize)&#123; //数组A[m+n]中，从0到m-1存放顺序表(a1,a2,…,am)，从m到n-1存放(b1,b2,…,bn) Reverse(A, 0, m+n-1, arraySize); Reverse(A, 0, n-1, arraySize); Reverse(A, n, m+n-1, arraySize);&#125; 三个顺序表位置互换 设规模n=3m, m≥1的顺序表存储在一维数组int array[n]中，它含有的元素为(a1,a2,…,am, b1, b2 , …, bm,c1,c2,…,cm)。请编写算法将上述顺序表改造成为(c1,c2,…,cm, bm, …, b2, b1, a1,a2,…,am)，要求时间复杂度和空间复杂度尽可能低。 1234567891011121314void Reverse(int array[], int left, int right) &#123; int temp, mid, i; //i作为下标增量 mid = (left+right)/2; for(i = 0; i &lt;= mid - left; i++)&#123; temp=a[left+i]; a[left+i]=a[right-i]; a[right-i]=temp; &#125;&#125;void Exchange(int array[], int m)&#123; Reverse(array, 0, 3m-1); Reverse(array, 0, m-1); Reverse(array, 2m, 3m-1);&#125; 总结就地逆置线性表元素基本操作总结为“二分交换”，基本思想是从头开始将前半部分与后半部分以中心元素对称的元素进行交换，直到走到了中心元素位置]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件控制块与索引节点的总结]]></title>
    <url>%2F2019%2F11%2F24%2Fos-FCB-and-inode%2F</url>
    <content type="text"><![CDATA[序言文件控制块（FCB）与索引结点（inode）都是操作系统文件管理中逻辑结构的重要部分。在今日考研复习过程中，基本解决了以前遇到的“FCB与inode”的问题，现以此博文记录该知识点。 文件控制块与索引结点这需要从目录结构说起。 文件目录：包含有关文件的信息，信息主要有：属性，位置，所有权。这些信息主要是由OS进行管理。把所有的FCB组织在一起，就构成了文件目录，即文件控制块的有序集合，其包含许多目录项（即FCB）。目录管理的基本要求：从用户角度看待，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射。目录管理提供的是：按名存取。 共享系统中目录还需要提供控制访问文件的信息。重名问题主要通过树形结构来解决。 普通文件目录 以索引结点实现的目录 由FCB构成的一个一个目录项组成；FCB中存放了和文件相关的所有控制信息 a. 文件名 b. 指向索引结点的指针 采用索引结点的方式来实现目录，好处是文件目录的目录项长度会缩短很多。因为通过文件目录实现对文件的按名存取时，在寻找文件的过程中只需要用到文件名这个信息，而其他信息在寻找文件的时候没有必要。如果一个目录中存放了很多个文件，采用传统的以FCB构成目录项的方式，那么这个文件目录会非常大，因为每个目录项就特别大。而采用索引结点的方式实现目录，每个目录项就会很小，只包含文件名和指向索引结点的指针。可以提高文件检索速度。 FCB：文件控制块。用于存放控制文件的各种信息的数据结构，实现了按名存取。 总结如下表： 此处有个小问题： 某科技大学的OS考研试卷填空题答案中索引节点分为文件描述信息和i结点，而资料书上说的是索引节点即为i结点 检索目录文件（FCB的集合）时只用到了文件名。仅当找到一个目录项时才需要从该目录项（FCB）中读出该文件的物理地址。即：检索目录时文件的其他描述信息用不到，也因此不必调入内存。那么我们是否可以考虑，把文件名和文件的描述信息(FCB-文件名)分开，文件的描述信息单独形成一个数据结构，这个被称作索引结点。简称为i结点。这样就可以简化目录结构为：文件名对应i结点指针。比如在UNIX系统中，文件目录项（FCB）占16B，其中14B是文件名，2B是i结点指针。注意到设计i结点的设计思路是怎么得到的，就很容易理解FCB和i结点包含的信息大部分是相同的，i结点只是抽出了文件名。每个文件对应一个文件名，则一个文件也只要一个i结点。 存放在磁盘上的索引结点称为磁盘索引结点。 文件控制块与索引节点的区别个人总结：从文件目录结构来看，UNIX中， 文件目录由FCB（目录项）组成 FCB = 文件名 + inode inode包含了文件物理地址信息 物理地址信息的组成主要是主索引表如图所示: 个人能力有限，总结有问题请指出。]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 监控爬取成绩并推送到邮箱(基于百度云接口的验证码识别)]]></title>
    <url>%2F2018%2F12%2F28%2FPython-3-6-%E7%9B%91%E6%8E%A7%E7%88%AC%E5%8F%96%E6%88%90%E7%BB%A9%E5%B9%B6%E6%8E%A8%E9%80%81%E5%88%B0%E9%82%AE%E7%AE%B1(%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E4%BA%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB)%2F</url>
    <content type="text"><![CDATA[简介本程序模拟登录正方教务系统获取本人当前学期成绩（也可以手动改学期学年），20分钟检测一次，当有新成绩公布时就发送到邮箱，本程序用到的是我学校的教务网网址。 本项目GitHub地址大连大学成绩监控查询脚本 第一代手动输入验证码的程序Python 3.6 监控爬取成绩并推送到邮箱 验证码识别参照了XiaoYaoII的文章利用python3 爬取教务处实现自动查询成绩并发送给用户QQ邮箱 使用百度云文字识别的SDK的帮助文档在此Python SDK文档 实现思想本程序的实现主要步骤有： 首先登录进入成绩查询页面 将对应的所有成绩爬取下来 将爬取下来的成绩进行格式化（表格） 美化后的成绩表格发送到邮箱 详细步骤 登录 得到跳转后页面的地址（为了防止登录重复，教务系统后面会跳转后在网址后面加一串随机的hash码） 利用百度云识别验证码 将需要的列爬取下来 每次爬取后让程序暂停20分钟，将每次所爬取的成绩数量进行对比，如果与第一次爬取的数量相同则不发邮件，否则发送邮件 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701'''大连大学成绩查询助手V1.7.190216Code By ZC Liang2018.6.6Completed on 2019.2.15'''import getpassimport http.cookiejarimport osimport pickleimport platformimport randomimport reimport smtplibimport subprocessimport sysimport timeimport urllib.parseimport urllib.requestfrom email.mime.text import MIMETextfrom email.utils import formataddrimport bs4import numpy as npimport pandas as pdimport prettytable as ptimport pymysqlimport requestsfrom aip import AipOcrfrom bs4 import BeautifulSoupfrom PIL import Imagefrom prettytable import PrettyTablefrom requests import ReadTimeoutfrom requests import ConnectionErrormy_sender = '发件人邮箱账号' # 发件人邮箱账号my_pass = '发件人邮箱密码' # 发件人邮箱密码(当时申请smtp给的口令)# my_user = '收件人邮箱账号' # 收件人邮箱账号，我这边发送给自己email_send_to = '' # 收件人邮箱账号DstDir = os.getcwd()searchCount = 0 # 查询次数count = 0 # 循环计数scorenum = 0 # 成绩条数score = []scorenp = np.array(score)makeup_course_num = 0 # 重修课程数目makeup_course_flag = -1 # 重修课程数目下标courseList = [] # 选课情况查询列表required_course_num = 0 # 本学期必修课总数# 准备Cookie和opener，因为cookie存于opener中，所以以下所有网页操作全部要基于同一个openercookie = http.cookiejar.CookieJar()opener = urllib.request.build_opener( urllib.request.HTTPCookieProcessor(cookie))final_url = "" # 头 + 随机编码 + default2.aspxfinal_url_head = ""url_head = "202.199.155." + str(random.randint(33, 37)) # 随机产生网址ddlxn = ""ddlxq = """"" 你的 APPID AK SK """APP_ID = '你的 APP_ID'API_KEY = '你的 API_KEY'SECRET_KEY = '你的 SECRET_KEY'client = AipOcr(APP_ID, API_KEY, SECRET_KEY)""" 读取图片 """def get_file_content(filePath): with open(filePath, 'rb') as fp: return fp.read()# 判断操作系统类型def getOpeningSystem(): return platform.system()# 判断操作系统类型def getOpeningSystem(): return platform.system()# 判断是否联网def isConnected(): try: response = requests.get('http://' + url_head, timeout=1) if response.status_code == 200: return True else: print('网络检测错误status_code: ' + response.status_code, 'http://' + url_head) return False except (ConnectionError, ReadTimeout): print('无网络连接。')# 获取重定向编码def check_for_redirects(url): r = requests.head(url) if r.ok: return r.headers['location'] else: return '[no redirect]'# 图像转换并识别def image_util(img): new_im = img.convert("RGB") # 将验证码图片转换成24位图片 new_im.save('' + DstDir + '\\ScoreHelper\\CheckCode1.jpg') # 将24位图片保存到本地 arr = np.array(Image.open('' + DstDir + '\\ScoreHelper\\CheckCode1.jpg').convert("L")) b = 255 - arr im = Image.fromarray(b.astype('uint8')) # 翻转 # d = 255 * (arr / 255) ** 2 # im = Image.fromarray(d.astype('uint8')) # 灰度 # 此处验证过，翻转比灰度识别率更高 im.save('' + DstDir + '\\ScoreHelper\\CheckCode2.jpg')# 验证码识别def code_recognition(): try: # 调用百度云识别验证码 result = client.basicAccurate(get_file_content('' + DstDir + '\\ScoreHelper\\CheckCode2.jpg')) word = result.get('words_result') res = "" if len(word): res = re.findall('[a-zA-Z0-9]+', word[0].get('words'))[0] elif len(res) &gt; 4: # 教务系统所有的验证码都是四位的，若大于四位，则挑选前四位 res = res[0:4] return res except Exception as e: print(e)# 登陆def login(): # 构造表单 params = &#123; 'txtUserName': sid, 'Textbox1': '', 'Textbox2': spwd, 'RadioButtonList1': '学生', 'Button1': '', 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '', &#125; # 获取验证码 res = opener.open(final_url_head + '/checkcode.aspx').read() with open('' + DstDir + '\\ScoreHelper\\CheckCode.jpg', 'wb') as file: file.write(res) img = Image.open('' + DstDir + '\\ScoreHelper\\CheckCode.jpg') # 图片处理 image_util(img) # img.show() print('验证码识别结果：' + code_recognition()) vcode = code_recognition() # img.close() params['txtSecretCode'] = vcode # 获取ViewState response = urllib.request.urlopen('http://' + url_head + '/') html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 尝试登陆 loginurl = final_url print("\n本次登录所用网址为：" + loginurl + "\n") data = urllib.parse.urlencode(params).encode('gb2312') response = opener.open(loginurl, data) if response.geturl() == final_url: print('登陆失败，可能是姓名，学号，密码或验证码填写错误！') return False else: return True# 获取本学期必修课数目def get_RequiredCourse_num(): global required_course_num print("正在查询本学期必修课数目...") # 构造url url = ''.join([ final_url_head + '/xsxkqk.aspx', '?xh=', sid, '&amp;xm=', urllib.parse.quote(sname), '&amp;gnmkdm=N121615', ]) # 构建查询学生选课情况表单 params = &#123; 'ddlxn': ddlxn, 'ddlxq': ddlxq, &#125; # 构造Request对象，填入Header，防止302跳转，获取新的View_State req = urllib.request.Request(url) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') req.add_header( 'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = opener.open(req) html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 查询所有成绩 req = urllib.request.Request( url, urllib.parse.urlencode(params).encode('gb2312')) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') response = opener.open(req) soup = BeautifulSoup(response.read().decode('gb2312'), 'html.parser') html = soup.find('table', class_='datelist') # 指定要输出的列，原网页的表格列下标从0开始 # 用于标记是否是遍历第一行 flag = True # 根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象 # 遍历行 counter = 0 for each in html: columnCounter = 0 column = [] if type(each) == bs4.element.NavigableString: pass else: # 遍历列 for item in each.contents: if item != '\n': if counter &gt; 0 and columnCounter == 3: courseList.append(str(item.contents[0]).strip()) columnCounter += 1 if flag: flag = False counter += 1 for each in courseList: if each == "必修课程": required_course_num += 1# 获取成绩def getScore(): global searchCount global scorenum global scorenp global ddlxn global ddlxq score = [] # 构造url url = ''.join([ final_url_head + '/xscjcx_dq.aspx', '?xh=', sid, '&amp;xm=', urllib.parse.quote(sname), '&amp;gnmkdm=N121605', ]) # 构建查询全部成绩表单 params = &#123; 'ddlxn': ddlxn, # 全部为 %C8%AB%B2%BF 'ddlxq': ddlxq, 'btnCx': '查询', &#125; # 构造Request对象，填入Header，防止302跳转，获取新的View_State req = urllib.request.Request(url) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') req.add_header( 'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = opener.open(req) html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 查询所有成绩 req = urllib.request.Request( url, urllib.parse.urlencode(params).encode('gb2312')) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') response = opener.open(req) soup = BeautifulSoup(response.read().decode('gb2312'), 'html.parser') html = soup.find('table', class_='datelist') print("执行第" + str(searchCount) + "次查询：") print('你的所有成绩如下：') # 指定要输出的列，原网页的表格列下标从0开始 outColumn = [3, 4, 6, 7, 9, 11, 13] # 用于标记是否是遍历第一行 flag = True # 根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象 # 遍历行 for each in html: columnCounter = 0 column = [] if type(each) == bs4.element.NavigableString: pass else: # 遍历列 for item in each.contents: if item != '\n': if columnCounter in outColumn: # 要使用str转换，不然陷入copy与deepcopy的无限递归 column.append(str(item.contents[0]).strip()) columnCounter += 1 if flag: table = PrettyTable(column) flag = False else: table.add_row(column) score.extend([column]) searchCount += 1 scorenp = np.array(score) # table.set_style(pt.PLAIN_COLUMNS) print(table) print("分条统计：") scorenum = sendScore(table) print("成绩数目: " + str(scorenum) + "条")def sendScore(table): global scorenum global count global email_send_to global scorenp for i in table: print(i.get_string()) count += 1 if count &gt; scorenum: try: scorenum = count # 文本模式 # context = i.get_string().replace("+"," ") # context = context.replace("-"," ") # context = context.replace("2017 2018","2017-2018") # if(scorenum == 1): # msg=MIMEText("有成绩下来了：" + context,'plain','utf-8') # else: # msg=MIMEText("又有成绩下来了：" + context,'plain','utf-8') # msg = prettyScore() # html格式 msg = prettyScore() # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['From'] = formataddr(["1115810371@qq.com", my_sender]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['To'] = formataddr([email_send_to, email_send_to]) if count == required_course_num: msg['Subject'] = "第" + str(count) + "次成绩推送加平均绩点" else: msg['Subject'] = "第" + str(count) + "次成绩推送" # 邮件的主题，也可以说是标题 # 发件人邮箱中的SMTP服务器，端口是465 server = smtplib.SMTP_SSL("smtp.qq.com", 465) server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.sendmail(my_sender, [email_send_to, ], msg.as_string()) server.quit() # 关闭连接 print("发送成功，请注意在此邮箱查收：" + email_send_to) except Exception as e: print(e) print("发送失败！") count = 0 if scorenum != required_course_num: print("程序休息中...（按'Ctrl C'结束）") time.sleep(1200) # 二十分钟查一次 return scorenum# 接收构造成功的表格def prettyScore(): global scorenp try: # context = MIMEText(html,_subtype='html',_charset='utf-8') #解决乱码 msg = MIMEText(str(htmlText(scorenum)), "html", "gb2312") except Exception as e: print(e) return msg# 构造邮件内容：成绩表格def htmlText(scorenum): global required_course_num html = """ &lt;table color="CCCC33" width="800" border="1" cellspacing="0" cellpadding="5" text-align="center"&gt; &lt;tr&gt; &lt;td&gt;课程名称&lt;/td&gt; &lt;td&gt;课程性质&lt;/td&gt; &lt;td&gt;学分&lt;/td&gt; &lt;td&gt;平时成绩&lt;/td&gt; &lt;td&gt;期末成绩&lt;/td&gt; &lt;td&gt;成绩&lt;/td&gt; &lt;/tr&gt; """ + addtrs(scorenum) + """ &lt;/table&gt; """ # 最后一次推送时计算GPA并与成绩表格一起推送 if scorenum == required_course_num: html += """ &lt;br/&gt; &lt;div class='gpa_text' style='font-size: 25px;font-style: italic;'&gt;--&gt;平均绩点：%s &lt;--&lt;/div&gt; """ % (getGPA()) + """ &lt;br/&gt; &lt;div class='end_words' style='font-size: 20px;'&gt;本学期考试成绩查询完成！&lt;/div&gt; """ return html# 在发送的表格里添加成绩行def addtrs(scorenum): global scorenp i = 1 array = [] while i &lt;= scorenum: trs = ''' &lt;tr&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; ''' % (scorenp[i][0], scorenp[i][1], scorenp[i][2], scorenp[i][3], scorenp[i][4]) if (scorenp[i][5].isalpha() and scorenp[i][5] == "A") or (scorenp[i][5].isdigit() and int(scorenp[i][5]) &gt;= 90): # 等级A和90以上的成绩标记为绿色 trs += '&lt;td style="color:springgreen;"&gt;' elif (scorenp[i][5].isalpha() and scorenp[i][5] == "F") or ( scorenp[i][5].isdigit() and int(scorenp[i][5]) &lt; 60): # 不及格的成绩标记为红色 trs += '&lt;td style="color:red;"&gt;' else: # 普通成绩不标记 trs += '&lt;td&gt;' trs += ''' %s &lt;/td&gt; &lt;/tr&gt; ''' % (scorenp[i][5]) array.append(trs) i += 1 s = "" for x in array: s += str(x) return s# 计算GPAdef getGPA(): global scorenp global scorenum global makeup_course_num global makeup_course_flag sc = [] GPAlist = [] i = 1 j = 0 coursenum = 0 while i &lt;= scorenum: if scorenp[i][1] != "必修课程" or scorenp[i][6] == "是": # 排除非必修课以及重修课 makeup_course_num += 1 i += 1 continue else: # 有些成绩是等级，需要转换为数字 if scorenp[i][5].isalpha() and scorenp[i][5] != "F": sc.append(745 - 10 * ord(scorenp[i][5])) # 计算式子：x - (x - A) + 10 * (D - x) 即 745 - 10 * x elif scorenp[i][5] == "F": sc.append(0) else: sc.append(int(scorenp[i][5])) if int(sc[j]) &lt; 60: # 不及格的科目绩点为0 GPAlist.append(0) else: # 计算单科绩点 GPAlist.append((int(sc[j]) - 50) / 10 * float(scorenp[i][2])) i += 1 j += 1 coursenum += 1 i = 1 j = 0 sum = 0 scoresum = 0 while i &lt;= scorenum: if scorenp[i][1] != "必修课程" or scorenp[i][6] == "是": i += 1 continue sum += GPAlist[j] scoresum += float(scorenp[i][2]) j += 1 i += 1 GPA = sum / scoresum print("平均绩点：" + str(GPA)) return GPA# 根据当前日期设置查询学期def setSemester(): global ddlxn global ddlxq try: localtime = time.localtime(time.time()) # 获取当前日期 # 第一学期是从当年9月到次年2月，第二学期则是从当年3月到8月 if (int((localtime.tm_mon) &gt;= 9 and int(localtime.tm_mon) &lt;= 12) or ( int(localtime.tm_mon) &gt;= 1 and int(localtime.tm_mon) &lt;= 2)): # if (str(localtime.tm_year) == "2020" and int((localtime.tm_mon) &gt;= 7)): # print("您已毕业，无须监控成绩！") # sys.exit(0) if (int(localtime.tm_mon) &gt;= 1 and int(localtime.tm_mon) &lt;= 2): ddlxn = str(localtime.tm_year - 1) + '-' + str(int(localtime.tm_year)) else: ddlxn = str(localtime.tm_year) + '-' + str(int(localtime.tm_year) + 1) ddlxq = '1' else: ddlxn = str(int(localtime.tm_year) - 1) + '-' + str(localtime.tm_year) ddlxq = '2' except Exception as e: print(e)if __name__ == '__main__': setSemester() try: searchCount = 1 print('欢迎使用大连大学成绩查询助手！') print('正在检查网络...') if isConnected(): with open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'rb') as file: udick = pickle.load(file) sname = udick['sname'] sid = udick['sid'] spwd = udick['spwd'] email_send_to = udick['email_send_to'] # 构造登录地址 final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] loginCount = 0 while not login(): if loginCount &gt; 3: # 超过三次未登录自动更换网址 url_head = "202.199.155." + str(random.randint(33, 37)) final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] loginCount = 0 loginCount += 1 print("正在等待重试...") time.sleep(3) continue get_RequiredCourse_num() getScore() counter = 0 while scorenum &lt;= required_course_num: counter += 1 if scorenum == required_course_num: print("本学期成绩查询完成！") break if counter &gt; 0: getScore() except FileNotFoundError: # if os.path.exists(r'' + DstDir + '\\ScoreHelper'): # os.remove(r'' + DstDir + '\\ScoreHelper') os.mkdir(r'' + DstDir + '\\ScoreHelper') # 注：针对Windows目录结构 print('这是你第一次使用，请按提示输入信息，以后可不必再次输入~') sid = input('请输入学号：') sname = input('请输入姓名：') # 隐藏密码 # spwd = getpass.getpass('请输入密码：') spwd = input('请输入密码：') email_send_to = input('请输入要将成绩发送到的邮箱地址：') udick = &#123;'sname': sname, 'sid': sid, 'spwd': spwd, 'email_send_to': email_send_to&#125; file = open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'wb') pickle.dump(udick, file) file.close() final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] # 登录失败，重试 while not login(): sname = input('请输入姓名：') sid = input('请输入学号：') # spwd = getpass.getpass('请输入密码：') spwd = input('请输入密码：') email_send_to = input('请输入要将成绩发送到的邮箱地址：') udick = &#123;'sname': sname, 'sid': sid, 'spwd': spwd, 'email_send_to': email_send_to&#125; file = open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'wb') pickle.dump(udick, file) file.close() final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] get_RequiredCourse_num() getScore() counter = 0 while scorenum &lt;= required_course_num: counter += 1 if scorenum == required_course_num: print("本学期成绩查询完成！") break if counter &gt; 0: getScore() print(scorenum) except subprocess.CalledProcessError: print("网络连接不正常！请检查网络！") except Exception as e: print(e) print("失败！可能是你没有完成教学评价！没有完成教学评价则无法查看成绩！或用户中途取消或网络故障。") finally: # if os.path.exists(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg'): # os.remove(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg') print("程序将在3秒后退出...") time.sleep(3) 运行结果 NOTE 当百度云识别不成功时，为了防止网页错误，我设置了3秒间隔重试登录 当多次识别不成功时，程序可能结束 关于自动判断学期的功能，我是根据我个人的毕业时间来算的结束监控的年月日期，请按需修改 当教务网关闭以及断网的时候本程序就不灵了。。。 由于session有时间限制，所以每隔一段时间（约27小时）就要重新登录 本程序需要改进的一些功能 程序被停止后需要立即重新运行（在完善中） 修复日志 2019-1-2 修复日期计算错误的问题 更新新增python控制自动运行.bat文件功能，使程序得以无休止运行 battle.bat 12345@echo off cd ./start python 成绩监控并推送.py startpy.py 123456789101112131415161718192021222324252627282930313233343536# startpy.py# coding:utf8import datetimeimport osimport timedef doSth(): # 把爬虫程序放在这个类里 print('这个程序要开始疯狂的运转啦') try: if os.path.exists(path): command = path + '/battle.bat' os.system(command) except (IOError, Exception) as e: print(e)if __name__ == '__main__': path = os.getcwd() count = 0 timeCount = 0 doSth() while timeCount &lt; 27: timeCount += 1 count += 1 print("程序第",end="") print(count,end="") print("次执行") if timeCount == 27: timeCount = 0 # doSth() # 每隔1小时检测一次 time.sleep(3600) startpy.py运行截图： 更新更新(2019-2-12)将验证码图片颜色翻转，提高识别准确率123456789101112131415# 图像转换并识别def image_util(img): new_im = img.convert(&quot;RGB&quot;) # 将验证码图片转换成24位图片 new_im.save(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode1.jpg&apos;) # 将24位图片保存到本地 arr = np.array(Image.open(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode1.jpg&apos;).convert(&quot;L&quot;)) b = 255 - arr im = Image.fromarray(b.astype(&apos;uint8&apos;)) # 翻转 # d = 255 * (arr / 255) ** 2 # im = Image.fromarray(d.astype(&apos;uint8&apos;)) # 灰度 # 此处验证过，翻转比灰度识别率更高 im.save(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode2.jpg&apos;) 更新(2019-2-15)更改重试次数限制，当出现三次登录不成功时，更换网址重新登录12345678910111213141516171819if __name__ == &apos;__main__&apos;: ... loginCount = 0 while not login(): if loginCount &gt; 3: # 超过三次未登录自动更换网址 url_head = &quot;202.199.155.&quot; + str(random.randint(33, 37)) final_url = &apos;http://&apos; + url_head + \ check_for_redirects(&apos;http://&apos; + url_head + &apos;/default2.aspx&apos;) final_url_head = final_url[0:48] loginCount = 0 loginCount += 1 print(&quot;正在等待重试...&quot;) time.sleep(3) continue get_RequiredCourse_num() getScore() ...]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 监控爬取成绩并推送到邮箱]]></title>
    <url>%2F2018%2F07%2F25%2FPython-3-6-%E7%9B%91%E6%8E%A7%E7%88%AC%E5%8F%96%E6%88%90%E7%BB%A9%E5%B9%B6%E6%8E%A8%E9%80%81%E5%88%B0%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[简介本程序模拟登录正方教务系统获取本人当前学期成绩（也可以手动改学期学年），20分钟检测一次，当有新成绩公布时就发送到邮箱，本程序用到的是我学校的教务网网址。 由于正方网页的每一项都需要cookie来进行访问，在用Chrome单独打开子页面时，网页会直接跳到登录前界面。在用调试查看了post后，发现cookie消失了；但是直接从网页上打开子网页可以访问。所以在登录时就要保存登录信息cookie。 爬取部分是根据网上代码内容修改的，后面的监控和发送是自己完成的。 本程序测试了多次修改了许许多多的bug，终于得以发布。 该程序的发送邮箱部分需要用到Python SMTP功能，具体可参照xsan的python3通过qq邮箱发送邮件 教务系统网址防止访问重复冲突，在后面加了一串hash码，所有的网址一定要带上它，这样才能访问到登录后的界面，否则没有cookie。 开头要求用户输入本学期所有考试数目，包括重修、公选、跨选等课程，目的是在最后一次推送前将平均绩点算出并发送到邮箱。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574'''大连大学成绩查询助手V3.5Coded By Martin HuangCode Changed By ZC Liang2018.6.6'''import reimport urllib.requestimport urllib.parseimport http.cookiejarimport bs4import getpassimport pickleimport osimport platformimport subprocessfrom bs4 import BeautifulSoupfrom prettytable import PrettyTablefrom PIL import Imageimport smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrimport timeimport prettytable as ptimport pandas as pdimport numpy as npmy_sender = '发件人邮箱账号' # 发件人邮箱账号my_pass = '发件人邮箱密码' # 发件人邮箱密码(当时申请smtp给的口令)# my_user = '收件人邮箱账号' # 收件人邮箱账号，我这边发送给自己email_send_to = '' # 收件人邮箱账号DstDir = os.getcwd()searchCount = 0 # 查询次数count = 0 # 循环计数scorenum = 0 # 成绩条数score = []scorenp = np.array(score)makeup_course_num = 0 # 重修课程数目makeup_course_flag = -1 # 重修课程数目下标courseList = []required_course_num = 0# 准备Cookie和opener，因为cookie存于opener中，所以以下所有网页操作全部要基于同一个openercookie = http.cookiejar.CookieJar()opener = urllib.request.build_opener( urllib.request.HTTPCookieProcessor(cookie))final_url = "" # 头 + 随机编码 + default2.aspxfinal_url_head = ""url_head = "202.199.155." + str(random.randint(33, 37)) # 随机产生网址ddlxn = ""ddlxq = ""# 判断操作系统类型def getOpeningSystem(): return platform.system()# 判断是否联网def isConnected(): userOs = getOpeningSystem() if userOs == "Windows": subprocess.check_call( ["ping", "-n", "2", url_head], stdout=subprocess.PIPE) else: subprocess.check_call( ["ping", "-c", "2", url_head], stdout=subprocess.PIPE)# 获取重定向编码def check_for_redirects(url): r = requests.head(url) if r.ok: return r.headers['location'] else: return '[no redirect]'# 登陆def login(): # 构造表单 params = &#123; 'txtUserName': sid, 'Textbox1': '', 'Textbox2': spwd, 'RadioButtonList1': '学生', 'Button1': '', 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '', &#125; # 获取验证码 res = opener.open(final_url_head + '/checkcode.aspx').read() with open('' + DstDir + '\\ScoreHelper\\CheckCode.jpg', 'wb') as file: file.write(res) img = Image.open('' + DstDir + '\\ScoreHelper\\CheckCode.jpg') img.show() vcode = input('请输入验证码：') img.close() params['txtSecretCode'] = vcode # 获取ViewState response = urllib.request.urlopen('http://' + url_head + '/') html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 尝试登陆 loginurl = final_url print("\n本次登录所用网址为：" + loginurl + "\n") data = urllib.parse.urlencode(params).encode('gb2312') response = opener.open(loginurl, data) if response.geturl() == final_url: print('登陆失败，可能是姓名、学号、密码、验证码填写错误！') return False else: return True# 获取本学期必修课数目def get_RequiredCourse_num(): global required_course_num print("正在查询本学期必修课数目...") # 构造url url = ''.join([ final_url_head + '/xsxkqk.aspx', '?xh=', sid, '&amp;xm=', urllib.parse.quote(sname), '&amp;gnmkdm=N121615', ]) # 构建查询学生选课情况表单 params = &#123; 'ddlxn': ddlxn, 'ddlxq': ddlxq, &#125; # 构造Request对象，填入Header，防止302跳转，获取新的View_State req = urllib.request.Request(url) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') req.add_header( 'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = opener.open(req) html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 查询所有成绩 req = urllib.request.Request( url, urllib.parse.urlencode(params).encode('gb2312')) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') response = opener.open(req) soup = BeautifulSoup(response.read().decode('gb2312'), 'html.parser') html = soup.find('table', class_='datelist') # 指定要输出的列，原网页的表格列下标从0开始 # 用于标记是否是遍历第一行 flag = True # 根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象 # 遍历行 counter = 0 for each in html: columnCounter = 0 column = [] if(type(each) == bs4.element.NavigableString): pass else: # 遍历列 for item in each.contents: if(item != '\n'): if(counter&gt;0 and columnCounter == 3): courseList.append(str(item.contents[0]).strip()) columnCounter += 1 if flag: flag = False counter += 1 for each in courseList: if(each == "必修课程"): required_course_num += 1# 获取成绩def getScore(): global searchCount global scorenum global scorenp global ddlxn global ddlxq score = [] # 构造url url = ''.join([ final_url_head + '/xscjcx_dq.aspx', '?xh=', sid, '&amp;xm=', urllib.parse.quote(sname), '&amp;gnmkdm=N121605', ]) # 构建查询全部成绩表单 params = &#123; 'ddlxn': ddlxn, # 全部为 %C8%AB%B2%BF 'ddlxq': ddlxq, 'btnCx': '+%B2%E9++%D1%AF+', &#125; # 构造Request对象，填入Header，防止302跳转，获取新的View_State req = urllib.request.Request(url) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') req.add_header( 'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = opener.open(req) html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 查询所有成绩 req = urllib.request.Request( url, urllib.parse.urlencode(params).encode('gb2312')) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') response = opener.open(req) soup = BeautifulSoup(response.read().decode('gb2312'), 'html.parser') html = soup.find('table', class_='datelist') print("执行第" + str(searchCount) + "次查询：") print('你的所有成绩如下：') # 指定要输出的列，原网页的表格列下标从0开始 outColumn = [3, 4, 6, 7, 9, 11, 13] # 用于标记是否是遍历第一行 flag = True # 根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象 # 遍历行 for each in html: columnCounter = 0 column = [] if(type(each) == bs4.element.NavigableString): pass else: # 遍历列 for item in each.contents: if(item != '\n'): if columnCounter in outColumn: # 要使用str转换，不然陷入copy与deepcopy的无限递归 column.append(str(item.contents[0]).strip()) columnCounter += 1 if flag: table = PrettyTable(column) flag = False else: table.add_row(column) score.extend([column]) searchCount += 1 scorenp = np.array(score) # table.set_style(pt.PLAIN_COLUMNS) print(table) print("分条统计：") scorenum = sendScore(table) print("成绩数目: " + str(scorenum) + "条")def sendScore(table): global scorenum global count global email_send_to global scorenp for i in table: print(i.get_string()) count += 1 if(count &gt; scorenum): try: scorenum = count # 文本模式 # context = i.get_string().replace("+"," ") # context = context.replace("-"," ") # context = context.replace("2017 2018","2017-2018") # if(scorenum == 1): # msg=MIMEText("有成绩下来了：" + context,'plain','utf-8') # else: # msg=MIMEText("又有成绩下来了：" + context,'plain','utf-8') # msg = prettyScore() # html格式 msg = prettyScore() # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['From'] = formataddr(["1115810371@qq.com", my_sender]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['To'] = formataddr([email_send_to, email_send_to]) if(count == required_course_num): msg['Subject'] = "第" + \ str(count) + "次成绩推送加平均绩点" # 邮件的主题，也可以说是标题 else: msg['Subject'] = "第" + str(count) + "次成绩推送" # 邮件的主题，也可以说是标题 # 发件人邮箱中的SMTP服务器，端口是465 server = smtplib.SMTP_SSL("smtp.qq.com", 465) server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.sendmail(my_sender, [email_send_to, ], msg.as_string()) server.quit() # 关闭连接 print("发送成功，请注意在此邮箱查收：" + email_send_to) except Exception as e: print(e) print("发送失败") count = 0 if(scorenum != required_course_num): print("程序休息中...（按'Ctrl C'结束）") time.sleep(1200) # 二十分钟查一次 return scorenumdef prettyScore(): global scorenp try: # context = MIMEText(html,_subtype='html',_charset='utf-8') #解决乱码 msg = MIMEText(str(htmlText(scorenum)), "html", "gb2312") except Exception as e: print(e) return msgdef htmlText(scorenum): global required_course_num if(scorenum == required_course_num): html = """ &lt;table color="CCCC33" width="800" border="1" cellspacing="0" cellpadding="5" text-align="center"&gt; &lt;tr&gt; &lt;td text-align="center"&gt;课程名称&lt;/td&gt; &lt;td text-align="center"&gt;课程性质&lt;/td&gt; &lt;td text-align="center"&gt;学分&lt;/td&gt; &lt;td text-align="center"&gt;平时成绩&lt;/td&gt; &lt;td text-align="center"&gt;期末成绩&lt;/td&gt; &lt;td text-align="center"&gt;成绩&lt;/td&gt; &lt;/tr&gt; """ + addtrs(scorenum) + """ &lt;/table&gt; &lt;div&gt;&lt;h2&gt;--&gt;平均绩点：%s --&lt;&lt;/h2&gt;&lt;/div&gt; """ % (getGPA()) else: html = """ &lt;table color="CCCC33" width="800" border="1" cellspacing="0" cellpadding="5" text-align="center"&gt; &lt;tr&gt; &lt;td text-align="center"&gt;课程名称&lt;/td&gt; &lt;td text-align="center"&gt;课程性质&lt;/td&gt; &lt;td text-align="center"&gt;学分&lt;/td&gt; &lt;td text-align="center"&gt;平时成绩&lt;/td&gt; &lt;td text-align="center"&gt;期末成绩&lt;/td&gt; &lt;td text-align="center"&gt;成绩&lt;/td&gt; &lt;/tr&gt; """ + addtrs(scorenum) return htmldef addtrs(scorenum): global scorenp i = 1 array = [] while(i &lt;= scorenum): trs = ''' &lt;tr&gt; &lt;td text-align="center"&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;/tr&gt; ''' % (scorenp[i][0], scorenp[i][1], scorenp[i][2], scorenp[i][3], scorenp[i][4], scorenp[i][5]) array.append(trs) i += 1 s = "" for x in array: s += str(x) return sdef getGPA(): global scorenp global scorenum global makeup_course_num global makeup_course_flag sc = [] GPAlist = [] i = 1 j = 0 coursenum = 0 while(i &lt;= scorenum): if(scorenp[i][1] != "必修课程" or scorenp[i][6] == "是"): makeup_course_num += 1 i += 1 continue else: if(scorenp[i][5] == "F"): sc.append(0) elif(scorenp[i][5] == "A"): sc.append(95) elif(scorenp[i][5] == "B"): sc.append(85) elif(scorenp[i][5] == "C"): sc.append(75) elif(scorenp[i][5] == "D"): sc.append(65) else: sc.append(int(scorenp[i][5])) if(int(sc[j]) &lt; 60): GPAlist.append(0) else: GPAlist.append((int(sc[j]) - 50)/10*float(scorenp[i][2])) i += 1 j += 1 coursenum += 1 i = 1 j = 0 sum = 0 scoresum = 0 while(i &lt;= scorenum): if(scorenp[i][1] != "必修课程" or scorenp[i][6] == "是"): i += 1 continue sum += GPAlist[j] scoresum += float(scorenp[i][2]) j += 1 i += 1 GPA = sum/scoresum print("平均绩点：" + str(GPA)) return GPAif __name__ == '__main__': try: localtime = time.localtime(time.time()) # 获取当前日期 if(int((localtime.tm_mon) &gt;= 9 and int(localtime.tm_mon) &lt;= 12) or (int(localtime.tm_mon) &gt;= 1 and int(localtime.tm_mon) &lt;= 2)): if(str(localtime.tm_year) == "2020"): print("您已毕业，无须监控成绩！") sys.exit(0) ddlxn = str(localtime.tm_year) + '-' + str(int(localtime.tm_year) + 1) ddlxq = '1' else: ddlxn = str(int(localtime.tm_year) - 1) + '-' + str(localtime.tm_year) ddlxq = '2' searchCount = 1 print('欢迎使用大连大学成绩查询助手！') print('正在检查网络...') isConnected() with open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'rb') as file: udick = pickle.load(file) sname = udick['sname'] sid = udick['sid'] spwd = udick['spwd'] email_send_to = udick['email_send_to'] final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] while(not login()): continue get_RequiredCourse_num() getScore() counter = 0 while(scorenum &lt;= required_course_num): counter += 1 if(scorenum == required_course_num): print("本学期成绩查询完成！") break if(counter &gt; 0): getScore() except FileNotFoundError: # if os.path.exists(r'' + DstDir + '\\ScoreHelper'): # os.remove(r'' + DstDir + '\\ScoreHelper') os.mkdir(r'' + DstDir + '\\ScoreHelper') # 注：针对Windows目录结构 print('这是你第一次使用，请按提示输入信息，以后可不必再次输入~') sid = input('请输入学号：') sname = input('请输入姓名：') # 隐藏密码 # spwd = getpass.getpass('请输入密码：') spwd = input('请输入密码：') email_send_to = input('请输入要将成绩发送到的邮箱地址：') udick = &#123;'sname': sname, 'sid': sid, 'spwd': spwd, 'email_send_to': email_send_to&#125; file = open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'wb') pickle.dump(udick, file) file.close() final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] while(not login()): sname = input('请输入姓名：') sid = input('请输入学号：') # spwd = getpass.getpass('请输入密码：') spwd = input('请输入密码：') email_send_to = input('请输入要将成绩发送到的邮箱地址：') udick = &#123;'sname': sname, 'sid': sid, 'spwd': spwd, 'email_send_to': email_send_to&#125; file = open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'wb') pickle.dump(udick, file) file.close() final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] get_RequiredCourse_num() getScore() counter = 0 while (scorenum &lt;= required_course_num): counter += 1 if (scorenum == required_course_num): print("本学期成绩查询完成！") break if (counter &gt; 0): getScore() print(scorenum) except subprocess.CalledProcessError: print("网络连接不正常！请检查网络！") except: print("失败！可能是你没有完成教学评价！没有完成教学评价则无法查看成绩！或用户中途取消或网络故障。") finally: # if os.path.exists(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg'): # os.remove(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg') print("程序将在3秒后退出...") time.sleep(3) 当教务网关闭以及断网的时候本程序就不灵了。。。 由于session有时间限制，所以每隔一段时间（约27小时）就要重新登录 最后一次发送成功 截图： 2018-09-25新增——自动获取本学期必修课总数]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理笔记]]></title>
    <url>%2F2018%2F05%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、计算机系统概述计算机由五部分组成：控制器，存储器，运算器，输入设备，输出设备系统结构：计算机系统对各级之间界面的定义，及其上下功能分配。各级都有自己的系统结构，各级之间存在透明性（确实存在，但无法监测设置） 计算机组成是指计算机系统结构的逻辑实现，包括 机器级内的数据通道和控制信号的组成及逻辑设计，他着眼于机器级内各事件的时序方式与控制机构，各部件功能及相互联系 计算机实现是指计算机组成的物理实现 吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量。 CPI(Cycles Per Instruction)：表示每条指令周期数，即执行一条质量所需的平均时钟周期数。计算如下：CPI=执行某段程序所需的CPU时钟周期数/程序包含的指令条数 MIPS(Million Instructions Per Second)：每秒执行多少百万条定点指令数，计算如下：MIPS=指令数/(程序执行的时间*10^6) FLOPS(Floating-point Operations Per Second)：每秒执行浮点操作的次数，用来衡量机器浮点操作的性能，计算如下：FLOPS=程序中的浮点操作次数/程序执行时间(S) 二、数据的机器表示计算机数制：十进制D，二进制B，十六进制H······二进制——&gt;十进制：按权相加十进制——&gt;二进制：除2取余十进制——&gt;十六进制：除16取余十六进制——&gt;十进制：按权相加二进制——&gt;十六进制：四位合一（小数点左或右，每四位合一位）十六进制——&gt;二进制：将十六进制的每位用四位二进制表示 字母ASCII码：A所对应的码是在其十六进制的基础上加37H，小写字母的码比其大写字母对应的码大20H数字ASCII码：在其数字基础上加30H 校验编码和解码为了判断，纠正信息在存入物理设备或传输中被干扰而导致某些信息错误，需要在信息发送（存储）后之前进行编码，在信息接收（读出）后进行解码。校验码编码采用冗余校验（在近笨的有效信息位尚在扩充若干校验位称为冗余位，冗余位越多纠错差错能力越强）的编码思想。奇偶校验：是一种只有一位冗余位的编码方法，常用于主存校验，信息传送。分为奇校验，偶校验两种。奇校验：编码后的有效信息位和奇偶校验位的个数为奇数偶校验：编码后有效信息位和奇偶校验位1的个数为偶数 奇偶校验电路采用异或的方式。如果采用偶校验，将所有信息位异或后得到的就是偶校验位。如果采用奇校验，将所有信息位异或后再取反得到的便是奇校验接收端将接受的全部信息（包括校验位）进行异或运算，如果是偶校验，结果如果为0则正确。如果是奇校验结果为1则正确 海明码编码是一种既能发现错误又能纠正错误的校验码。其中包含n位有效信息位，k位校验位。k位校验位一共有2^k种组合，除去采用一种组合指示是否在传输中出现错误。要满足如下公式：2^k&gt;=n+k+1海明码规定，位号（从左往右数，1为起始）等于2的权值的那些位均可用作奇偶校验位，余下则是信息位。校验位与信息位的关系：信息位的位号等于哪几个校验位相加，就是被哪几个校验位检验。例如：3（2^0+2^1)位号为3的信息位将被位号为0和1的校验位海明码的编码原理校验位的值是其所校验的信息位之异或海明码错误位查询海明码出错指示码称为指误字，他所检验的不仅包含信息位还有，校验位。E0检验p0，E1检验P1，E2检验P2，E3检验P3，E4检验P4。指误字的值是所检验的位异或后的值错误位就是E3E2E1E0海明码的纠错只需将错误位取反 循环冗余校验设带编码的信息以多项式M（x)表示将M(x)左移得到M(x)x^r，使低r位全为0，以便与校验位拼接。校验位用M(x)x^r除以生成多项式G(x)（G(x)必须是r+1位的）所得余数则为校验位。所得的余数与M(x)*x^r相加便为CRC码 CRC码的译码及纠错用CRC码除以G(x)若余数为0，则该码正确。否则，余数即为错误位 三、运算方法运算器符号：正0负1原码表示：======整数：用逗号将符号与数隔开======小数：用.将符号和小数隔开 补码表示：======整数：用逗号将符号位与数值部分隔开，负数或浮点机中正数阶码按位取反加1======小数：用.将符号位与数值隔开，负数数值部分按位取反加1 反码表示：======整数：用逗号将符号位与数值部分隔开，负数或浮点机中正数阶码按位取反======小数：用.将符号位与数值隔开，负数数值部分按位取反 定点表示：小数点固定的数，用来表示纯整数，纯小数。采用定点数的机器称为定点机浮点表示：1.523432^3将正数尾数最高位为1的浮点数称为规格化数，即0.111101012^10浮点机中表示：阶符，阶码；数值 定点数乘除 定点数的乘法机算（原码一位乘）：最先部分积为0，判断乘数最低位（为1则部分积加上被乘数，为0部分积加上0）得到新的部分积，部分积右移一位，乘数得到此数放在最高位同时踢出最低位。当原始乘数全被踢出时运算结束，结果为部分积与新乘数拼接。（补码一位乘）判断乘数是否大于0（大于0则在结果不需加负的被乘数的补码，小于0需要加）（补码符号位为两位）定点数的除法：（恢复余数法）（结果符号位是被除数与除数的符号位的异或）（两个补码的运算，余数为负时需加上除数补码）一开始被除数补码减除数补码，（若余数为负则上商0，加除数补码，余数左移一位后再减除数补码。若余数为正，左移一位，上商1，再减除数补码）直到结果位数与初始除数位数相同（加减交替法）一开始被除数补码减除数补码，（若余数为负则上商0，加除数补码。。。。。。 （补码除法，末位横置1法） 判断被除数补码与除数补码是否同号（同号则减除数补码，异号加除数补码），所得余数判断是否与除数同号（同号则上商1左移1位减除数补码，异号上商0左移一位加除数补码，直到所得商位数为初始商位数减1，所得结果左移一位加1。（！！！！同号减y补上商1，异号加y补上商0） 浮点数加减 加法先对阶，按照小阶看齐大阶原则，使阶小的尾数右移。然后尾数相加，得数若是数值位第一位和符号位相同需左规（左移一位，阶码减1 ）若得数符号位两位不同需右规，再做舍入处理减法先对阶，按照小阶看齐大阶原则，使阶小的尾数右移。然后尾数相减，得数若是数值位第一位和符号位相同需左规（左移一位，阶码减1 ）若得数符号位两位不同需右规，再做舍入处理。阶符为01时为上溢，需做溢出处理，阶符为10时为下溢，按机器零处理。 四、指令系统指令是指计算机执行某些操作的命令，一台计算机的所有指令的集合构成该机的指令系统，也称指令集。寻址技术指的是寻找操作数的地址或下一条将要执行的指令地址，寻址技术是计算机设计中硬件对软件最早提供支持的技术之一。寻找下一条将要执行的指令地址称为指令寻址，寻找操作数的地址称为数据寻址。 s设计指令系统格式直接寻址：OP + A变址寻址：OP + Rx+A寄存器寻址：OP+Rx OP为操作码，A为形式地址，M为寻址特征 五、中央处理器指令流，数据流在程序运行过程中，在计算机的各部件之间流动的指令和数据形成了指令流，数据流。指令流，数据流，不是程序中静态的指令序列和存储器中静态分配序列。指令流指的是cpu执行的指令序列，数据流指的是根据指令操作要求依次存取数据的序列。 cpu的基本功能就是对指令流和数据流在时间与空间上实施正确的控制。 程序计数器（PC）是专用寄存器，又称指令计数器，用来存放正在执行的指令地址，或接着要执行的下一条指令地址。cpu中的主要技术参数cpu的字长：指的是在单位时间内同时处理的二进制数据的位数。cpu按照其处理信息的字长可分为，8位cpu，16位，32位，64位。内部工作频率：又称为内频或主频，它是衡量cpu速度的重要参数。主频表示在cpu内数字脉冲信号震荡的速度。 控制器硬件实现办法控制器分为三种，组合逻辑性，存储逻辑性，组合逻辑和存储逻辑结合型。 指令运行一条指令运行过程可以分为三种阶段：取指令阶段，分析取数阶段，执行阶段。 微程序控制原理微命令：控制部件向执行部件发出的控制命令微操作：是计算机中最基本的不可再分的操作 微命令 和微操作是一一对应的微命令是微操作的控制信号，微操作是微命令的操作过程。 微指令：是控制存储器的一个单元的内容，是若干微命令的集合微地址：存放控制存储单元的单元地址就成为微地址。微周期：从控制存储器中读取一条微指令并执行相应的微命令所需的全部时间微程序：一系列微指令的有序集合就是微程序。每一条机器指令都对应一个微程序。 微指令编码法直接控制法，最短编码法，字段编码法 六、指令流水线七、存储器系统及其层次结构存储器的性能指标存储容量：存储器所能容纳二进制信息的总量。容量单位：位（b) 字节(B)…… 1B=8b 存储器速度：衡量存储器的速度通常有三个相关参数（存取时间，存取周期，存储器带宽） 存储器的分类按存储介质分（磁表面存储器，半导体存储器，光盘存储器）按所处位置分（内存，外村，缓冲存储器（cache））按存取方式分（随机存储器，只读存储器，串行访问存储器） 存储器的层次结构缓存-主存主要解决cpu和主存速度不匹配问题 ，主存和缓存之间的数据调动是由硬件自动完成的主存-辅存层次主要解决存储系统的容量问题，主存和辅存志坚的数据调动是由硬件和操作系统共同完成的 半导体存储器随机存储器RAM：可以通过指令随机的对任意存储单元进行读写访问，RAM通常是住存储器的主要组成部分。分为动态(DRAM，每隔2ms刷新一次)和静态(SRAM)两种只读存储器（ROM)：仅能执行读操作的存储器半导体串行存储器：其数据按位串行读出或写入 存储器芯片存储容量：用常用存储单元个数乘以存储单元的位数计算在存储器中存储1位二进制信息的存储元件称为基本存储单元，若干个基本存储单元组成一个存储字，存储字的位数称为存储器位宽，被一定的规则组合在一起构成一个存储体存储器芯片由存储阵列，译码器，读写控制电路，数据缓冲电路构成。地址译码器：将输入的地址信号（来自cpu发出的地址信号）翻译成某单元（存储字或字节）的选通信号，使该单元能被读写 存储阵列，译码器，读写控制电路分别通过片选信号CE，读写控制信号WE，输出允许信号OE引脚实现。 动态RAM的刷新：刷新即将原信息读出，再生成原信息重新写入。刷新的原因（因为存储单元是随机访问，未得到访问的单元内的原信息可能会消失，因此要定时刷新）通常有三种刷新（集中刷新，分散刷新，异步刷新） 存储器与cpu存储容量的扩展：位拓展，自拓展，字位拓展存储器与cpu的连接：地址线，数据线，读写命令线，片选线 八、互连及输入输出组织九、总线系统总线是连接多个部件的信息传输线，是各部件共享的传输介质。按照总线上传输信号的不同，总线可分为地址总线，控制总线，数据总线三类。地址总线传送的是从cpu等主设备发往从设备的地址信号控制总线传送的是一个部件对另一个部件的控制或状态信息。数据总线传送的是各部件之间交换的数据信息 根据连接方式不同，单处理机系统中采用的总线结构有两种基本类型，即单总线结构，多总线结构。单总线结构使用单一的系统总线连接cpu，主存，I/o设备，允许各设备间的信息直接交换。 简单，易扩充，工作效率低。 多总线结构cpu和缓存之间采用高速的cpu总线，主存在系统总线上，通过桥，cpu总线，系统总线，高速总线彼此相连。 总线的仲裁连接到总线上的功能模块分为主模块，从模块。主模块不固定，有启动一个总线周期的作用。从模块只能响应主模块的请求。每次只能有一个主模块。仲裁就是在多个模块同时竞争总线控制权的时候选择一个主模块。按照总线仲裁电路的位置不同，仲裁分为集中式仲裁和分布式仲裁。 集中式仲裁每个功能模块有两条线连到总线，一条是仲裁请求线br另一条是仲裁授权线bg具体实现方式有链式查询方式，计数器定时查询，独立请求。 链式查询方式：通过判断离总线仲裁器的远近判断其优先级，优先级高的且有仲裁请求则被授权。 总线通信控制总线的通信控制主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调，如何配合，通常用同步通信，异步通信，半同步通信和分离式通信四种方式。 总线传输速率=总线宽度/总线传输周期 异步串行通信的数据传输速率用波特率表示。波特率是指单位时间内传送二进制数据的位数，单位用位/秒表示，记为波特。由于异步通信中包含若干附加位，如起始位，终止位，可用比特率来衡量异步串行通信的有效数据传输速率，即单位时间内传送二进制有效数据的位数单位用位/秒表示。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记 —— 爬取教务网明日课程并发送微信好友]]></title>
    <url>%2F2018%2F05%2F18%2FPython-3-6%E8%8E%B7%E5%8F%96%E6%98%8E%E6%97%A5%E8%AF%BE%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[简介 实现将登录教务网爬取到的课程内容通过微信消息的方式发送给好友，提醒明日课程 主要用到itchat、requests、BeautifulSoup等库 登录的用户名和密码以及爬取下来的验证码需要自己输入 获取本地日期，判断星期几，加一天就是明日的星期数。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218#-*-coding:utf-8-*-import osimport refrom lxml import etreeimport requestsimport sysfrom bs4 import BeautifulSoupimport importlib,sysfrom PIL import Image,ImageEnhancefrom datetime import datetime,dateimport timeimport datetimeimport itchatdef getInfor(response, xpath): content = response.content.decode('gb2312') # 网页源码是gb2312要先解码 selector = etree.HTML(content) infor = selector.xpath(xpath)[0] return infordef get_week_day(date): week_day_dict = &#123; 0 : '星期一', 1 : '星期二', 2 : '星期三', 3 : '星期四', 4 : '星期五', 5 : '星期六', 6 : '星期日' &#125; day = date.weekday() if(day == 6): tomorrow = 0 else: tomorrow = day + 1 return week_day_dict[tomorrow]def get_tomorrow_column(date): column_dict = &#123; '星期一' : 3, '星期二' : 4, '星期三' : 5, '星期四' : 6, '星期五' : 7, '星期六' : 8, '星期日' : 9 &#125; return column_dict[date]def main(): # 设置编码 importlib.reload(sys) # 初始参数，自己输入的学号，密码。 studentnumber = input("学号：") password = input("密码：") # 访问教务系统,前面分析过了，提交数据时要用这个值。先得到__VIEWSTATE的值。 s = requests.session() url = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/default2.aspx" response = s.get(url) selector = etree.HTML(response.content) __VIEWSTATE = selector.xpath('//*[@id="form1"]/input/@value')[0] # 获取验证码并下载到本地 imgUrl = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/CheckCode.aspx?" imgresponse = s.get(imgUrl, stream=True) print (s.cookies) image = imgresponse.content DstDir = os.getcwd()+"\\" print("保存验证码到："+DstDir+"code.jpg"+"\n") try: with open(DstDir+"code.jpg", "wb") as jpg: jpg.write(image) except IOError: print("IO Error\n") finally: jpg.close # 手动输入验证码 image = Image.open('&#123;&#125;/code.jpg'.format(os.getcwd())) image.show() code = input("验证码是：") time.sleep(2) try: image.close() except: print() # 构建post数据 data = &#123; "__VIEWSTATE": __VIEWSTATE, "txtUserName": studentnumber, "TextBox2": password, "txtSecretCode": code, "Button1": "", &#125; # 提交表头，里面的参数是电脑各浏览器的信息。模拟成是浏览器去访问网页。 headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36", &#125; # 登陆教务系统 response = s.post(url, data=data, headers=headers) print ("成功进入") # 得到登录信息，个人感觉有点多余。 # 获取学生基本信息 text = getInfor(response, '//*[@id="xhxm"]/text()') text = text.replace(" ", "") print (text) # 抓一下名字 catch = '&lt;span id="xhxm"&gt;(.*?)&lt;/span&gt;&lt;/em&gt;' name = re.findall(catch, response.text) name = name[0] name = name[:-2] name = str(name).replace(r'\x', '%') # 扩大适用性 name = name.upper() name = name[2:] # 获取课表，kburl是课表页面url,为什么有个Referer参数,这个参数代表你是从哪里来的。就是登录后的主界面参数。这个一定要有。 kburl = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/xskbcx.aspx?xh=" + studentnumber + "&amp;xm=" + name + "&amp;gnmkdm=N121603" headers = &#123; "Referer": "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/xs_main.aspx?xh=" + studentnumber, "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36", &#125; response = s.get(kburl, headers=headers) # html代表访问课表页面返回的结果就是课表。下面做的就是解析这个html页面。 html = response.content.decode("gb2312") soup = BeautifulSoup(response.text,"html.parser") s=soup.find(id='Table1') trs=s.find_all('tr') itchat.auto_login(hotReload=True) while(True): friend = input('请输入好友昵称（输入0退出）：') if(friend == "0"): return users = itchat.search_friends(name= (u''+str(friend))) userName = users[0]['UserName'] # 打印全部课表 # for i in range(11): # td1=trs[i].find_all('td') # for j in td1: # print(j.text[0:6], end='\t') # print() #print(soup) # selector = etree.HTML(html) # content = selector.xpath('//[@id="Table1"]/tbody/tr/td/text()') # for each in content: # print (each) now = datetime.datetime.now() delta = datetime.timedelta(days=1) n_days = now + delta tomorrow = get_week_day(datetime.datetime.now()) date_info = "明天是 " + n_days.strftime('%Y-%m-%d') + " " + tomorrow print("明天是 " + n_days.strftime('%Y-%m-%d') + " " + tomorrow) itchat.send(str(date_info),toUserName = userName) if(n_days.strftime('%m') == "05" and n_days.strftime('%d') &gt;= "01" and n_days.strftime('%d') &lt; "07"): info = "明天没有课程哦，好好享受五一假期！" print("\t明天没有课程哦，好好享受五一假期！") itchat.send(str(info),toUserName = userName) return if(tomorrow == "星期六" or tomorrow == "星期日"): info = "明天没有课程哦！" print("\t明天没有课程哦！") itchat.send(str(info),toUserName = userName) return # 打印明天课表 for i in range(11): if(i==0): continue td1=trs[i].find_all('td') count = 1 # 列数 column = get_tomorrow_column(tomorrow) # 上午第一节课和下午第一节课的标签前面包含有“上午”和“下午”列 for j in td1: if(i == 2 or i == 6 or i == 10): if(count &gt;= 8): continue if(count == column): print(j.text, end='\t') info = j.text if not(info.strip()==''): itchat.send(str(info),toUserName = userName) else: if(count &gt;= 7): continue if(count == column-1): print(j.text, end='\t') info = j.text if not(info.strip()==''): itchat.send(str(info),toUserName = userName) count += 1 print() if(column&lt;8): info = "——这些是明天的课程，注意周次，请做好课前准备" itchat.send(str(info),toUserName = userName) else: info = "明天没有课程哦！" print("\t" + info) itchat.send(str(info),toUserName = userName) print("退出...") if os.path.exists(DstDir+"code.jpg"): #删除文件 os.remove(DstDir+"code.jpg")if __name__ == '__main__': main() 心得 在登录教务网时需要保存cookie信息，否则将无法访问后续网页 爬取网页发送请求的一种方法是用requests，还可以用urllib.request 和 urllib.parse 爬取课程表格时，有“早上”、“上午”、“下午”、“晚上”等列比较特殊，它们和各个时间段的第一行放在一起，所以要特殊处理该行 再接再厉！]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记 —— OpenCV+百度云接口实现人脸认证]]></title>
    <url>%2F2018%2F05%2F17%2FOpenCV-%E7%99%BE%E5%BA%A6%E4%BA%91%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[有话在先前日注册了百度云账号，接触到了百度云的一系列接口，看到“人脸对比”后突发奇想，用人脸识别来做认证（虽然没有Alipay那么高端）模拟登录执行程序。 于是就去百度了百度云接口python实现人脸识别、OpenCV人脸认证。网上实现百度云接口的代码是用Python3写的，但是OpenCV目前只支持Python2；所以我尝试了一下把py3的百度云人脸识别代码改成了py2的。结果……失败了【悲伤.gif】……所以我将就用那个py3，同时安装了py2，然后再在一个程序里面调用另一个程序但是这样做可移植性差，需要用户同时安装py2和py3。 原文python3.6+百度人脸识别API进行照片人脸对比：https://blog.csdn.net/weixin_39133476/article/details/79310817python+OpenCV人脸认证：https://www.cnblogs.com/hanson1/p/7105265.html Python2.x与3​​.x版本区别 Python的3​​.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。 为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。 许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。 为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。 新的Python程式建议使用Python 3.0版本的语法。 除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。 大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。详情阅读：https://blog.csdn.net/ljl6158999/article/details/78983725，https://www.cnblogs.com/sherlockChen/p/8064896.html其实我遇到的问题是库的问题，py3将py2的一些库做了整合和删除，导致py2变py3时会很麻烦 实现方法思想 这需要之前先保存一张人脸的图片，然后调用摄像头拍照获取当前人脸，通过代码上传二者到百度云人脸对比进行比较分析 分析后会有一段返回值，用BeautifulSoup库可取其重点文字：“是同一个人”，“不是同一个人”。二者有重复语句段，在判断的时候要注意。 源代码authentication.py [Python2.7]authentication.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding: utf-8import cv2import osimport timeimport subprocessprint('Press Esc to exit')faceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')faceCascade.load('D:/Program Files/Python/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml')imgWindow = cv2.namedWindow('FaceDetect', cv2.WINDOW_NORMAL)path = os.getcwd()def detect_face(): capInput = cv2.VideoCapture(0) # 避免处理时间过长造成画面卡顿 nextCaptureTime = time.time() faces = [] count = 0 if not capInput.isOpened(): print('Capture failed because of camera') while 1: ret, img = capInput.read() gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if nextCaptureTime &lt; time.time(): nextCaptureTime = time.time() + 0.1 faces = faceCascade.detectMultiScale(gray, 1.3, 5) # if faces: for x, y, w, h in faces: count += 1 img = cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2) cv2.imshow('FaceDetect', img) if count == 8: print(u'检测出人脸') cv2.imwrite(path + '/face.jpg', img) time.sleep(2) break # 这是简单的读取键盘输入，27即Esc的acsii码 if cv2.waitKey(1) &amp; 0xFF == 27: break capInput.release() cv2.destroyAllWindows()def main(): detect_face() program = path + "/FaceCompare.py" command = "py -3 "+ program print(command) os.system(command) if os.path.exists(path + '/face.jpg'): os.remove(path + '/face.jpg')main() FaceCompare.py [Python3.6]FaceCompare.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import sysimport sslfrom urllib import request,parsefrom aip import AipFaceimport tkinter as tk from tkinter import filedialog import osAPP_ID = '你的APP_ID'API_KEY = '你的API_KEY'SECRET_KEY = '你的SECRET_KEY'path = os.getcwd()# client_id 为官网获取的AK， client_secret 为官网获取的SK#获取tokendef get_token(): client_id = API_KEY client_secret = SECRET_KEY host = 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s'%(client_id,client_secret) req = request.Request(host) req.add_header('Content-Type', 'application/json; charset=UTF-8') response = request.urlopen(req) #获得请求结果 content = response.read() #结果转化为字符 content = bytes.decode(content) #转化为字典 content = eval(content[:-1]) return content['access_token']#转换图片#读取文件内容，转换为base64编码#二进制方式打开图文件def imgdata(file1path,file2path): import base64 f=open(r'%s' % file1path,'rb') pic1=base64.b64encode(f.read()) f.close() f=open(r'%s' % file2path,'rb') pic2=base64.b64encode(f.read()) f.close() #将图片信息格式化为可提交信息，这里需要注意str参数设置 params = &#123;"images":str(pic1,'utf-8') + ',' + str(pic2,'utf-8')&#125; return params#提交进行对比获得结果def img(file1path,file2path): token = get_token() #人脸识别API #url = 'https://aip.baidubce.com/rest/2.0/face/v2/detect?access_token='+token #人脸对比API url = 'https://aip.baidubce.com/rest/2.0/face/v2/match?access_token='+token params = imgdata(file1path,file2path) #urlencode处理需提交的数据 data = parse.urlencode(params).encode('utf-8') req = request.Request(url,data=data) req.add_header('Content-Type', 'application/x-www-form-urlencoded') response = request.urlopen(req) content = response.read() content = bytes.decode(content) content = eval(content) #获得分数 score = content['result'][0]['score'] if score&gt;80: return '照片相似度：'+str(score)+',同一个人' else: return '照片相似度：'+str(score)+',不是同一个人'def main(): print("\n************百度云人脸对比************") file1_path = path + '/face.jpg' file2_path = path + '/compared.jpg' # 之前保存的用于对比的图像 print("计算中...") res = img(file1_path,file2_path) print(path) print('\n' + res) print("**************************************\n") if('同一个人' in res): print('认证成功, 进入跑操系统') if os.path.exists(path + '/face.jpg'): os.remove(path + '/face.jpg') command = path + '/SportsSpider.exe' # 上次写的学校跑操系统的爬虫程序 os.system(command) else: print('认证失败')main()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>人脸识别</tag>
        <tag>百度云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记 —— 新版Windows10配置Java环境变量]]></title>
    <url>%2F2018%2F05%2F16%2F%E6%96%B0%E7%89%88Windows10%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[背景在上学期安装好Java后，根据网上的教程配置了环境变量，在cmd里运行”java”成功，而运行”javac”出现“不是内部或外部命令，也不是可运行的程序或批处理文件”的提示。经过了一番苦苦的寻找、测试，终于在百度经验的一篇找到了答案： （原文链接：http://jingyan.baidu.com/article/d5c4b52b80665fda560dc5e4.html）发现的确是环境变量配置的问题。 原料 一台新版的win10(16,17,18版)的电脑 Java jkd/jre 1.8以上版本 人脑 熟练操作鼠标和键盘的手 如何配置首先，右键单击桌面“此电脑”图标，选择“属性”在左侧的菜单栏中选择“高级系统设置” 选择“环境变量” 选择下方的新建，变量名为JAVA_HOME,变量值为你安装jdk的路径，我的是D:\Program Files\Java\jdk1.8.0_182，你的就要看自己的了 然后在新建个，变量名为CLASSPATH，变量值为 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; （注意这里一个符号都不能少，包含了前面的 .; 还有后面的 ;），然后确定 这一步操作之后会出现一个操作界面是14,15版的win10 没有的，所以要注意看，找到Path,然后选择 “编辑” 会出现这个页面，我们选择下面的“编辑文本”，然后确定 重点 在变量值的开始处，找到C: ,在C: 添加这段变量 ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; （注意前后的符号一个都不能少而且是英文的），然后“确定” 编辑完后有两个确定要按 接下来测试时否安装成功，win+R ,然后输入CMD，进入命令提示符”javac” Attention 其中关键的一步是把PATH里的jdk和jre路径放在PATH列表的最前面，这样cmd运行javac时才能先检测到JAVA_HOME系列的路径]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 模拟登录学校教务系统获取四六级成绩]]></title>
    <url>%2F2018%2F05%2F15%2FPython-3-6-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%8F%96%E5%9B%9B%E5%85%AD%E7%BA%A7%E6%88%90%E7%BB%A9%2F</url>
    <content type="text"><![CDATA[简介本程序模拟登录正方教务系统获取本人四六级成绩，并将表格内容写入本地表格。 由于正方网页的每一项都需要cookie来进行访问，在用Chrome单独打开子页面时，网页会直接跳到登录前界面。在用调试查看了post后，发现cookie消失了；但是直接从网页上打开子网页可以访问。所以在登录时就要保存登录信息cookie。 因为个人技术问题，这一段代码是我从网上找的，然后修改使其能访问我们学校的网页，而且现在还不能完成验证码自动识别功能，请各位大佬见谅！ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import requestsimport refrom html.parser import *import urllib.requestimport osimport csvfrom bs4 import BeautifulSoupx = []state = []class Scraper(HTMLParser): def handle_starttag(self, tag, attrs): if tag == 'img': # 验证码 attrs = dict(attrs) if(attrs.__contains__('id')): x.append(attrs["src"]) if tag == 'input': # viewstate attrs = dict(attrs) if attrs.__contains__('name'): if attrs['name'] == '__VIEWSTATE': state.append(attrs['value'])webpage = requests.get(url="http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/default2.aspx")Cookie = webpage.cookies # 获取网页cookiesdate = webpage.textparser = Scraper()parser.feed(date)headers = &#123; 'User-Agent': r'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; TheWorld 7)',&#125;DstDir = os.getcwd()while True: url = "http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/CheckCode.aspx" # 验证码所在连接 pic = requests.get(url, cookies=Cookie, headers=headers) if os.path.exists(r''+DstDir+'\\CheckCode.jpg'): os.remove(r''+DstDir+'\\CheckCode.jpg') with open(r''+DstDir+'\\CheckCode.jpg', 'wb')as f: f.write(pic.content) f.close() username = input("输入用户名: ") password = input("输入密码：") os.startfile(r''+DstDir+'\\CheckCode.jpg') print("验证码在"+DstDir+"\\CheckCode.jpg") ycode = input("输入验证码: ") payload = &#123; '__VIEWSTATE': state[0], 'txtUserName': username, 'TextBox2': password, 'txtSecretCode': ycode, 'RadioButtonList1': '%D1%A7%C9%FA', 'Button1': "", 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '', &#125; Log_in = r"http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/default2.aspx" r = requests.post(url=Log_in, data=payload, headers=headers, cookies=Cookie) # 用正则算了 pat = r'&lt;title&gt;(.*?)&lt;/title&gt;' # 获取标题的正则表达式 x = re.findall(pat, r.text) if(x[0] == "欢迎使用正方教务管理系统！请登录"): print("登陆失败") else: print("登陆成功") # 抓一下名字 catch = '&lt;span id="xhxm"&gt;(.*?)&lt;/span&gt;&lt;/em&gt;' name = re.findall(catch, r.text) name = name[0] name = name[:-2] print(name) breakname = str(name).replace(r'\x', '%') # 扩大适用性name = name.upper()name = name[2:]lheaders = &#123; 'User-Agent': r'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36', 'Referer': 'http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/xs_main.aspx?xh='+username # 扩大适用性&#125;html = requests.get("http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/xsdjkscx.aspx?xh="+username + "&amp;xm="+name+"&amp;gnmkdm=N121606", cookies=Cookie, headers=lheaders)# 最后处理成绩信息selectall = r'&lt;td&gt;(.*?)&lt;/td&gt;'*10result = re.findall(selectall, html.text)xm = result[0] # 项目分离forma = []csvfile = open(DstDir+'\\'+name+'的历年英语等级考试.csv', 'w', newline='')writer = csv.writer(csvfile)temp = ''for i in range(10): forma.append('') # 17位的数据存放处理好的数据for index in range(10): for item in result: temp = format("% -15s" % str(item[index]).strip()) forma[index] += tempfor each in forma: print(each)for num, item in enumerate(result): for index, value in enumerate(item): # 处理下result里面的无规则数据 if value == " ": result[num][index] = ''for item in result: writer.writerow(item)csvfile.close()if os.path.exists(DstDir+"\\CheckCode.jpg"): #删除文件 os.remove(DstDir+"\\CheckCode.jpg")input("爬虫完成,结果存在"+DstDir+"\\"+name+"的历年英语等级考试.csv文件下")]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用itchat库给好友发微信消息]]></title>
    <url>%2F2018%2F05%2F15%2F%E7%94%A8itchat%E5%BA%93%E7%BB%99%E5%A5%BD%E5%8F%8B%E5%8F%91%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[简介itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。微信登录可以通过第三方登录来实现，即网页登录。所以我们可以直接通过调用接口（使用itchat）来实现。详细查看微信网页第三方登录原理：https://www.cnblogs.com/lhat/p/6113803.html 安装可以通过本命令安装itchat：1pip install itchat 简单入门实例有了itchat，如果你想要给文件传输助手发一条信息，只需要这样：12345import itchatitchat.auto_login()itchat.send('Hello, filehelper', toUserName='filehelper') 如果你想要回复发给自己的文本消息，只需要这样：12345678import itchat@itchat.msg_register(itchat.content.TEXT)def text_reply(msg): return msg.textitchat.auto_login()itchat.run() 源代码消息发送12345678910111213141516171819# coding=utf8import itchatimport requestsitchat.auto_login(hotReload=True)friend = input('请输入好友昵称：')# 想给谁发信息，先查找到这个朋友,name后填微信备注即可,deepin测试成功users = itchat.search_friends(name=(u''+str(friend)))# 获取好友全部信息,返回一个列表,列表内是一个字典# print(users)# 获取`UserName`,用于发送消息userName = users[0]['UserName']while(True): a = input("Input: ") itchat.send(str(a), toUserName=userName)]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 模拟登录学校跑操系统获取跑操信息]]></title>
    <url>%2F2018%2F05%2F14%2FPython-3-6-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E8%8E%B7%E5%8F%96%E8%B7%91%E6%93%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[简介本程序通过模拟登录大连大学智慧体育云获取数据该程序要用到requests, BeautifulSoup, re, html.parser等库使用session的post，将用户的数据传给服务器以登录。session可以将用户登录的cookie保存，从而得以进行访问其它网页。BeautifulSoup获取网页数据，并将获取的数据打印在屏幕上。因为学生默认密码为”111111”，所以改过密码的学生无法登录其账号，本程序将其跳过 源代码跑操爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsfrom bs4 import BeautifulSoupimport msvcrtimport refrom html.parser import *session = requests.session()login_data = &#123;'StudentNo': '****', 'Pwd': '111111'&#125;if __name__ == '__main__': i = 16422001 count = 0 count1 = 0 tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^6&#125;\t&#123;2:^4&#125;" print("\n------------------信息学院16级跑操情况------------------n") print(tplt.format("学号", "姓名", "跑操次数", chr(12288))) while(i &lt;= 16429060): if(count1 &gt; 70): i+=930 count1=0 login_data['StudentNo'] = str(i) response = session.post("http://isscp.dlu.edu.cn/User/UserLogin", data=login_data) if("true" in response.text): i += 1 count1 += 1 continue res = session.get("http://isscp.dlu.edu.cn/Movement/Sign?dc=30&amp;ds=0") res1 = session.get("http://isscp.dlu.edu.cn/My/Index") soup = BeautifulSoup(res.text, "html.parser") soup1 = BeautifulSoup(res1.text, "html.parser") text = soup.find('p', 'data_p_two') text1 = soup1.find('span', 'my_row_right_name') text2 = soup1.find('span', 'my_row_right_department') name = text1.find('p') department = text2.find('p') print(tplt.format(str(i), name.text, text.text, chr(12288))) i += 1 count += 1 count1 += 1 print("\n共计" + str(count) + "人, 按任意键退出...\n") msvcrt.getch()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积神经网络]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[This is the beginning of the garden tour. 卷积神经网络（Convolutional Neural Network,CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。 [2] 它包括卷积层(convolutional layer)和池化层(pooling layer)。卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。20世纪60年代，Hubel和Wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络（Convolutional Neural Networks-简称CNN）。现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。 K.Fukushima在1980年提出的新识别机是卷积神经网络的第一个实现网络。随后，更多的科研工作者对该网络进行了改进。其中，具有代表性的研究成果是Alexander和Taylor提出的“改进认知机”，该方法综合了各种改进方法的优点并避免了耗时的误差反向传播。 一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。 CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。]]></content>
      <tags>
        <tag>test article</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
