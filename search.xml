<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习笔记 —— OpenCV+百度云接口实现人脸认证]]></title>
    <url>%2F2018%2F05%2F17%2FOpenCV-%E7%99%BE%E5%BA%A6%E4%BA%91%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[有话在先前日注册了百度云账号，接触到了百度云的一系列接口，看到“人脸对比”后突发奇想，用人脸识别来做认证（虽然没有Alipay那么高端）模拟登录执行程序。于是就去百度了百度云接口python实现人脸识别、OpenCV人脸认证。网上实现百度云接口的代码是用Python3写的，但是OpenCV目前只支持Python2；所以我尝试了一下把py3的百度云人脸识别代码改成了py2的。结果……失败了【悲伤.gif】……所以我将就用那个py3，同时安装了py2，然后再在一个程序里面调用另一个程序但是这样做可移植性差，需要用户同时安装py2和py3。 原文python3.6+百度人脸识别API进行照片人脸对比：https://blog.csdn.net/weixin_39133476/article/details/79310817python+OpenCV人脸认证：https://www.cnblogs.com/hanson1/p/7105265.html Python2.x与3​​.x版本区别 Python的3​​.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。 为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。 许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。 为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。 新的Python程式建议使用Python 3.0版本的语法。 除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。 大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。详情阅读：https://blog.csdn.net/ljl6158999/article/details/78983725，https://www.cnblogs.com/sherlockChen/p/8064896.html其实我遇到的问题是库的问题，py3将py2的一些库做了整合和删除，导致py2变py3时会很麻烦 实现方法思想 这需要之前先保存一张人脸的图片，然后调用摄像头拍照获取当前人脸，通过代码上传二者到百度云人脸对比进行比较分析 分析后会有一段返回值，用BeautifulSoup库可取其重点文字：“是同一个人”，“不是同一个人”。二者有重复语句段，在判断的时候要注意。 源代码authentication.py [Python2.7]authentication.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding: utf-8import cv2import osimport timeimport subprocessprint('Press Esc to exit')faceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')faceCascade.load('D:/Program Files/Python/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml')imgWindow = cv2.namedWindow('FaceDetect', cv2.WINDOW_NORMAL)path = os.getcwd()def detect_face(): capInput = cv2.VideoCapture(0) # 避免处理时间过长造成画面卡顿 nextCaptureTime = time.time() faces = [] count = 0 if not capInput.isOpened(): print('Capture failed because of camera') while 1: ret, img = capInput.read() gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if nextCaptureTime &lt; time.time(): nextCaptureTime = time.time() + 0.1 faces = faceCascade.detectMultiScale(gray, 1.3, 5) # if faces: for x, y, w, h in faces: count += 1 img = cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2) cv2.imshow('FaceDetect', img) if count == 8: print(u'检测出人脸') cv2.imwrite(path + '/face.jpg', img) time.sleep(2) break # 这是简单的读取键盘输入，27即Esc的acsii码 if cv2.waitKey(1) &amp; 0xFF == 27: break capInput.release() cv2.destroyAllWindows()def main(): detect_face() program = path + "/FaceCompare.py" command = "py -3 "+ program print(command) os.system(command) if os.path.exists(path + '/face.jpg'): os.remove(path + '/face.jpg')main() FaceCompare.py [Python3.6]FaceCompare.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import sysimport sslfrom urllib import request,parsefrom aip import AipFaceimport tkinter as tk from tkinter import filedialog import osAPP_ID = '你的APP_ID'API_KEY = '你的API_KEY'SECRET_KEY = '你的SECRET_KEY'path = os.getcwd()# client_id 为官网获取的AK， client_secret 为官网获取的SK#获取tokendef get_token(): client_id = API_KEY client_secret = SECRET_KEY host = 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s'%(client_id,client_secret) req = request.Request(host) req.add_header('Content-Type', 'application/json; charset=UTF-8') response = request.urlopen(req) #获得请求结果 content = response.read() #结果转化为字符 content = bytes.decode(content) #转化为字典 content = eval(content[:-1]) return content['access_token']#转换图片#读取文件内容，转换为base64编码#二进制方式打开图文件def imgdata(file1path,file2path): import base64 f=open(r'%s' % file1path,'rb') pic1=base64.b64encode(f.read()) f.close() f=open(r'%s' % file2path,'rb') pic2=base64.b64encode(f.read()) f.close() #将图片信息格式化为可提交信息，这里需要注意str参数设置 params = &#123;"images":str(pic1,'utf-8') + ',' + str(pic2,'utf-8')&#125; return params#提交进行对比获得结果def img(file1path,file2path): token = get_token() #人脸识别API #url = 'https://aip.baidubce.com/rest/2.0/face/v2/detect?access_token='+token #人脸对比API url = 'https://aip.baidubce.com/rest/2.0/face/v2/match?access_token='+token params = imgdata(file1path,file2path) #urlencode处理需提交的数据 data = parse.urlencode(params).encode('utf-8') req = request.Request(url,data=data) req.add_header('Content-Type', 'application/x-www-form-urlencoded') response = request.urlopen(req) content = response.read() content = bytes.decode(content) content = eval(content) #获得分数 score = content['result'][0]['score'] if score&gt;80: return '照片相似度：'+str(score)+',同一个人' else: return '照片相似度：'+str(score)+',不是同一个人'def main(): print("\n************百度云人脸对比************") file1_path = path + '/face.jpg' file2_path = path + '/compared.jpg' # 之前保存的用于对比的图像 print("计算中...") res = img(file1_path,file2_path) print(path) print('\n' + res) print("**************************************\n") if('同一个人' in res): print('认证成功, 进入跑操系统') if os.path.exists(path + '/face.jpg'): os.remove(path + '/face.jpg') command = path + '/SportsSpider.exe' # 上次写的学校跑操系统的爬虫程序 os.system(command) else: print('认证失败')main()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>人脸识别</tag>
        <tag>百度云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记 —— 新版Windows10配置Java环境变量]]></title>
    <url>%2F2018%2F05%2F16%2F%E6%96%B0%E7%89%88Windows10%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[背景在上学期安装好Java后，根据网上的教程配置了环境变量，在cmd里运行”java”成功，而运行”javac”出现“不是内部或外部命令，也不是可运行的程序或批处理文件”的提示。经过了一番苦苦的寻找、测试，终于在百度经验的一篇找到了答案：（原文链接：http://jingyan.baidu.com/article/d5c4b52b80665fda560dc5e4.html）发现的确是环境变量配置的问题。 原料 一台新版的win10(16,17,18版)的电脑 Java jkd/jre 1.8以上版本 人脑 熟练操作鼠标和键盘的手 如何配置首先，右键单击桌面“此电脑”图标，选择“属性”在左侧的菜单栏中选择“高级系统设置” 选择“环境变量” 选择下方的新建，变量名为JAVA_HOME,变量值为你安装jdk的路径，我的是D:\Program Files\Java\jdk1.8.0_182，你的就要看自己的了 然后在新建个，变量名为CLASSPATH，变量值为 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; （注意这里一个符号都不能少，包含了前面的 .; 还有后面的 ;），然后确定 这一步操作之后会出现一个操作界面是14,15版的win10 没有的，所以要注意看，找到Path,然后选择 “编辑” 会出现这个页面，我们选择下面的“编辑文本”，然后确定 重点 在变量值的开始处，找到C: ,在C: 添加这段变量 ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; （注意前后的符号一个都不能少而且是英文的），然后“确定” 编辑完后有两个确定要按 接下来测试时否安装成功，win+R ,然后输入CMD，进入命令提示符”javac” Attention 其中关键的一步是把PATH里的jdk和jre路径放在PATH列表的最前面，这样cmd运行javac时才能先检测到JAVA_HOME系列的路径]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 模拟登录学校教务系统获取四六级成绩]]></title>
    <url>%2F2018%2F05%2F15%2FPython-3-6-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%8F%96%E5%9B%9B%E5%85%AD%E7%BA%A7%E6%88%90%E7%BB%A9%2F</url>
    <content type="text"><![CDATA[简介本程序模拟登录正方教务系统获取本人四六级成绩，并将表格内容写入本地表格。 由于正方网页的每一项都需要cookie来进行访问，在用Chrome单独打开子页面时，网页会直接跳到登录前界面。在用调试查看了post后，发现cookie消失了；但是直接从网页上打开子网页可以访问。所以在登录时就要保存登录信息cookie。 因为个人技术问题，这一段代码是我从网上找的，然后修改使其能访问我们学校的网页，而且现在还不能完成验证码自动识别功能，请各位大佬见谅！ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import requestsimport refrom html.parser import *import urllib.requestimport osimport csvfrom bs4 import BeautifulSoupx = []state = []class Scraper(HTMLParser): def handle_starttag(self, tag, attrs): if tag == 'img': # 验证码 attrs = dict(attrs) if(attrs.__contains__('id')): x.append(attrs["src"]) if tag == 'input': # viewstate attrs = dict(attrs) if attrs.__contains__('name'): if attrs['name'] == '__VIEWSTATE': state.append(attrs['value'])webpage = requests.get(url="http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/default2.aspx")Cookie = webpage.cookies # 获取网页cookiesdate = webpage.textparser = Scraper()parser.feed(date)headers = &#123; 'User-Agent': r'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; TheWorld 7)',&#125;DstDir = os.getcwd()while True: url = "http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/CheckCode.aspx" # 验证码所在连接 pic = requests.get(url, cookies=Cookie, headers=headers) if os.path.exists(r''+DstDir+'\\CheckCode.jpg'): os.remove(r''+DstDir+'\\CheckCode.jpg') with open(r''+DstDir+'\\CheckCode.jpg', 'wb')as f: f.write(pic.content) f.close() username = input("输入用户名: ") password = input("输入密码：") os.startfile(r''+DstDir+'\\CheckCode.jpg') print("验证码在"+DstDir+"\\CheckCode.jpg") ycode = input("输入验证码: ") payload = &#123; '__VIEWSTATE': state[0], 'txtUserName': username, 'TextBox2': password, 'txtSecretCode': ycode, 'RadioButtonList1': '%D1%A7%C9%FA', 'Button1': "", 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '', &#125; Log_in = r"http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/default2.aspx" r = requests.post(url=Log_in, data=payload, headers=headers, cookies=Cookie) # 用正则算了 pat = r'&lt;title&gt;(.*?)&lt;/title&gt;' # 获取标题的正则表达式 x = re.findall(pat, r.text) if(x[0] == "欢迎使用正方教务管理系统！请登录"): print("登陆失败") else: print("登陆成功") # 抓一下名字 catch = '&lt;span id="xhxm"&gt;(.*?)&lt;/span&gt;&lt;/em&gt;' name = re.findall(catch, r.text) name = name[0] name = name[:-2] print(name) breakname = str(name).replace(r'\x', '%') # 扩大适用性name = name.upper()name = name[2:]lheaders = &#123; 'User-Agent': r'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36', 'Referer': 'http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/xs_main.aspx?xh='+username # 扩大适用性&#125;html = requests.get("http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/xsdjkscx.aspx?xh="+username + "&amp;xm="+name+"&amp;gnmkdm=N121606", cookies=Cookie, headers=lheaders)# 最后处理成绩信息selectall = r'&lt;td&gt;(.*?)&lt;/td&gt;'*10result = re.findall(selectall, html.text)xm = result[0] # 项目分离forma = []csvfile = open(DstDir+'\\'+name+'的历年英语等级考试.csv', 'w', newline='')writer = csv.writer(csvfile)temp = ''for i in range(10): forma.append('') # 17位的数据存放处理好的数据for index in range(10): for item in result: temp = format("% -15s" % str(item[index]).strip()) forma[index] += tempfor each in forma: print(each)for num, item in enumerate(result): for index, value in enumerate(item): # 处理下result里面的无规则数据 if value == " ": result[num][index] = ''for item in result: writer.writerow(item)csvfile.close()if os.path.exists(DstDir+"\\CheckCode.jpg"): #删除文件 os.remove(DstDir+"\\CheckCode.jpg")input("爬虫完成,结果存在"+DstDir+"\\"+name+"的历年英语等级考试.csv文件下")]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用itchat库给好友发微信消息]]></title>
    <url>%2F2018%2F05%2F15%2F%E7%94%A8itchat%E5%BA%93%E7%BB%99%E5%A5%BD%E5%8F%8B%E5%8F%91%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[简介itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。微信登录可以通过第三方登录来实现，即网页登录。所以我们可以直接通过调用接口（使用itchat）来实现。详细查看微信网页第三方登录原理：https://www.cnblogs.com/lhat/p/6113803.html 安装可以通过本命令安装itchat：1pip install itchat 简单入门实例有了itchat，如果你想要给文件传输助手发一条信息，只需要这样：12345import itchatitchat.auto_login()itchat.send('Hello, filehelper', toUserName='filehelper') 如果你想要回复发给自己的文本消息，只需要这样：12345678import itchat@itchat.msg_register(itchat.content.TEXT)def text_reply(msg): return msg.textitchat.auto_login()itchat.run() 源代码消息发送12345678910111213141516171819# coding=utf8import itchatimport requestsitchat.auto_login(hotReload=True)friend = input('请输入好友昵称：')# 想给谁发信息，先查找到这个朋友,name后填微信备注即可,deepin测试成功users = itchat.search_friends(name=(u''+str(friend)))# 获取好友全部信息,返回一个列表,列表内是一个字典# print(users)# 获取`UserName`,用于发送消息userName = users[0]['UserName']while(True): a = input("Input: ") itchat.send(str(a), toUserName=userName)]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 模拟登录学校跑操系统获取跑操信息]]></title>
    <url>%2F2018%2F05%2F14%2FPython-3-6-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E8%8E%B7%E5%8F%96%E8%B7%91%E6%93%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[简介本程序通过模拟登录大连大学智慧体育云获取数据该程序要用到requests, BeautifulSoup, re, html.parser等库使用session的post，将用户的数据传给服务器以登录。session可以将用户登录的cookie保存，从而得以进行访问其它网页。BeautifulSoup获取网页数据，并将获取的数据打印在屏幕上。因为学生默认密码为”111111”，所以改过密码的学生无法登录其账号，本程序将其跳过 源代码跑操爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsfrom bs4 import BeautifulSoupimport msvcrtimport refrom html.parser import *session = requests.session()login_data = &#123;'StudentNo': '****', 'Pwd': '111111'&#125;if __name__ == '__main__': i = 16422001 count = 0 count1 = 0 tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^6&#125;\t&#123;2:^4&#125;" print("\n------------------信息学院16级跑操情况------------------n") print(tplt.format("学号", "姓名", "跑操次数", chr(12288))) while(i &lt;= 16429060): if(count1 &gt; 70): i+=930 count1=0 login_data['StudentNo'] = str(i) response = session.post("http://isscp.dlu.edu.cn/User/UserLogin", data=login_data) if("true" in response.text): i += 1 count1 += 1 continue res = session.get("http://isscp.dlu.edu.cn/Movement/Sign?dc=30&amp;ds=0") res1 = session.get("http://isscp.dlu.edu.cn/My/Index") soup = BeautifulSoup(res.text, "html.parser") soup1 = BeautifulSoup(res1.text, "html.parser") text = soup.find('p', 'data_p_two') text1 = soup1.find('span', 'my_row_right_name') text2 = soup1.find('span', 'my_row_right_department') name = text1.find('p') department = text2.find('p') print(tplt.format(str(i), name.text, text.text, chr(12288))) i += 1 count += 1 count1 += 1 print("\n共计" + str(count) + "人, 按任意键退出...\n") msvcrt.getch()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积神经网络]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[卷积神经网络（Convolutional Neural Network,CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。 [2] 它包括卷积层(convolutional layer)和池化层(pooling layer)。卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。20世纪60年代，Hubel和Wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络（Convolutional Neural Networks-简称CNN）。现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。 K.Fukushima在1980年提出的新识别机是卷积神经网络的第一个实现网络。随后，更多的科研工作者对该网络进行了改进。其中，具有代表性的研究成果是Alexander和Taylor提出的“改进认知机”，该方法综合了各种改进方法的优点并避免了耗时的误差反向传播。 一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。 CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。]]></content>
      <tags>
        <tag>This is the beginning of the garden tour.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
