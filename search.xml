<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计算机组成原理笔记]]></title>
    <url>%2F2018%2F05%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、计算机系统概述计算机由五部分组成：控制器，存储器，运算器，输入设备，输出设备 系统结构：计算机系统对各级之间界面的定义，及其上下功能分配。各级都有自己的系统结构，各级之间存在透明性（确实存在，但无法监测设置） 计算机组成是指计算机系统结构的逻辑实现，包括 机器级内的数据通道和控制信号的组成及逻辑设计，他着眼于机器级内各事件的时序方式与控制机构，各部件功能及相互联系 计算机实现是指计算机组成的物理实现 吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量。 CPI(Cycles Per Instruction)：表示每条指令周期数，即执行一条质量所需的平均时钟周期数。计算如下：CPI=执行某段程序所需的CPU时钟周期数/程序包含的指令条数 MIPS(Million Instructions Per Second)：每秒执行多少百万条定点指令数，计算如下：MIPS=指令数/(程序执行的时间*10^6) FLOPS(Floating-point Operations Per Second)：每秒执行浮点操作的次数，用来衡量机器浮点操作的性能，计算如下：FLOPS=程序中的浮点操作次数/程序执行时间(S) 二、数据的机器表示计算机数制：十进制D，二进制B，十六进制H······二进制——&gt;十进制：按权相加十进制——&gt;二进制：除2取余十进制——&gt;十六进制：除16取余十六进制——&gt;十进制：按权相加二进制——&gt;十六进制：四位合一（小数点左或右，每四位合一位）十六进制——&gt;二进制：将十六进制的每位用四位二进制表示 字母ASCII码：A所对应的码是在其十六进制的基础上加37H，小写字母的码比其大写字母对应的码大20H数字ASCII码：在其数字基础上加30H 校验编码和解码为了判断，纠正信息在存入物理设备或传输中被干扰而导致某些信息错误，需要在信息发送（存储）后之前进行编码，在信息接收（读出）后进行解码。校验码编码采用冗余校验（在近笨的有效信息位尚在扩充若干校验位称为冗余位，冗余位越多纠错差错能力越强）的编码思想。奇偶校验：是一种只有一位冗余位的编码方法，常用于主存校验，信息传送。分为奇校验，偶校验两种。奇校验：编码后的有效信息位和奇偶校验位的个数为奇数偶校验：编码后有效信息位和奇偶校验位1的个数为偶数 奇偶校验电路采用异或的方式。如果采用偶校验，将所有信息位异或后得到的就是偶校验位。如果采用奇校验，将所有信息位异或后再取反得到的便是奇校验接收端将接受的全部信息（包括校验位）进行异或运算，如果是偶校验，结果如果为0则正确。如果是奇校验结果为1则正确 海明码编码是一种既能发现错误又能纠正错误的校验码。其中包含n位有效信息位，k位校验位。k位校验位一共有2^k种组合，除去采用一种组合指示是否在传输中出现错误。要满足如下公式：2^k&gt;=n+k+1海明码规定，位号（从左往右数，1为起始）等于2的权值的那些位均可用作奇偶校验位，余下则是信息位。校验位与信息位的关系：信息位的位号等于哪几个校验位相加，就是被哪几个校验位检验。例如：3（2^0+2^1)位号为3的信息位将被位号为0和1的校验位海明码的编码原理校验位的值是其所校验的信息位之异或海明码错误位查询海明码出错指示码称为指误字，他所检验的不仅包含信息位还有，校验位。E0检验p0，E1检验P1，E2检验P2，E3检验P3，E4检验P4。指误字的值是所检验的位异或后的值错误位就是E3E2E1E0海明码的纠错只需将错误位取反 循环冗余校验设带编码的信息以多项式M（x)表示将M(x)左移得到M(x)x^r，使低r位全为0，以便与校验位拼接。校验位用M(x)x^r除以生成多项式G(x)（G(x)必须是r+1位的）所得余数则为校验位。所得的余数与M(x)*x^r相加便为CRC码 CRC码的译码及纠错用CRC码除以G(x)若余数为0，则该码正确。否则，余数即为错误位 三、运算方法运算器符号：正0负1原码表示：======整数：用逗号将符号与数隔开======小数：用.将符号和小数隔开 补码表示：======整数：用逗号将符号位与数值部分隔开，负数或浮点机中正数阶码按位取反加1======小数：用.将符号位与数值隔开，负数数值部分按位取反加1 反码表示：======整数：用逗号将符号位与数值部分隔开，负数或浮点机中正数阶码按位取反======小数：用.将符号位与数值隔开，负数数值部分按位取反 定点表示：小数点固定的数，用来表示纯整数，纯小数。采用定点数的机器称为定点机浮点表示：1.523432^3将正数尾数最高位为1的浮点数称为规格化数，即0.111101012^10浮点机中表示：阶符，阶码；数值 定点数乘除 定点数的乘法机算（原码一位乘）：最先部分积为0，判断乘数最低位（为1则部分积加上被乘数，为0部分积加上0）得到新的部分积，部分积右移一位，乘数得到此数放在最高位同时踢出最低位。当原始乘数全被踢出时运算结束，结果为部分积与新乘数拼接。（补码一位乘）判断乘数是否大于0（大于0则在结果不需加负的被乘数的补码，小于0需要加）（补码符号位为两位）定点数的除法：（恢复余数法）（结果符号位是被除数与除数的符号位的异或）（两个补码的运算，余数为负时需加上除数补码）一开始被除数补码减除数补码，（若余数为负则上商0，加除数补码，余数左移一位后再减除数补码。若余数为正，左移一位，上商1，再减除数补码）直到结果位数与初始除数位数相同（加减交替法）一开始被除数补码减除数补码，（若余数为负则上商0，加除数补码。。。。。。 （补码除法，末位横置1法） 判断被除数补码与除数补码是否同号（同号则减除数补码，异号加除数补码），所得余数判断是否与除数同号（同号则上商1左移1位减除数补码，异号上商0左移一位加除数补码，直到所得商位数为初始商位数减1，所得结果左移一位加1。（！！！！同号减y补上商1，异号加y补上商0） 浮点数加减 加法先对阶，按照小阶看齐大阶原则，使阶小的尾数右移。然后尾数相加，得数若是数值位第一位和符号位相同需左规（左移一位，阶码减1 ）若得数符号位两位不同需右规，再做舍入处理减法先对阶，按照小阶看齐大阶原则，使阶小的尾数右移。然后尾数相减，得数若是数值位第一位和符号位相同需左规（左移一位，阶码减1 ）若得数符号位两位不同需右规，再做舍入处理。阶符为01时为上溢，需做溢出处理，阶符为10时为下溢，按机器零处理。 四、指令系统指令是指计算机执行某些操作的命令，一台计算机的所有指令的集合构成该机的指令系统，也称指令集。寻址技术指的是寻找操作数的地址或下一条将要执行的指令地址，寻址技术是计算机设计中硬件对软件最早提供支持的技术之一。寻找下一条将要执行的指令地址称为指令寻址，寻找操作数的地址称为数据寻址。 s设计指令系统格式直接寻址：OP + A变址寻址：OP + Rx+A寄存器寻址：OP+Rx OP为操作码，A为形式地址，M为寻址特征P116 #5.1 #5.2 #5.3 #5.4 五、中央处理器指令流，数据流在程序运行过程中，在计算机的各部件之间流动的指令和数据形成了指令流，数据流。指令流，数据流，不是程序中静态的指令序列和存储器中静态分配序列。指令流指的是cpu执行的指令序列，数据流指的是根据指令操作要求依次存取数据的序列。 cpu的基本功能就是对指令流和数据流在时间与空间上实施正确的控制。 程序计数器（PC）是专用寄存器，又称指令计数器，用来存放正在执行的指令地址，或接着要执行的下一条指令地址。cpu中的主要技术参数cpu的字长：指的是在单位时间内同时处理的二进制数据的位数。cpu按照其处理信息的字长可分为，8位cpu，16位，32位，64位。内部工作频率：又称为内频或主频，它是衡量cpu速度的重要参数。主频表示在cpu内数字脉冲信号震荡的速度。 控制器硬件实现办法控制器分为三种，组合逻辑性，存储逻辑性，组合逻辑和存储逻辑结合型。 指令运行一条指令运行过程可以分为三种阶段：取指令阶段，分析取数阶段，执行阶段。 微程序控制原理微命令：控制部件向执行部件发出的控制命令微操作：是计算机中最基本的不可再分的操作 微命令 和微操作是一一对应的微命令是微操作的控制信号，微操作是微命令的操作过程。 微指令：是控制存储器的一个单元的内容，是若干微命令的集合微地址：存放控制存储单元的单元地址就成为微地址。微周期：从控制存储器中读取一条微指令并执行相应的微命令所需的全部时间微程序：一系列微指令的有序集合就是微程序。每一条机器指令都对应一个微程序。 微指令编码法直接控制法，最短编码法，字段编码法 六、指令流水线七、存储器系统及其层次结构存储器的性能指标存储容量：存储器所能容纳二进制信息的总量。容量单位：位（b) 字节(B)…… 1B=8b 存储器速度：衡量存储器的速度通常有三个相关参数（存取时间，存取周期，存储器带宽） 存储器的分类按存储介质分（磁表面存储器，半导体存储器，光盘存储器）按所处位置分（内存，外村，缓冲存储器（cache））按存取方式分（随机存储器，只读存储器，串行访问存储器） 存储器的层次结构缓存-主存主要解决cpu和主存速度不匹配问题 ，主存和缓存之间的数据调动是由硬件自动完成的主存-辅存层次主要解决存储系统的容量问题，主存和辅存志坚的数据调动是由硬件和操作系统共同完成的 半导体存储器随机存储器RAM：可以通过指令随机的对任意存储单元进行读写访问，RAM通常是住存储器的主要组成部分。分为动态(DRAM，每隔2ms刷新一次)和静态(SRAM)两种只读存储器（ROM)：仅能执行读操作的存储器半导体串行存储器：其数据按位串行读出或写入 存储器芯片存储容量：用常用存储单元个数乘以存储单元的位数计算在存储器中存储1位二进制信息的存储元件称为基本存储单元，若干个基本存储单元组成一个存储字，存储字的位数称为存储器位宽，被一定的规则组合在一起构成一个存储体存储器芯片由存储阵列，译码器，读写控制电路，数据缓冲电路构成。地址译码器：将输入的地址信号（来自cpu发出的地址信号）翻译成某单元（存储字或字节）的选通信号，使该单元能被读写 存储阵列，译码器，读写控制电路分别通过片选信号CE，读写控制信号WE，输出允许信号OE引脚实现。 动态RAM的刷新：刷新即将原信息读出，再生成原信息重新写入。刷新的原因（因为存储单元是随机访问，未得到访问的单元内的原信息可能会消失，因此要定时刷新）通常有三种刷新（集中刷新，分散刷新，异步刷新） 存储器与cpu存储容量的扩展：位拓展，自拓展，字位拓展存储器与cpu的连接：地址线，数据线，读写命令线，片选线]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理, 考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记 —— 爬取教务网明日课程并发送微信好友]]></title>
    <url>%2F2018%2F05%2F18%2FPython3-6%E8%8E%B7%E5%8F%96%E6%98%8E%E6%97%A5%E8%AF%BE%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[简介 实现将登录教务网爬取到的课程内容通过微信消息的方式发送给好友，提醒明日课程 主要用到itchat、requests、BeautifulSoup等库 登录的用户名和密码以及爬取下来的验证码需要自己输入 获取本地日期，判断星期几，加一天就是明日的星期数。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218#-*-coding:utf-8-*-import osimport refrom lxml import etreeimport requestsimport sysfrom bs4 import BeautifulSoupimport importlib,sysfrom PIL import Image,ImageEnhancefrom datetime import datetime,dateimport timeimport datetimeimport itchatdef getInfor(response, xpath): content = response.content.decode('gb2312') # 网页源码是gb2312要先解码 selector = etree.HTML(content) infor = selector.xpath(xpath)[0] return infordef get_week_day(date): week_day_dict = &#123; 0 : '星期一', 1 : '星期二', 2 : '星期三', 3 : '星期四', 4 : '星期五', 5 : '星期六', 6 : '星期日' &#125; day = date.weekday() if(day == 6): tomorrow = 0 else: tomorrow = day + 1 return week_day_dict[tomorrow]def get_tomorrow_column(date): column_dict = &#123; '星期一' : 3, '星期二' : 4, '星期三' : 5, '星期四' : 6, '星期五' : 7, '星期六' : 8, '星期日' : 9 &#125; return column_dict[date]def main(): # 设置编码 importlib.reload(sys) # 初始参数，自己输入的学号，密码。 studentnumber = input("学号：") password = input("密码：") # 访问教务系统,前面分析过了，提交数据时要用这个值。先得到__VIEWSTATE的值。 s = requests.session() url = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/default2.aspx" response = s.get(url) selector = etree.HTML(response.content) __VIEWSTATE = selector.xpath('//*[@id="form1"]/input/@value')[0] # 获取验证码并下载到本地 imgUrl = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/CheckCode.aspx?" imgresponse = s.get(imgUrl, stream=True) print (s.cookies) image = imgresponse.content DstDir = os.getcwd()+"\\" print("保存验证码到："+DstDir+"code.jpg"+"\n") try: with open(DstDir+"code.jpg", "wb") as jpg: jpg.write(image) except IOError: print("IO Error\n") finally: jpg.close # 手动输入验证码 image = Image.open('&#123;&#125;/code.jpg'.format(os.getcwd())) image.show() code = input("验证码是：") time.sleep(2) try: image.close() except: print() # 构建post数据 data = &#123; "__VIEWSTATE": __VIEWSTATE, "txtUserName": studentnumber, "TextBox2": password, "txtSecretCode": code, "Button1": "", &#125; # 提交表头，里面的参数是电脑各浏览器的信息。模拟成是浏览器去访问网页。 headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36", &#125; # 登陆教务系统 response = s.post(url, data=data, headers=headers) print ("成功进入") # 得到登录信息，个人感觉有点多余。 # 获取学生基本信息 text = getInfor(response, '//*[@id="xhxm"]/text()') text = text.replace(" ", "") print (text) # 抓一下名字 catch = '&lt;span id="xhxm"&gt;(.*?)&lt;/span&gt;&lt;/em&gt;' name = re.findall(catch, response.text) name = name[0] name = name[:-2] name = str(name).replace(r'\x', '%') # 扩大适用性 name = name.upper() name = name[2:] # 获取课表，kburl是课表页面url,为什么有个Referer参数,这个参数代表你是从哪里来的。就是登录后的主界面参数。这个一定要有。 kburl = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/xskbcx.aspx?xh=" + studentnumber + "&amp;xm=" + name + "&amp;gnmkdm=N121603" headers = &#123; "Referer": "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/xs_main.aspx?xh=" + studentnumber, "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36", &#125; response = s.get(kburl, headers=headers) # html代表访问课表页面返回的结果就是课表。下面做的就是解析这个html页面。 html = response.content.decode("gb2312") soup = BeautifulSoup(response.text,"html.parser") s=soup.find(id='Table1') trs=s.find_all('tr') itchat.auto_login(hotReload=True) while(True): friend = input('请输入好友昵称（输入0退出）：') if(friend == "0"): return users = itchat.search_friends(name= (u''+str(friend))) userName = users[0]['UserName'] # 打印全部课表 # for i in range(11): # td1=trs[i].find_all('td') # for j in td1: # print(j.text[0:6], end='\t') # print() #print(soup) # selector = etree.HTML(html) # content = selector.xpath('//[@id="Table1"]/tbody/tr/td/text()') # for each in content: # print (each) now = datetime.datetime.now() delta = datetime.timedelta(days=1) n_days = now + delta tomorrow = get_week_day(datetime.datetime.now()) date_info = "明天是 " + n_days.strftime('%Y-%m-%d') + " " + tomorrow print("明天是 " + n_days.strftime('%Y-%m-%d') + " " + tomorrow) itchat.send(str(date_info),toUserName = userName) if(n_days.strftime('%m') == "05" and n_days.strftime('%d') &gt;= "01" and n_days.strftime('%d') &lt; "07"): info = "明天没有课程哦，好好享受五一假期！" print("\t明天没有课程哦，好好享受五一假期！") itchat.send(str(info),toUserName = userName) return if(tomorrow == "星期六" or tomorrow == "星期日"): info = "明天没有课程哦！" print("\t明天没有课程哦！") itchat.send(str(info),toUserName = userName) return # 打印明天课表 for i in range(11): if(i==0): continue td1=trs[i].find_all('td') count = 1 # 列数 column = get_tomorrow_column(tomorrow) # 上午第一节课和下午第一节课的标签前面包含有“上午”和“下午”列 for j in td1: if(i == 2 or i == 6 or i == 10): if(count &gt;= 8): continue if(count == column): print(j.text, end='\t') info = j.text if not(info.strip()==''): itchat.send(str(info),toUserName = userName) else: if(count &gt;= 7): continue if(count == column-1): print(j.text, end='\t') info = j.text if not(info.strip()==''): itchat.send(str(info),toUserName = userName) count += 1 print() if(column&lt;8): info = "——这些是明天的课程，注意周次，请做好课前准备" itchat.send(str(info),toUserName = userName) else: info = "明天没有课程哦！" print("\t" + info) itchat.send(str(info),toUserName = userName) print("退出...") if os.path.exists(DstDir+"code.jpg"): #删除文件 os.remove(DstDir+"code.jpg")if __name__ == '__main__': main() 心得 在登录教务网时需要保存cookie信息，否则将无法访问后续网页 爬取网页发送请求的一种方法是用requests，还可以用urllib.request 和 urllib.parse 爬取课程表格时，有“早上”、“上午”、“下午”、“晚上”等列比较特殊，它们和各个时间段的第一行放在一起，所以要特殊处理该行 再接再厉！]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记 —— OpenCV+百度云接口实现人脸认证]]></title>
    <url>%2F2018%2F05%2F17%2FOpenCV-%E7%99%BE%E5%BA%A6%E4%BA%91%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[有话在先前日注册了百度云账号，接触到了百度云的一系列接口，看到“人脸对比”后突发奇想，用人脸识别来做认证（虽然没有Alipay那么高端）模拟登录执行程序。于是就去百度了百度云接口python实现人脸识别、OpenCV人脸认证。网上实现百度云接口的代码是用Python3写的，但是OpenCV目前只支持Python2；所以我尝试了一下把py3的百度云人脸识别代码改成了py2的。结果……失败了【悲伤.gif】……所以我将就用那个py3，同时安装了py2，然后再在一个程序里面调用另一个程序但是这样做可移植性差，需要用户同时安装py2和py3。 原文python3.6+百度人脸识别API进行照片人脸对比：https://blog.csdn.net/weixin_39133476/article/details/79310817python+OpenCV人脸认证：https://www.cnblogs.com/hanson1/p/7105265.html Python2.x与3​​.x版本区别 Python的3​​.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。 为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。 许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。 为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。 新的Python程式建议使用Python 3.0版本的语法。 除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。 大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。详情阅读：https://blog.csdn.net/ljl6158999/article/details/78983725，https://www.cnblogs.com/sherlockChen/p/8064896.html其实我遇到的问题是库的问题，py3将py2的一些库做了整合和删除，导致py2变py3时会很麻烦 实现方法思想 这需要之前先保存一张人脸的图片，然后调用摄像头拍照获取当前人脸，通过代码上传二者到百度云人脸对比进行比较分析 分析后会有一段返回值，用BeautifulSoup库可取其重点文字：“是同一个人”，“不是同一个人”。二者有重复语句段，在判断的时候要注意。 源代码authentication.py [Python2.7]authentication.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding: utf-8import cv2import osimport timeimport subprocessprint('Press Esc to exit')faceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')faceCascade.load('D:/Program Files/Python/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml')imgWindow = cv2.namedWindow('FaceDetect', cv2.WINDOW_NORMAL)path = os.getcwd()def detect_face(): capInput = cv2.VideoCapture(0) # 避免处理时间过长造成画面卡顿 nextCaptureTime = time.time() faces = [] count = 0 if not capInput.isOpened(): print('Capture failed because of camera') while 1: ret, img = capInput.read() gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if nextCaptureTime &lt; time.time(): nextCaptureTime = time.time() + 0.1 faces = faceCascade.detectMultiScale(gray, 1.3, 5) # if faces: for x, y, w, h in faces: count += 1 img = cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2) cv2.imshow('FaceDetect', img) if count == 8: print(u'检测出人脸') cv2.imwrite(path + '/face.jpg', img) time.sleep(2) break # 这是简单的读取键盘输入，27即Esc的acsii码 if cv2.waitKey(1) &amp; 0xFF == 27: break capInput.release() cv2.destroyAllWindows()def main(): detect_face() program = path + "/FaceCompare.py" command = "py -3 "+ program print(command) os.system(command) if os.path.exists(path + '/face.jpg'): os.remove(path + '/face.jpg')main() FaceCompare.py [Python3.6]FaceCompare.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import sysimport sslfrom urllib import request,parsefrom aip import AipFaceimport tkinter as tk from tkinter import filedialog import osAPP_ID = '你的APP_ID'API_KEY = '你的API_KEY'SECRET_KEY = '你的SECRET_KEY'path = os.getcwd()# client_id 为官网获取的AK， client_secret 为官网获取的SK#获取tokendef get_token(): client_id = API_KEY client_secret = SECRET_KEY host = 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s'%(client_id,client_secret) req = request.Request(host) req.add_header('Content-Type', 'application/json; charset=UTF-8') response = request.urlopen(req) #获得请求结果 content = response.read() #结果转化为字符 content = bytes.decode(content) #转化为字典 content = eval(content[:-1]) return content['access_token']#转换图片#读取文件内容，转换为base64编码#二进制方式打开图文件def imgdata(file1path,file2path): import base64 f=open(r'%s' % file1path,'rb') pic1=base64.b64encode(f.read()) f.close() f=open(r'%s' % file2path,'rb') pic2=base64.b64encode(f.read()) f.close() #将图片信息格式化为可提交信息，这里需要注意str参数设置 params = &#123;"images":str(pic1,'utf-8') + ',' + str(pic2,'utf-8')&#125; return params#提交进行对比获得结果def img(file1path,file2path): token = get_token() #人脸识别API #url = 'https://aip.baidubce.com/rest/2.0/face/v2/detect?access_token='+token #人脸对比API url = 'https://aip.baidubce.com/rest/2.0/face/v2/match?access_token='+token params = imgdata(file1path,file2path) #urlencode处理需提交的数据 data = parse.urlencode(params).encode('utf-8') req = request.Request(url,data=data) req.add_header('Content-Type', 'application/x-www-form-urlencoded') response = request.urlopen(req) content = response.read() content = bytes.decode(content) content = eval(content) #获得分数 score = content['result'][0]['score'] if score&gt;80: return '照片相似度：'+str(score)+',同一个人' else: return '照片相似度：'+str(score)+',不是同一个人'def main(): print("\n************百度云人脸对比************") file1_path = path + '/face.jpg' file2_path = path + '/compared.jpg' # 之前保存的用于对比的图像 print("计算中...") res = img(file1_path,file2_path) print(path) print('\n' + res) print("**************************************\n") if('同一个人' in res): print('认证成功, 进入跑操系统') if os.path.exists(path + '/face.jpg'): os.remove(path + '/face.jpg') command = path + '/SportsSpider.exe' # 上次写的学校跑操系统的爬虫程序 os.system(command) else: print('认证失败')main()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>人脸识别</tag>
        <tag>百度云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记 —— 新版Windows10配置Java环境变量]]></title>
    <url>%2F2018%2F05%2F16%2F%E6%96%B0%E7%89%88Windows10%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[背景在上学期安装好Java后，根据网上的教程配置了环境变量，在cmd里运行”java”成功，而运行”javac”出现“不是内部或外部命令，也不是可运行的程序或批处理文件”的提示。经过了一番苦苦的寻找、测试，终于在百度经验的一篇找到了答案：（原文链接：http://jingyan.baidu.com/article/d5c4b52b80665fda560dc5e4.html）发现的确是环境变量配置的问题。 原料 一台新版的win10(16,17,18版)的电脑 Java jkd/jre 1.8以上版本 人脑 熟练操作鼠标和键盘的手 如何配置首先，右键单击桌面“此电脑”图标，选择“属性”在左侧的菜单栏中选择“高级系统设置” 选择“环境变量” 选择下方的新建，变量名为JAVA_HOME,变量值为你安装jdk的路径，我的是D:\Program Files\Java\jdk1.8.0_182，你的就要看自己的了 然后在新建个，变量名为CLASSPATH，变量值为 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; （注意这里一个符号都不能少，包含了前面的 .; 还有后面的 ;），然后确定 这一步操作之后会出现一个操作界面是14,15版的win10 没有的，所以要注意看，找到Path,然后选择 “编辑” 会出现这个页面，我们选择下面的“编辑文本”，然后确定 重点 在变量值的开始处，找到C: ,在C: 添加这段变量 ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; （注意前后的符号一个都不能少而且是英文的），然后“确定” 编辑完后有两个确定要按 接下来测试时否安装成功，win+R ,然后输入CMD，进入命令提示符”javac” Attention 其中关键的一步是把PATH里的jdk和jre路径放在PATH列表的最前面，这样cmd运行javac时才能先检测到JAVA_HOME系列的路径]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 模拟登录学校教务系统获取四六级成绩]]></title>
    <url>%2F2018%2F05%2F15%2FPython-3-6-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%8F%96%E5%9B%9B%E5%85%AD%E7%BA%A7%E6%88%90%E7%BB%A9%2F</url>
    <content type="text"><![CDATA[简介本程序模拟登录正方教务系统获取本人四六级成绩，并将表格内容写入本地表格。 由于正方网页的每一项都需要cookie来进行访问，在用Chrome单独打开子页面时，网页会直接跳到登录前界面。在用调试查看了post后，发现cookie消失了；但是直接从网页上打开子网页可以访问。所以在登录时就要保存登录信息cookie。 因为个人技术问题，这一段代码是我从网上找的，然后修改使其能访问我们学校的网页，而且现在还不能完成验证码自动识别功能，请各位大佬见谅！ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import requestsimport refrom html.parser import *import urllib.requestimport osimport csvfrom bs4 import BeautifulSoupx = []state = []class Scraper(HTMLParser): def handle_starttag(self, tag, attrs): if tag == 'img': # 验证码 attrs = dict(attrs) if(attrs.__contains__('id')): x.append(attrs["src"]) if tag == 'input': # viewstate attrs = dict(attrs) if attrs.__contains__('name'): if attrs['name'] == '__VIEWSTATE': state.append(attrs['value'])webpage = requests.get(url="http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/default2.aspx")Cookie = webpage.cookies # 获取网页cookiesdate = webpage.textparser = Scraper()parser.feed(date)headers = &#123; 'User-Agent': r'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; TheWorld 7)',&#125;DstDir = os.getcwd()while True: url = "http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/CheckCode.aspx" # 验证码所在连接 pic = requests.get(url, cookies=Cookie, headers=headers) if os.path.exists(r''+DstDir+'\\CheckCode.jpg'): os.remove(r''+DstDir+'\\CheckCode.jpg') with open(r''+DstDir+'\\CheckCode.jpg', 'wb')as f: f.write(pic.content) f.close() username = input("输入用户名: ") password = input("输入密码：") os.startfile(r''+DstDir+'\\CheckCode.jpg') print("验证码在"+DstDir+"\\CheckCode.jpg") ycode = input("输入验证码: ") payload = &#123; '__VIEWSTATE': state[0], 'txtUserName': username, 'TextBox2': password, 'txtSecretCode': ycode, 'RadioButtonList1': '%D1%A7%C9%FA', 'Button1': "", 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '', &#125; Log_in = r"http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/default2.aspx" r = requests.post(url=Log_in, data=payload, headers=headers, cookies=Cookie) # 用正则算了 pat = r'&lt;title&gt;(.*?)&lt;/title&gt;' # 获取标题的正则表达式 x = re.findall(pat, r.text) if(x[0] == "欢迎使用正方教务管理系统！请登录"): print("登陆失败") else: print("登陆成功") # 抓一下名字 catch = '&lt;span id="xhxm"&gt;(.*?)&lt;/span&gt;&lt;/em&gt;' name = re.findall(catch, r.text) name = name[0] name = name[:-2] print(name) breakname = str(name).replace(r'\x', '%') # 扩大适用性name = name.upper()name = name[2:]lheaders = &#123; 'User-Agent': r'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36', 'Referer': 'http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/xs_main.aspx?xh='+username # 扩大适用性&#125;html = requests.get("http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/xsdjkscx.aspx?xh="+username + "&amp;xm="+name+"&amp;gnmkdm=N121606", cookies=Cookie, headers=lheaders)# 最后处理成绩信息selectall = r'&lt;td&gt;(.*?)&lt;/td&gt;'*10result = re.findall(selectall, html.text)xm = result[0] # 项目分离forma = []csvfile = open(DstDir+'\\'+name+'的历年英语等级考试.csv', 'w', newline='')writer = csv.writer(csvfile)temp = ''for i in range(10): forma.append('') # 17位的数据存放处理好的数据for index in range(10): for item in result: temp = format("% -15s" % str(item[index]).strip()) forma[index] += tempfor each in forma: print(each)for num, item in enumerate(result): for index, value in enumerate(item): # 处理下result里面的无规则数据 if value == " ": result[num][index] = ''for item in result: writer.writerow(item)csvfile.close()if os.path.exists(DstDir+"\\CheckCode.jpg"): #删除文件 os.remove(DstDir+"\\CheckCode.jpg")input("爬虫完成,结果存在"+DstDir+"\\"+name+"的历年英语等级考试.csv文件下")]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用itchat库给好友发微信消息]]></title>
    <url>%2F2018%2F05%2F15%2F%E7%94%A8itchat%E5%BA%93%E7%BB%99%E5%A5%BD%E5%8F%8B%E5%8F%91%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[简介itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。微信登录可以通过第三方登录来实现，即网页登录。所以我们可以直接通过调用接口（使用itchat）来实现。详细查看微信网页第三方登录原理：https://www.cnblogs.com/lhat/p/6113803.html 安装可以通过本命令安装itchat：1pip install itchat 简单入门实例有了itchat，如果你想要给文件传输助手发一条信息，只需要这样：12345import itchatitchat.auto_login()itchat.send('Hello, filehelper', toUserName='filehelper') 如果你想要回复发给自己的文本消息，只需要这样：12345678import itchat@itchat.msg_register(itchat.content.TEXT)def text_reply(msg): return msg.textitchat.auto_login()itchat.run() 源代码消息发送12345678910111213141516171819# coding=utf8import itchatimport requestsitchat.auto_login(hotReload=True)friend = input('请输入好友昵称：')# 想给谁发信息，先查找到这个朋友,name后填微信备注即可,deepin测试成功users = itchat.search_friends(name=(u''+str(friend)))# 获取好友全部信息,返回一个列表,列表内是一个字典# print(users)# 获取`UserName`,用于发送消息userName = users[0]['UserName']while(True): a = input("Input: ") itchat.send(str(a), toUserName=userName)]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 模拟登录学校跑操系统获取跑操信息]]></title>
    <url>%2F2018%2F05%2F14%2FPython-3-6-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E8%8E%B7%E5%8F%96%E8%B7%91%E6%93%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[简介本程序通过模拟登录大连大学智慧体育云获取数据该程序要用到requests, BeautifulSoup, re, html.parser等库使用session的post，将用户的数据传给服务器以登录。session可以将用户登录的cookie保存，从而得以进行访问其它网页。BeautifulSoup获取网页数据，并将获取的数据打印在屏幕上。因为学生默认密码为”111111”，所以改过密码的学生无法登录其账号，本程序将其跳过 源代码跑操爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsfrom bs4 import BeautifulSoupimport msvcrtimport refrom html.parser import *session = requests.session()login_data = &#123;'StudentNo': '****', 'Pwd': '111111'&#125;if __name__ == '__main__': i = 16422001 count = 0 count1 = 0 tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^6&#125;\t&#123;2:^4&#125;" print("\n------------------信息学院16级跑操情况------------------n") print(tplt.format("学号", "姓名", "跑操次数", chr(12288))) while(i &lt;= 16429060): if(count1 &gt; 70): i+=930 count1=0 login_data['StudentNo'] = str(i) response = session.post("http://isscp.dlu.edu.cn/User/UserLogin", data=login_data) if("true" in response.text): i += 1 count1 += 1 continue res = session.get("http://isscp.dlu.edu.cn/Movement/Sign?dc=30&amp;ds=0") res1 = session.get("http://isscp.dlu.edu.cn/My/Index") soup = BeautifulSoup(res.text, "html.parser") soup1 = BeautifulSoup(res1.text, "html.parser") text = soup.find('p', 'data_p_two') text1 = soup1.find('span', 'my_row_right_name') text2 = soup1.find('span', 'my_row_right_department') name = text1.find('p') department = text2.find('p') print(tplt.format(str(i), name.text, text.text, chr(12288))) i += 1 count += 1 count1 += 1 print("\n共计" + str(count) + "人, 按任意键退出...\n") msvcrt.getch()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积神经网络]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[卷积神经网络（Convolutional Neural Network,CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。 [2] 它包括卷积层(convolutional layer)和池化层(pooling layer)。卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。20世纪60年代，Hubel和Wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络（Convolutional Neural Networks-简称CNN）。现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。 K.Fukushima在1980年提出的新识别机是卷积神经网络的第一个实现网络。随后，更多的科研工作者对该网络进行了改进。其中，具有代表性的研究成果是Alexander和Taylor提出的“改进认知机”，该方法综合了各种改进方法的优点并避免了耗时的误差反向传播。 一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。 CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。]]></content>
      <tags>
        <tag>This is the beginning of the garden tour.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
