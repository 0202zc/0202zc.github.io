<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[就地逆置线性表元素]]></title>
    <url>%2F2020%2F01%2F18%2F%E5%B0%B1%E5%9C%B0%E9%80%86%E7%BD%AE%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[本文分为线性表逆置操作的基本操作和扩展操作 基本操作顺序表 设计一个高效算法，将顺序表L的所有元素逆置，要求空间复杂度为O(1) 方法一扫描前半部分元素，对于L.data[i]（0&lt;i&lt;L.length/2），与后半部分对应元素L.data[L.length-i-1].data交换12345678void Reverse(SqList &amp;L) &#123; ElemType temp; for(int i=0;i&lt;L.length/2;i++) &#123; temp = L.data[i]; L.data[i] = L.data[L.length-i-1]; L.data[L.length-i-1] = temp; &#125;&#125; 方法二用两个指针i、j分别指向数组的前后123456789void Reverse(int *a[], int n)&#123; int i=0, j=n-1, temp; While(i&lt;j)&#123; temp=a[i]; a[i]=a[j]; a[j]=temp; i++; j--; &#125;&#125; 单链表逆置链表（带头结点L）用“头插法”。尾插时，最后一个结点的指针要置空。12345678910void Reverse(LinkList L) &#123; LinkNode *p=L-&gt;next, *q; L-&gt;next=NULL; while(p!=NULL)&#123; q=p-&gt;next; p-&gt;next=L-&gt;next; L-&gt;next=p; p=q; &#125;&#125; 双链表逆置双链表除了上述的步骤外，还多了两个指针，p的后继的前驱和p的前驱的后继12345678910111213void Reverse(DLinkList L) &#123; DLinkNode *p=L-&gt;next, *q; L-&gt;next=NULL; while(p!=NULL)&#123; q=p-&gt;next; p-&gt;next=L-&gt;next; if(p-&gt;next!=NULL) //第一个用“头插法”插入L的结点没有后继 P-&gt;next-&gt;prior=p; L-&gt;next=p; p-&gt;prior=L; p=q; &#125;&#125; 扩展操作两个顺序表位置互换 一维数组A[m+n]中一次存放两个线性表(a1, a2, …, am)和(b1, b2 , …, bn)。编写一个算法，将数组中两个线性表的位置互换—&gt;(b1,b2,…,bn, a1,a2,…,am) 算法思想：将A[m+n]中全部元素逆置为(bn, bn-1, …, b2, b1, am, am-1, …, a2, a1)，再对前n个元素和后m个元素分别逆置123456789101112131415161718void Reverse(int A[], int left, int right, int arraySize)&#123; //逆置(aleft, aleft+1, …, aright) if(left&gt;=right||right&gt;=arraySize) return; int mid=(left+right)/2; for(int i = 0; i&lt;= mid - left; i++)&#123; //这里i作为下标的增量 int temp=A[left+i]; A[left+i]=a[right-i]; A[right-i]=temp; &#125;&#125;void Exchange(int A[], int m, int n, int arraySize)&#123; //数组A[m+n]中，从0到m-1存放顺序表(a1,a2,…,am)，从m到n-1存放(b1,b2,…,bn) Reverse(A, 0, m+n-1, arraySize); Reverse(A, 0, n-1, arraySize); Reverse(A, n, m+n-1, arraySize);&#125; 三个顺序表位置互换 设规模n=3m, m≥1的顺序表存储在一维数组int array[n]中，它含有的元素为(a1,a2,…,am, b1, b2 , …, bm,c1,c2,…,cm)。请编写算法将上述顺序表改造成为(c1,c2,…,cm, bm, …, b2, b1, a1,a2,…,am)，要求时间复杂度和空间复杂度尽可能低。 1234567891011121314void Reverse(int array[], int left, int right) &#123; int temp, mid, i; //i作为下标增量 mid = (left+right)/2; for(i = 0; i &lt;= mid - left; i++)&#123; temp=a[left+i]; a[left+i]=a[right-i]; a[right-i]=temp; &#125;&#125;void Exchange(int array[], int m)&#123; Reverse(array, 0, 3m-1); Reverse(array, 0, m-1); Reverse(array, 2m, 3m-1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件控制块与索引节点的总结]]></title>
    <url>%2F2019%2F11%2F24%2FFCB%E4%B8%8Einode%2F</url>
    <content type="text"><![CDATA[序言文件控制块（FCB）与索引结点（inode）都是操作系统文件管理中逻辑结构的重要部分。在今日考研复习过程中，基本解决了以前遇到的“FCB与inode”的问题，现以此博文记录该知识点。 文件控制块与索引结点这需要从目录结构说起。 文件目录：包含有关文件的信息，信息主要有：属性，位置，所有权。这些信息主要是由OS进行管理。把所有的FCB组织在一起，就构成了文件目录，即文件控制块的有序集合，其包含许多目录项（即FCB）。目录管理的基本要求：从用户角度看待，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射。目录管理提供的是：按名存取。 共享系统中目录还需要提供控制访问文件的信息。重名问题主要通过树形结构来解决。 采用索引结点的方式来实现目录，好处是文件目录的目录项长度会缩短很多。因为通过文件目录实现对文件的按名存取时，在寻找文件的过程中只需要用到文件名这个信息，而其他信息在寻找文件的时候没有必要。如果一个目录中存放了很多个文件，采用传统的以FCB构成目录项的方式，那么这个文件目录会非常大，因为每个目录项就特别大。而采用索引结点的方式实现目录，每个目录项就会很小，只包含文件名和指向索引结点的指针。可以提高文件检索速度。 FCB：文件控制块。用于存放控制文件的各种信息的数据结构，实现了按名存取。 总结如下表： 此处有个小问题： 某科技大学的OS考研试卷填空题答案中索引节点分为文件描述信息和i结点，而资料书上说的是索引节点即为i结点 检索目录文件（FCB的集合）时只用到了文件名。仅当找到一个目录项时才需要从该目录项（FCB）中读出该文件的物理地址。即：检索目录时文件的其他描述信息用不到，也因此不必调入内存。那么我们是否可以考虑，把文件名和文件的描述信息(FCB-文件名)分开，文件的描述信息单独形成一个数据结构，这个被称作索引结点。简称为i结点。这样就可以简化目录结构为：文件名对应i结点指针。比如在UNIX系统中，文件目录项（FCB）占16B，其中14B是文件名，2B是i结点指针。注意到设计i结点的设计思路是怎么得到的，就很容易理解FCB和i结点包含的信息大部分是相同的，i结点只是抽出了文件名。每个文件对应一个文件名，则一个文件也只要一个i结点。 存放在磁盘上的索引结点称为磁盘索引结点。 文件控制块与索引节点的区别个人总结：从文件目录结构来看，UNIX中， 文件目录由FCB（目录项）组成 FCB = 文件名 + inode inode包含了文件物理地址信息 物理地址信息的组成主要是主索引表如图所示: 个人能力有限，总结有问题请指出。]]></content>
      <categories>
        <category>计算机操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 监控爬取成绩并推送到邮箱(基于百度云接口的验证码识别)]]></title>
    <url>%2F2018%2F12%2F28%2FPython-3-6-%E7%9B%91%E6%8E%A7%E7%88%AC%E5%8F%96%E6%88%90%E7%BB%A9%E5%B9%B6%E6%8E%A8%E9%80%81%E5%88%B0%E9%82%AE%E7%AE%B1(%E5%9F%BA%E4%BA%8E%E7%99%BE%E5%BA%A6%E4%BA%91%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB)%2F</url>
    <content type="text"><![CDATA[简介本程序模拟登录正方教务系统获取本人当前学期成绩（也可以手动改学期学年），20分钟检测一次，当有新成绩公布时就发送到邮箱，本程序用到的是我学校的教务网网址。 本项目GitHub地址大连大学成绩监控查询脚本 第一代手动输入验证码的程序Python 3.6 监控爬取成绩并推送到邮箱 验证码识别参照了XiaoYaoII的文章利用python3 爬取教务处实现自动查询成绩并发送给用户QQ邮箱 使用百度云文字识别的SDK的帮助文档在此Python SDK文档 实现思想本程序的实现主要步骤有： 首先登录进入成绩查询页面 将对应的所有成绩爬取下来 将爬取下来的成绩进行格式化（表格） 美化后的成绩表格发送到邮箱 详细步骤 登录 得到跳转后页面的地址（为了防止登录重复，教务系统后面会跳转后在网址后面加一串随机的hash码） 利用百度云识别验证码 将需要的列爬取下来 每次爬取后让程序暂停20分钟，将每次所爬取的成绩数量进行对比，如果与第一次爬取的数量相同则不发邮件，否则发送邮件 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701'''大连大学成绩查询助手V1.7.190216Code By ZC Liang2018.6.6Completed on 2019.2.15'''import getpassimport http.cookiejarimport osimport pickleimport platformimport randomimport reimport smtplibimport subprocessimport sysimport timeimport urllib.parseimport urllib.requestfrom email.mime.text import MIMETextfrom email.utils import formataddrimport bs4import numpy as npimport pandas as pdimport prettytable as ptimport pymysqlimport requestsfrom aip import AipOcrfrom bs4 import BeautifulSoupfrom PIL import Imagefrom prettytable import PrettyTablefrom requests import ReadTimeoutfrom requests import ConnectionErrormy_sender = '发件人邮箱账号' # 发件人邮箱账号my_pass = '发件人邮箱密码' # 发件人邮箱密码(当时申请smtp给的口令)# my_user = '收件人邮箱账号' # 收件人邮箱账号，我这边发送给自己email_send_to = '' # 收件人邮箱账号DstDir = os.getcwd()searchCount = 0 # 查询次数count = 0 # 循环计数scorenum = 0 # 成绩条数score = []scorenp = np.array(score)makeup_course_num = 0 # 重修课程数目makeup_course_flag = -1 # 重修课程数目下标courseList = [] # 选课情况查询列表required_course_num = 0 # 本学期必修课总数# 准备Cookie和opener，因为cookie存于opener中，所以以下所有网页操作全部要基于同一个openercookie = http.cookiejar.CookieJar()opener = urllib.request.build_opener( urllib.request.HTTPCookieProcessor(cookie))final_url = "" # 头 + 随机编码 + default2.aspxfinal_url_head = ""url_head = "202.199.155." + str(random.randint(33, 37)) # 随机产生网址ddlxn = ""ddlxq = """"" 你的 APPID AK SK """APP_ID = '你的 APP_ID'API_KEY = '你的 API_KEY'SECRET_KEY = '你的 SECRET_KEY'client = AipOcr(APP_ID, API_KEY, SECRET_KEY)""" 读取图片 """def get_file_content(filePath): with open(filePath, 'rb') as fp: return fp.read()# 判断操作系统类型def getOpeningSystem(): return platform.system()# 判断操作系统类型def getOpeningSystem(): return platform.system()# 判断是否联网def isConnected(): try: response = requests.get('http://' + url_head, timeout=1) if response.status_code == 200: return True else: print('网络检测错误status_code: ' + response.status_code, 'http://' + url_head) return False except (ConnectionError, ReadTimeout): print('无网络连接。')# 获取重定向编码def check_for_redirects(url): r = requests.head(url) if r.ok: return r.headers['location'] else: return '[no redirect]'# 图像转换并识别def image_util(img): new_im = img.convert("RGB") # 将验证码图片转换成24位图片 new_im.save('' + DstDir + '\\ScoreHelper\\CheckCode1.jpg') # 将24位图片保存到本地 arr = np.array(Image.open('' + DstDir + '\\ScoreHelper\\CheckCode1.jpg').convert("L")) b = 255 - arr im = Image.fromarray(b.astype('uint8')) # 翻转 # d = 255 * (arr / 255) ** 2 # im = Image.fromarray(d.astype('uint8')) # 灰度 # 此处验证过，翻转比灰度识别率更高 im.save('' + DstDir + '\\ScoreHelper\\CheckCode2.jpg')# 验证码识别def code_recognition(): try: # 调用百度云识别验证码 result = client.basicAccurate(get_file_content('' + DstDir + '\\ScoreHelper\\CheckCode2.jpg')) word = result.get('words_result') res = "" if len(word): res = re.findall('[a-zA-Z0-9]+', word[0].get('words'))[0] elif len(res) &gt; 4: # 教务系统所有的验证码都是四位的，若大于四位，则挑选前四位 res = res[0:4] return res except Exception as e: print(e)# 登陆def login(): # 构造表单 params = &#123; 'txtUserName': sid, 'Textbox1': '', 'Textbox2': spwd, 'RadioButtonList1': '学生', 'Button1': '', 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '', &#125; # 获取验证码 res = opener.open(final_url_head + '/checkcode.aspx').read() with open('' + DstDir + '\\ScoreHelper\\CheckCode.jpg', 'wb') as file: file.write(res) img = Image.open('' + DstDir + '\\ScoreHelper\\CheckCode.jpg') # 图片处理 image_util(img) # img.show() print('验证码识别结果：' + code_recognition()) vcode = code_recognition() # img.close() params['txtSecretCode'] = vcode # 获取ViewState response = urllib.request.urlopen('http://' + url_head + '/') html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 尝试登陆 loginurl = final_url print("\n本次登录所用网址为：" + loginurl + "\n") data = urllib.parse.urlencode(params).encode('gb2312') response = opener.open(loginurl, data) if response.geturl() == final_url: print('登陆失败，可能是姓名，学号，密码或验证码填写错误！') return False else: return True# 获取本学期必修课数目def get_RequiredCourse_num(): global required_course_num print("正在查询本学期必修课数目...") # 构造url url = ''.join([ final_url_head + '/xsxkqk.aspx', '?xh=', sid, '&amp;xm=', urllib.parse.quote(sname), '&amp;gnmkdm=N121615', ]) # 构建查询学生选课情况表单 params = &#123; 'ddlxn': ddlxn, 'ddlxq': ddlxq, &#125; # 构造Request对象，填入Header，防止302跳转，获取新的View_State req = urllib.request.Request(url) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') req.add_header( 'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = opener.open(req) html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 查询所有成绩 req = urllib.request.Request( url, urllib.parse.urlencode(params).encode('gb2312')) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') response = opener.open(req) soup = BeautifulSoup(response.read().decode('gb2312'), 'html.parser') html = soup.find('table', class_='datelist') # 指定要输出的列，原网页的表格列下标从0开始 # 用于标记是否是遍历第一行 flag = True # 根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象 # 遍历行 counter = 0 for each in html: columnCounter = 0 column = [] if type(each) == bs4.element.NavigableString: pass else: # 遍历列 for item in each.contents: if item != '\n': if counter &gt; 0 and columnCounter == 3: courseList.append(str(item.contents[0]).strip()) columnCounter += 1 if flag: flag = False counter += 1 for each in courseList: if each == "必修课程": required_course_num += 1# 获取成绩def getScore(): global searchCount global scorenum global scorenp global ddlxn global ddlxq score = [] # 构造url url = ''.join([ final_url_head + '/xscjcx_dq.aspx', '?xh=', sid, '&amp;xm=', urllib.parse.quote(sname), '&amp;gnmkdm=N121605', ]) # 构建查询全部成绩表单 params = &#123; 'ddlxn': ddlxn, # 全部为 %C8%AB%B2%BF 'ddlxq': ddlxq, 'btnCx': '查询', &#125; # 构造Request对象，填入Header，防止302跳转，获取新的View_State req = urllib.request.Request(url) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') req.add_header( 'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = opener.open(req) html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 查询所有成绩 req = urllib.request.Request( url, urllib.parse.urlencode(params).encode('gb2312')) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') response = opener.open(req) soup = BeautifulSoup(response.read().decode('gb2312'), 'html.parser') html = soup.find('table', class_='datelist') print("执行第" + str(searchCount) + "次查询：") print('你的所有成绩如下：') # 指定要输出的列，原网页的表格列下标从0开始 outColumn = [3, 4, 6, 7, 9, 11, 13] # 用于标记是否是遍历第一行 flag = True # 根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象 # 遍历行 for each in html: columnCounter = 0 column = [] if type(each) == bs4.element.NavigableString: pass else: # 遍历列 for item in each.contents: if item != '\n': if columnCounter in outColumn: # 要使用str转换，不然陷入copy与deepcopy的无限递归 column.append(str(item.contents[0]).strip()) columnCounter += 1 if flag: table = PrettyTable(column) flag = False else: table.add_row(column) score.extend([column]) searchCount += 1 scorenp = np.array(score) # table.set_style(pt.PLAIN_COLUMNS) print(table) print("分条统计：") scorenum = sendScore(table) print("成绩数目: " + str(scorenum) + "条")def sendScore(table): global scorenum global count global email_send_to global scorenp for i in table: print(i.get_string()) count += 1 if count &gt; scorenum: try: scorenum = count # 文本模式 # context = i.get_string().replace("+"," ") # context = context.replace("-"," ") # context = context.replace("2017 2018","2017-2018") # if(scorenum == 1): # msg=MIMEText("有成绩下来了：" + context,'plain','utf-8') # else: # msg=MIMEText("又有成绩下来了：" + context,'plain','utf-8') # msg = prettyScore() # html格式 msg = prettyScore() # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['From'] = formataddr(["1115810371@qq.com", my_sender]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['To'] = formataddr([email_send_to, email_send_to]) if count == required_course_num: msg['Subject'] = "第" + str(count) + "次成绩推送加平均绩点" else: msg['Subject'] = "第" + str(count) + "次成绩推送" # 邮件的主题，也可以说是标题 # 发件人邮箱中的SMTP服务器，端口是465 server = smtplib.SMTP_SSL("smtp.qq.com", 465) server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.sendmail(my_sender, [email_send_to, ], msg.as_string()) server.quit() # 关闭连接 print("发送成功，请注意在此邮箱查收：" + email_send_to) except Exception as e: print(e) print("发送失败！") count = 0 if scorenum != required_course_num: print("程序休息中...（按'Ctrl C'结束）") time.sleep(1200) # 二十分钟查一次 return scorenum# 接收构造成功的表格def prettyScore(): global scorenp try: # context = MIMEText(html,_subtype='html',_charset='utf-8') #解决乱码 msg = MIMEText(str(htmlText(scorenum)), "html", "gb2312") except Exception as e: print(e) return msg# 构造邮件内容：成绩表格def htmlText(scorenum): global required_course_num html = """ &lt;table color="CCCC33" width="800" border="1" cellspacing="0" cellpadding="5" text-align="center"&gt; &lt;tr&gt; &lt;td&gt;课程名称&lt;/td&gt; &lt;td&gt;课程性质&lt;/td&gt; &lt;td&gt;学分&lt;/td&gt; &lt;td&gt;平时成绩&lt;/td&gt; &lt;td&gt;期末成绩&lt;/td&gt; &lt;td&gt;成绩&lt;/td&gt; &lt;/tr&gt; """ + addtrs(scorenum) + """ &lt;/table&gt; """ # 最后一次推送时计算GPA并与成绩表格一起推送 if scorenum == required_course_num: html += """ &lt;br/&gt; &lt;div class='gpa_text' style='font-size: 25px;font-style: italic;'&gt;--&gt;平均绩点：%s &lt;--&lt;/div&gt; """ % (getGPA()) + """ &lt;br/&gt; &lt;div class='end_words' style='font-size: 20px;'&gt;本学期考试成绩查询完成！&lt;/div&gt; """ return html# 在发送的表格里添加成绩行def addtrs(scorenum): global scorenp i = 1 array = [] while i &lt;= scorenum: trs = ''' &lt;tr&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; ''' % (scorenp[i][0], scorenp[i][1], scorenp[i][2], scorenp[i][3], scorenp[i][4]) if (scorenp[i][5].isalpha() and scorenp[i][5] == "A") or (scorenp[i][5].isdigit() and int(scorenp[i][5]) &gt;= 90): # 等级A和90以上的成绩标记为绿色 trs += '&lt;td style="color:springgreen;"&gt;' elif (scorenp[i][5].isalpha() and scorenp[i][5] == "F") or ( scorenp[i][5].isdigit() and int(scorenp[i][5]) &lt; 60): # 不及格的成绩标记为红色 trs += '&lt;td style="color:red;"&gt;' else: # 普通成绩不标记 trs += '&lt;td&gt;' trs += ''' %s &lt;/td&gt; &lt;/tr&gt; ''' % (scorenp[i][5]) array.append(trs) i += 1 s = "" for x in array: s += str(x) return s# 计算GPAdef getGPA(): global scorenp global scorenum global makeup_course_num global makeup_course_flag sc = [] GPAlist = [] i = 1 j = 0 coursenum = 0 while i &lt;= scorenum: if scorenp[i][1] != "必修课程" or scorenp[i][6] == "是": # 排除非必修课以及重修课 makeup_course_num += 1 i += 1 continue else: # 有些成绩是等级，需要转换为数字 if scorenp[i][5].isalpha() and scorenp[i][5] != "F": sc.append(745 - 10 * ord(scorenp[i][5])) # 计算式子：x - (x - A) + 10 * (D - x) 即 745 - 10 * x elif scorenp[i][5] == "F": sc.append(0) else: sc.append(int(scorenp[i][5])) if int(sc[j]) &lt; 60: # 不及格的科目绩点为0 GPAlist.append(0) else: # 计算单科绩点 GPAlist.append((int(sc[j]) - 50) / 10 * float(scorenp[i][2])) i += 1 j += 1 coursenum += 1 i = 1 j = 0 sum = 0 scoresum = 0 while i &lt;= scorenum: if scorenp[i][1] != "必修课程" or scorenp[i][6] == "是": i += 1 continue sum += GPAlist[j] scoresum += float(scorenp[i][2]) j += 1 i += 1 GPA = sum / scoresum print("平均绩点：" + str(GPA)) return GPA# 根据当前日期设置查询学期def setSemester(): global ddlxn global ddlxq try: localtime = time.localtime(time.time()) # 获取当前日期 # 第一学期是从当年9月到次年2月，第二学期则是从当年3月到8月 if (int((localtime.tm_mon) &gt;= 9 and int(localtime.tm_mon) &lt;= 12) or ( int(localtime.tm_mon) &gt;= 1 and int(localtime.tm_mon) &lt;= 2)): # if (str(localtime.tm_year) == "2020" and int((localtime.tm_mon) &gt;= 7)): # print("您已毕业，无须监控成绩！") # sys.exit(0) if (int(localtime.tm_mon) &gt;= 1 and int(localtime.tm_mon) &lt;= 2): ddlxn = str(localtime.tm_year - 1) + '-' + str(int(localtime.tm_year)) else: ddlxn = str(localtime.tm_year) + '-' + str(int(localtime.tm_year) + 1) ddlxq = '1' else: ddlxn = str(int(localtime.tm_year) - 1) + '-' + str(localtime.tm_year) ddlxq = '2' except Exception as e: print(e)if __name__ == '__main__': setSemester() try: searchCount = 1 print('欢迎使用大连大学成绩查询助手！') print('正在检查网络...') if isConnected(): with open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'rb') as file: udick = pickle.load(file) sname = udick['sname'] sid = udick['sid'] spwd = udick['spwd'] email_send_to = udick['email_send_to'] # 构造登录地址 final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] loginCount = 0 while not login(): if loginCount &gt; 3: # 超过三次未登录自动更换网址 url_head = "202.199.155." + str(random.randint(33, 37)) final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] loginCount = 0 loginCount += 1 print("正在等待重试...") time.sleep(3) continue get_RequiredCourse_num() getScore() counter = 0 while scorenum &lt;= required_course_num: counter += 1 if scorenum == required_course_num: print("本学期成绩查询完成！") break if counter &gt; 0: getScore() except FileNotFoundError: # if os.path.exists(r'' + DstDir + '\\ScoreHelper'): # os.remove(r'' + DstDir + '\\ScoreHelper') os.mkdir(r'' + DstDir + '\\ScoreHelper') # 注：针对Windows目录结构 print('这是你第一次使用，请按提示输入信息，以后可不必再次输入~') sid = input('请输入学号：') sname = input('请输入姓名：') # 隐藏密码 # spwd = getpass.getpass('请输入密码：') spwd = input('请输入密码：') email_send_to = input('请输入要将成绩发送到的邮箱地址：') udick = &#123;'sname': sname, 'sid': sid, 'spwd': spwd, 'email_send_to': email_send_to&#125; file = open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'wb') pickle.dump(udick, file) file.close() final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] # 登录失败，重试 while not login(): sname = input('请输入姓名：') sid = input('请输入学号：') # spwd = getpass.getpass('请输入密码：') spwd = input('请输入密码：') email_send_to = input('请输入要将成绩发送到的邮箱地址：') udick = &#123;'sname': sname, 'sid': sid, 'spwd': spwd, 'email_send_to': email_send_to&#125; file = open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'wb') pickle.dump(udick, file) file.close() final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] get_RequiredCourse_num() getScore() counter = 0 while scorenum &lt;= required_course_num: counter += 1 if scorenum == required_course_num: print("本学期成绩查询完成！") break if counter &gt; 0: getScore() print(scorenum) except subprocess.CalledProcessError: print("网络连接不正常！请检查网络！") except Exception as e: print(e) print("失败！可能是你没有完成教学评价！没有完成教学评价则无法查看成绩！或用户中途取消或网络故障。") finally: # if os.path.exists(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg'): # os.remove(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg') print("程序将在3秒后退出...") time.sleep(3) 运行结果 NOTE 当百度云识别不成功时，为了防止网页错误，我设置了3秒间隔重试登录 当多次识别不成功时，程序可能结束 关于自动判断学期的功能，我是根据我个人的毕业时间来算的结束监控的年月日期，请按需修改 当教务网关闭以及断网的时候本程序就不灵了。。。 由于session有时间限制，所以每隔一段时间（约27小时）就要重新登录 本程序需要改进的一些功能 程序被停止后需要立即重新运行（在完善中） 修复日志 2019-1-2 修复日期计算错误的问题 更新新增python控制自动运行.bat文件功能，使程序得以无休止运行 battle.bat 12345@echo off cd ./start python 成绩监控并推送.py startpy.py 123456789101112131415161718192021222324252627282930313233343536# startpy.py# coding:utf8import datetimeimport osimport timedef doSth(): # 把爬虫程序放在这个类里 print('这个程序要开始疯狂的运转啦') try: if os.path.exists(path): command = path + '/battle.bat' os.system(command) except (IOError, Exception) as e: print(e)if __name__ == '__main__': path = os.getcwd() count = 0 timeCount = 0 doSth() while timeCount &lt; 27: timeCount += 1 count += 1 print("程序第",end="") print(count,end="") print("次执行") if timeCount == 27: timeCount = 0 # doSth() # 每隔1小时检测一次 time.sleep(3600) startpy.py运行截图： 更新更新(2019-2-12)将验证码图片颜色翻转，提高识别准确率123456789101112131415# 图像转换并识别def image_util(img): new_im = img.convert(&quot;RGB&quot;) # 将验证码图片转换成24位图片 new_im.save(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode1.jpg&apos;) # 将24位图片保存到本地 arr = np.array(Image.open(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode1.jpg&apos;).convert(&quot;L&quot;)) b = 255 - arr im = Image.fromarray(b.astype(&apos;uint8&apos;)) # 翻转 # d = 255 * (arr / 255) ** 2 # im = Image.fromarray(d.astype(&apos;uint8&apos;)) # 灰度 # 此处验证过，翻转比灰度识别率更高 im.save(&apos;&apos; + DstDir + &apos;\\ScoreHelper\\CheckCode2.jpg&apos;) 更新(2019-2-15)更改重试次数限制，当出现三次登录不成功时，更换网址重新登录12345678910111213141516171819if __name__ == &apos;__main__&apos;: ... loginCount = 0 while not login(): if loginCount &gt; 3: # 超过三次未登录自动更换网址 url_head = &quot;202.199.155.&quot; + str(random.randint(33, 37)) final_url = &apos;http://&apos; + url_head + \ check_for_redirects(&apos;http://&apos; + url_head + &apos;/default2.aspx&apos;) final_url_head = final_url[0:48] loginCount = 0 loginCount += 1 print(&quot;正在等待重试...&quot;) time.sleep(3) continue get_RequiredCourse_num() getScore() ...]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 监控爬取成绩并推送到邮箱]]></title>
    <url>%2F2018%2F07%2F25%2FPython-3-6-%E7%9B%91%E6%8E%A7%E7%88%AC%E5%8F%96%E6%88%90%E7%BB%A9%E5%B9%B6%E6%8E%A8%E9%80%81%E5%88%B0%E9%82%AE%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[简介本程序模拟登录正方教务系统获取本人当前学期成绩（也可以手动改学期学年），20分钟检测一次，当有新成绩公布时就发送到邮箱，本程序用到的是我学校的教务网网址。 由于正方网页的每一项都需要cookie来进行访问，在用Chrome单独打开子页面时，网页会直接跳到登录前界面。在用调试查看了post后，发现cookie消失了；但是直接从网页上打开子网页可以访问。所以在登录时就要保存登录信息cookie。 爬取部分是根据网上代码内容修改的，后面的监控和发送是自己完成的。 本程序测试了多次修改了许许多多的bug，终于得以发布。 该程序的发送邮箱部分需要用到Python SMTP功能，具体可参照xsan的python3通过qq邮箱发送邮件 教务系统网址防止访问重复冲突，在后面加了一串hash码，所有的网址一定要带上它，这样才能访问到登录后的界面，否则没有cookie。 开头要求用户输入本学期所有考试数目，包括重修、公选、跨选等课程，目的是在最后一次推送前将平均绩点算出并发送到邮箱。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574'''大连大学成绩查询助手V3.5Coded By Martin HuangCode Changed By ZC Liang2018.6.6'''import reimport urllib.requestimport urllib.parseimport http.cookiejarimport bs4import getpassimport pickleimport osimport platformimport subprocessfrom bs4 import BeautifulSoupfrom prettytable import PrettyTablefrom PIL import Imageimport smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrimport timeimport prettytable as ptimport pandas as pdimport numpy as npmy_sender = '发件人邮箱账号' # 发件人邮箱账号my_pass = '发件人邮箱密码' # 发件人邮箱密码(当时申请smtp给的口令)# my_user = '收件人邮箱账号' # 收件人邮箱账号，我这边发送给自己email_send_to = '' # 收件人邮箱账号DstDir = os.getcwd()searchCount = 0 # 查询次数count = 0 # 循环计数scorenum = 0 # 成绩条数score = []scorenp = np.array(score)makeup_course_num = 0 # 重修课程数目makeup_course_flag = -1 # 重修课程数目下标courseList = []required_course_num = 0# 准备Cookie和opener，因为cookie存于opener中，所以以下所有网页操作全部要基于同一个openercookie = http.cookiejar.CookieJar()opener = urllib.request.build_opener( urllib.request.HTTPCookieProcessor(cookie))final_url = "" # 头 + 随机编码 + default2.aspxfinal_url_head = ""url_head = "202.199.155." + str(random.randint(33, 37)) # 随机产生网址ddlxn = ""ddlxq = ""# 判断操作系统类型def getOpeningSystem(): return platform.system()# 判断是否联网def isConnected(): userOs = getOpeningSystem() if userOs == "Windows": subprocess.check_call( ["ping", "-n", "2", url_head], stdout=subprocess.PIPE) else: subprocess.check_call( ["ping", "-c", "2", url_head], stdout=subprocess.PIPE)# 获取重定向编码def check_for_redirects(url): r = requests.head(url) if r.ok: return r.headers['location'] else: return '[no redirect]'# 登陆def login(): # 构造表单 params = &#123; 'txtUserName': sid, 'Textbox1': '', 'Textbox2': spwd, 'RadioButtonList1': '学生', 'Button1': '', 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '', &#125; # 获取验证码 res = opener.open(final_url_head + '/checkcode.aspx').read() with open('' + DstDir + '\\ScoreHelper\\CheckCode.jpg', 'wb') as file: file.write(res) img = Image.open('' + DstDir + '\\ScoreHelper\\CheckCode.jpg') img.show() vcode = input('请输入验证码：') img.close() params['txtSecretCode'] = vcode # 获取ViewState response = urllib.request.urlopen('http://' + url_head + '/') html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 尝试登陆 loginurl = final_url print("\n本次登录所用网址为：" + loginurl + "\n") data = urllib.parse.urlencode(params).encode('gb2312') response = opener.open(loginurl, data) if response.geturl() == final_url: print('登陆失败，可能是姓名、学号、密码、验证码填写错误！') return False else: return True# 获取本学期必修课数目def get_RequiredCourse_num(): global required_course_num print("正在查询本学期必修课数目...") # 构造url url = ''.join([ final_url_head + '/xsxkqk.aspx', '?xh=', sid, '&amp;xm=', urllib.parse.quote(sname), '&amp;gnmkdm=N121615', ]) # 构建查询学生选课情况表单 params = &#123; 'ddlxn': ddlxn, 'ddlxq': ddlxq, &#125; # 构造Request对象，填入Header，防止302跳转，获取新的View_State req = urllib.request.Request(url) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') req.add_header( 'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = opener.open(req) html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 查询所有成绩 req = urllib.request.Request( url, urllib.parse.urlencode(params).encode('gb2312')) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') response = opener.open(req) soup = BeautifulSoup(response.read().decode('gb2312'), 'html.parser') html = soup.find('table', class_='datelist') # 指定要输出的列，原网页的表格列下标从0开始 # 用于标记是否是遍历第一行 flag = True # 根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象 # 遍历行 counter = 0 for each in html: columnCounter = 0 column = [] if(type(each) == bs4.element.NavigableString): pass else: # 遍历列 for item in each.contents: if(item != '\n'): if(counter&gt;0 and columnCounter == 3): courseList.append(str(item.contents[0]).strip()) columnCounter += 1 if flag: flag = False counter += 1 for each in courseList: if(each == "必修课程"): required_course_num += 1# 获取成绩def getScore(): global searchCount global scorenum global scorenp global ddlxn global ddlxq score = [] # 构造url url = ''.join([ final_url_head + '/xscjcx_dq.aspx', '?xh=', sid, '&amp;xm=', urllib.parse.quote(sname), '&amp;gnmkdm=N121605', ]) # 构建查询全部成绩表单 params = &#123; 'ddlxn': ddlxn, # 全部为 %C8%AB%B2%BF 'ddlxq': ddlxq, 'btnCx': '+%B2%E9++%D1%AF+', &#125; # 构造Request对象，填入Header，防止302跳转，获取新的View_State req = urllib.request.Request(url) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') req.add_header( 'User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = opener.open(req) html = response.read().decode('gb2312') viewstate = re.search( '&lt;input type="hidden" name="__VIEWSTATE" value="(.+?)"', html) params['__VIEWSTATE'] = viewstate.group(1) # 查询所有成绩 req = urllib.request.Request( url, urllib.parse.urlencode(params).encode('gb2312')) req.add_header('Referer', final_url) req.add_header('Origin', 'http://' + url_head + '/') response = opener.open(req) soup = BeautifulSoup(response.read().decode('gb2312'), 'html.parser') html = soup.find('table', class_='datelist') print("执行第" + str(searchCount) + "次查询：") print('你的所有成绩如下：') # 指定要输出的列，原网页的表格列下标从0开始 outColumn = [3, 4, 6, 7, 9, 11, 13] # 用于标记是否是遍历第一行 flag = True # 根据DOM解析所要数据，首位的each是NavigatableString对象，其余为Tag对象 # 遍历行 for each in html: columnCounter = 0 column = [] if(type(each) == bs4.element.NavigableString): pass else: # 遍历列 for item in each.contents: if(item != '\n'): if columnCounter in outColumn: # 要使用str转换，不然陷入copy与deepcopy的无限递归 column.append(str(item.contents[0]).strip()) columnCounter += 1 if flag: table = PrettyTable(column) flag = False else: table.add_row(column) score.extend([column]) searchCount += 1 scorenp = np.array(score) # table.set_style(pt.PLAIN_COLUMNS) print(table) print("分条统计：") scorenum = sendScore(table) print("成绩数目: " + str(scorenum) + "条")def sendScore(table): global scorenum global count global email_send_to global scorenp for i in table: print(i.get_string()) count += 1 if(count &gt; scorenum): try: scorenum = count # 文本模式 # context = i.get_string().replace("+"," ") # context = context.replace("-"," ") # context = context.replace("2017 2018","2017-2018") # if(scorenum == 1): # msg=MIMEText("有成绩下来了：" + context,'plain','utf-8') # else: # msg=MIMEText("又有成绩下来了：" + context,'plain','utf-8') # msg = prettyScore() # html格式 msg = prettyScore() # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg['From'] = formataddr(["1115810371@qq.com", my_sender]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg['To'] = formataddr([email_send_to, email_send_to]) if(count == required_course_num): msg['Subject'] = "第" + \ str(count) + "次成绩推送加平均绩点" # 邮件的主题，也可以说是标题 else: msg['Subject'] = "第" + str(count) + "次成绩推送" # 邮件的主题，也可以说是标题 # 发件人邮箱中的SMTP服务器，端口是465 server = smtplib.SMTP_SSL("smtp.qq.com", 465) server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.sendmail(my_sender, [email_send_to, ], msg.as_string()) server.quit() # 关闭连接 print("发送成功，请注意在此邮箱查收：" + email_send_to) except Exception as e: print(e) print("发送失败") count = 0 if(scorenum != required_course_num): print("程序休息中...（按'Ctrl C'结束）") time.sleep(1200) # 二十分钟查一次 return scorenumdef prettyScore(): global scorenp try: # context = MIMEText(html,_subtype='html',_charset='utf-8') #解决乱码 msg = MIMEText(str(htmlText(scorenum)), "html", "gb2312") except Exception as e: print(e) return msgdef htmlText(scorenum): global required_course_num if(scorenum == required_course_num): html = """ &lt;table color="CCCC33" width="800" border="1" cellspacing="0" cellpadding="5" text-align="center"&gt; &lt;tr&gt; &lt;td text-align="center"&gt;课程名称&lt;/td&gt; &lt;td text-align="center"&gt;课程性质&lt;/td&gt; &lt;td text-align="center"&gt;学分&lt;/td&gt; &lt;td text-align="center"&gt;平时成绩&lt;/td&gt; &lt;td text-align="center"&gt;期末成绩&lt;/td&gt; &lt;td text-align="center"&gt;成绩&lt;/td&gt; &lt;/tr&gt; """ + addtrs(scorenum) + """ &lt;/table&gt; &lt;div&gt;&lt;h2&gt;--&gt;平均绩点：%s --&lt;&lt;/h2&gt;&lt;/div&gt; """ % (getGPA()) else: html = """ &lt;table color="CCCC33" width="800" border="1" cellspacing="0" cellpadding="5" text-align="center"&gt; &lt;tr&gt; &lt;td text-align="center"&gt;课程名称&lt;/td&gt; &lt;td text-align="center"&gt;课程性质&lt;/td&gt; &lt;td text-align="center"&gt;学分&lt;/td&gt; &lt;td text-align="center"&gt;平时成绩&lt;/td&gt; &lt;td text-align="center"&gt;期末成绩&lt;/td&gt; &lt;td text-align="center"&gt;成绩&lt;/td&gt; &lt;/tr&gt; """ + addtrs(scorenum) return htmldef addtrs(scorenum): global scorenp i = 1 array = [] while(i &lt;= scorenum): trs = ''' &lt;tr&gt; &lt;td text-align="center"&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;td&gt;%s &lt;/td&gt; &lt;/tr&gt; ''' % (scorenp[i][0], scorenp[i][1], scorenp[i][2], scorenp[i][3], scorenp[i][4], scorenp[i][5]) array.append(trs) i += 1 s = "" for x in array: s += str(x) return sdef getGPA(): global scorenp global scorenum global makeup_course_num global makeup_course_flag sc = [] GPAlist = [] i = 1 j = 0 coursenum = 0 while(i &lt;= scorenum): if(scorenp[i][1] != "必修课程" or scorenp[i][6] == "是"): makeup_course_num += 1 i += 1 continue else: if(scorenp[i][5] == "F"): sc.append(0) elif(scorenp[i][5] == "A"): sc.append(95) elif(scorenp[i][5] == "B"): sc.append(85) elif(scorenp[i][5] == "C"): sc.append(75) elif(scorenp[i][5] == "D"): sc.append(65) else: sc.append(int(scorenp[i][5])) if(int(sc[j]) &lt; 60): GPAlist.append(0) else: GPAlist.append((int(sc[j]) - 50)/10*float(scorenp[i][2])) i += 1 j += 1 coursenum += 1 i = 1 j = 0 sum = 0 scoresum = 0 while(i &lt;= scorenum): if(scorenp[i][1] != "必修课程" or scorenp[i][6] == "是"): i += 1 continue sum += GPAlist[j] scoresum += float(scorenp[i][2]) j += 1 i += 1 GPA = sum/scoresum print("平均绩点：" + str(GPA)) return GPAif __name__ == '__main__': try: localtime = time.localtime(time.time()) # 获取当前日期 if(int((localtime.tm_mon) &gt;= 9 and int(localtime.tm_mon) &lt;= 12) or (int(localtime.tm_mon) &gt;= 1 and int(localtime.tm_mon) &lt;= 2)): if(str(localtime.tm_year) == "2020"): print("您已毕业，无须监控成绩！") sys.exit(0) ddlxn = str(localtime.tm_year) + '-' + str(int(localtime.tm_year) + 1) ddlxq = '1' else: ddlxn = str(int(localtime.tm_year) - 1) + '-' + str(localtime.tm_year) ddlxq = '2' searchCount = 1 print('欢迎使用大连大学成绩查询助手！') print('正在检查网络...') isConnected() with open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'rb') as file: udick = pickle.load(file) sname = udick['sname'] sid = udick['sid'] spwd = udick['spwd'] email_send_to = udick['email_send_to'] final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] while(not login()): continue get_RequiredCourse_num() getScore() counter = 0 while(scorenum &lt;= required_course_num): counter += 1 if(scorenum == required_course_num): print("本学期成绩查询完成！") break if(counter &gt; 0): getScore() except FileNotFoundError: # if os.path.exists(r'' + DstDir + '\\ScoreHelper'): # os.remove(r'' + DstDir + '\\ScoreHelper') os.mkdir(r'' + DstDir + '\\ScoreHelper') # 注：针对Windows目录结构 print('这是你第一次使用，请按提示输入信息，以后可不必再次输入~') sid = input('请输入学号：') sname = input('请输入姓名：') # 隐藏密码 # spwd = getpass.getpass('请输入密码：') spwd = input('请输入密码：') email_send_to = input('请输入要将成绩发送到的邮箱地址：') udick = &#123;'sname': sname, 'sid': sid, 'spwd': spwd, 'email_send_to': email_send_to&#125; file = open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'wb') pickle.dump(udick, file) file.close() final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] while(not login()): sname = input('请输入姓名：') sid = input('请输入学号：') # spwd = getpass.getpass('请输入密码：') spwd = input('请输入密码：') email_send_to = input('请输入要将成绩发送到的邮箱地址：') udick = &#123;'sname': sname, 'sid': sid, 'spwd': spwd, 'email_send_to': email_send_to&#125; file = open(r'' + DstDir + '\\ScoreHelper\\uinfo.bin', 'wb') pickle.dump(udick, file) file.close() final_url = 'http://' + url_head + \ check_for_redirects('http://' + url_head + '/default2.aspx') final_url_head = final_url[0:48] get_RequiredCourse_num() getScore() counter = 0 while (scorenum &lt;= required_course_num): counter += 1 if (scorenum == required_course_num): print("本学期成绩查询完成！") break if (counter &gt; 0): getScore() print(scorenum) except subprocess.CalledProcessError: print("网络连接不正常！请检查网络！") except: print("失败！可能是你没有完成教学评价！没有完成教学评价则无法查看成绩！或用户中途取消或网络故障。") finally: # if os.path.exists(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg'): # os.remove(r'' + DstDir + '\\ScoreHelper\\CheckCode.jpg') print("程序将在3秒后退出...") time.sleep(3) 当教务网关闭以及断网的时候本程序就不灵了。。。 由于session有时间限制，所以每隔一段时间（约27小时）就要重新登录 最后一次发送成功 截图： 2018-09-25新增——自动获取本学期必修课总数]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理笔记]]></title>
    <url>%2F2018%2F05%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、计算机系统概述计算机由五部分组成：控制器，存储器，运算器，输入设备，输出设备 系统结构：计算机系统对各级之间界面的定义，及其上下功能分配。各级都有自己的系统结构，各级之间存在透明性（确实存在，但无法监测设置） 计算机组成是指计算机系统结构的逻辑实现，包括 机器级内的数据通道和控制信号的组成及逻辑设计，他着眼于机器级内各事件的时序方式与控制机构，各部件功能及相互联系 计算机实现是指计算机组成的物理实现 吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量。 CPI(Cycles Per Instruction)：表示每条指令周期数，即执行一条质量所需的平均时钟周期数。计算如下：CPI=执行某段程序所需的CPU时钟周期数/程序包含的指令条数 MIPS(Million Instructions Per Second)：每秒执行多少百万条定点指令数，计算如下：MIPS=指令数/(程序执行的时间*10^6) FLOPS(Floating-point Operations Per Second)：每秒执行浮点操作的次数，用来衡量机器浮点操作的性能，计算如下：FLOPS=程序中的浮点操作次数/程序执行时间(S) 二、数据的机器表示计算机数制：十进制D，二进制B，十六进制H······二进制——&gt;十进制：按权相加十进制——&gt;二进制：除2取余十进制——&gt;十六进制：除16取余十六进制——&gt;十进制：按权相加二进制——&gt;十六进制：四位合一（小数点左或右，每四位合一位）十六进制——&gt;二进制：将十六进制的每位用四位二进制表示 字母ASCII码：A所对应的码是在其十六进制的基础上加37H，小写字母的码比其大写字母对应的码大20H数字ASCII码：在其数字基础上加30H 校验编码和解码为了判断，纠正信息在存入物理设备或传输中被干扰而导致某些信息错误，需要在信息发送（存储）后之前进行编码，在信息接收（读出）后进行解码。校验码编码采用冗余校验（在近笨的有效信息位尚在扩充若干校验位称为冗余位，冗余位越多纠错差错能力越强）的编码思想。奇偶校验：是一种只有一位冗余位的编码方法，常用于主存校验，信息传送。分为奇校验，偶校验两种。奇校验：编码后的有效信息位和奇偶校验位的个数为奇数偶校验：编码后有效信息位和奇偶校验位1的个数为偶数 奇偶校验电路采用异或的方式。如果采用偶校验，将所有信息位异或后得到的就是偶校验位。如果采用奇校验，将所有信息位异或后再取反得到的便是奇校验接收端将接受的全部信息（包括校验位）进行异或运算，如果是偶校验，结果如果为0则正确。如果是奇校验结果为1则正确 海明码编码是一种既能发现错误又能纠正错误的校验码。其中包含n位有效信息位，k位校验位。k位校验位一共有2^k种组合，除去采用一种组合指示是否在传输中出现错误。要满足如下公式：2^k&gt;=n+k+1海明码规定，位号（从左往右数，1为起始）等于2的权值的那些位均可用作奇偶校验位，余下则是信息位。校验位与信息位的关系：信息位的位号等于哪几个校验位相加，就是被哪几个校验位检验。例如：3（2^0+2^1)位号为3的信息位将被位号为0和1的校验位海明码的编码原理校验位的值是其所校验的信息位之异或海明码错误位查询海明码出错指示码称为指误字，他所检验的不仅包含信息位还有，校验位。E0检验p0，E1检验P1，E2检验P2，E3检验P3，E4检验P4。指误字的值是所检验的位异或后的值错误位就是E3E2E1E0海明码的纠错只需将错误位取反 循环冗余校验设带编码的信息以多项式M（x)表示将M(x)左移得到M(x)x^r，使低r位全为0，以便与校验位拼接。校验位用M(x)x^r除以生成多项式G(x)（G(x)必须是r+1位的）所得余数则为校验位。所得的余数与M(x)*x^r相加便为CRC码 CRC码的译码及纠错用CRC码除以G(x)若余数为0，则该码正确。否则，余数即为错误位 三、运算方法运算器符号：正0负1原码表示：======整数：用逗号将符号与数隔开======小数：用.将符号和小数隔开 补码表示：======整数：用逗号将符号位与数值部分隔开，负数或浮点机中正数阶码按位取反加1======小数：用.将符号位与数值隔开，负数数值部分按位取反加1 反码表示：======整数：用逗号将符号位与数值部分隔开，负数或浮点机中正数阶码按位取反======小数：用.将符号位与数值隔开，负数数值部分按位取反 定点表示：小数点固定的数，用来表示纯整数，纯小数。采用定点数的机器称为定点机浮点表示：1.523432^3将正数尾数最高位为1的浮点数称为规格化数，即0.111101012^10浮点机中表示：阶符，阶码；数值 定点数乘除 定点数的乘法机算（原码一位乘）：最先部分积为0，判断乘数最低位（为1则部分积加上被乘数，为0部分积加上0）得到新的部分积，部分积右移一位，乘数得到此数放在最高位同时踢出最低位。当原始乘数全被踢出时运算结束，结果为部分积与新乘数拼接。（补码一位乘）判断乘数是否大于0（大于0则在结果不需加负的被乘数的补码，小于0需要加）（补码符号位为两位）定点数的除法：（恢复余数法）（结果符号位是被除数与除数的符号位的异或）（两个补码的运算，余数为负时需加上除数补码）一开始被除数补码减除数补码，（若余数为负则上商0，加除数补码，余数左移一位后再减除数补码。若余数为正，左移一位，上商1，再减除数补码）直到结果位数与初始除数位数相同（加减交替法）一开始被除数补码减除数补码，（若余数为负则上商0，加除数补码。。。。。。 （补码除法，末位横置1法） 判断被除数补码与除数补码是否同号（同号则减除数补码，异号加除数补码），所得余数判断是否与除数同号（同号则上商1左移1位减除数补码，异号上商0左移一位加除数补码，直到所得商位数为初始商位数减1，所得结果左移一位加1。（！！！！同号减y补上商1，异号加y补上商0） 浮点数加减 加法先对阶，按照小阶看齐大阶原则，使阶小的尾数右移。然后尾数相加，得数若是数值位第一位和符号位相同需左规（左移一位，阶码减1 ）若得数符号位两位不同需右规，再做舍入处理减法先对阶，按照小阶看齐大阶原则，使阶小的尾数右移。然后尾数相减，得数若是数值位第一位和符号位相同需左规（左移一位，阶码减1 ）若得数符号位两位不同需右规，再做舍入处理。阶符为01时为上溢，需做溢出处理，阶符为10时为下溢，按机器零处理。 四、指令系统指令是指计算机执行某些操作的命令，一台计算机的所有指令的集合构成该机的指令系统，也称指令集。寻址技术指的是寻找操作数的地址或下一条将要执行的指令地址，寻址技术是计算机设计中硬件对软件最早提供支持的技术之一。寻找下一条将要执行的指令地址称为指令寻址，寻找操作数的地址称为数据寻址。 s设计指令系统格式直接寻址：OP + A变址寻址：OP + Rx+A寄存器寻址：OP+Rx OP为操作码，A为形式地址，M为寻址特征 五、中央处理器指令流，数据流在程序运行过程中，在计算机的各部件之间流动的指令和数据形成了指令流，数据流。指令流，数据流，不是程序中静态的指令序列和存储器中静态分配序列。指令流指的是cpu执行的指令序列，数据流指的是根据指令操作要求依次存取数据的序列。 cpu的基本功能就是对指令流和数据流在时间与空间上实施正确的控制。 程序计数器（PC）是专用寄存器，又称指令计数器，用来存放正在执行的指令地址，或接着要执行的下一条指令地址。cpu中的主要技术参数cpu的字长：指的是在单位时间内同时处理的二进制数据的位数。cpu按照其处理信息的字长可分为，8位cpu，16位，32位，64位。内部工作频率：又称为内频或主频，它是衡量cpu速度的重要参数。主频表示在cpu内数字脉冲信号震荡的速度。 控制器硬件实现办法控制器分为三种，组合逻辑性，存储逻辑性，组合逻辑和存储逻辑结合型。 指令运行一条指令运行过程可以分为三种阶段：取指令阶段，分析取数阶段，执行阶段。 微程序控制原理微命令：控制部件向执行部件发出的控制命令微操作：是计算机中最基本的不可再分的操作 微命令 和微操作是一一对应的微命令是微操作的控制信号，微操作是微命令的操作过程。 微指令：是控制存储器的一个单元的内容，是若干微命令的集合微地址：存放控制存储单元的单元地址就成为微地址。微周期：从控制存储器中读取一条微指令并执行相应的微命令所需的全部时间微程序：一系列微指令的有序集合就是微程序。每一条机器指令都对应一个微程序。 微指令编码法直接控制法，最短编码法，字段编码法 六、指令流水线七、存储器系统及其层次结构存储器的性能指标存储容量：存储器所能容纳二进制信息的总量。容量单位：位（b) 字节(B)…… 1B=8b 存储器速度：衡量存储器的速度通常有三个相关参数（存取时间，存取周期，存储器带宽） 存储器的分类按存储介质分（磁表面存储器，半导体存储器，光盘存储器）按所处位置分（内存，外村，缓冲存储器（cache））按存取方式分（随机存储器，只读存储器，串行访问存储器） 存储器的层次结构缓存-主存主要解决cpu和主存速度不匹配问题 ，主存和缓存之间的数据调动是由硬件自动完成的主存-辅存层次主要解决存储系统的容量问题，主存和辅存志坚的数据调动是由硬件和操作系统共同完成的 半导体存储器随机存储器RAM：可以通过指令随机的对任意存储单元进行读写访问，RAM通常是住存储器的主要组成部分。分为动态(DRAM，每隔2ms刷新一次)和静态(SRAM)两种只读存储器（ROM)：仅能执行读操作的存储器半导体串行存储器：其数据按位串行读出或写入 存储器芯片存储容量：用常用存储单元个数乘以存储单元的位数计算在存储器中存储1位二进制信息的存储元件称为基本存储单元，若干个基本存储单元组成一个存储字，存储字的位数称为存储器位宽，被一定的规则组合在一起构成一个存储体存储器芯片由存储阵列，译码器，读写控制电路，数据缓冲电路构成。地址译码器：将输入的地址信号（来自cpu发出的地址信号）翻译成某单元（存储字或字节）的选通信号，使该单元能被读写 存储阵列，译码器，读写控制电路分别通过片选信号CE，读写控制信号WE，输出允许信号OE引脚实现。 动态RAM的刷新：刷新即将原信息读出，再生成原信息重新写入。刷新的原因（因为存储单元是随机访问，未得到访问的单元内的原信息可能会消失，因此要定时刷新）通常有三种刷新（集中刷新，分散刷新，异步刷新） 存储器与cpu存储容量的扩展：位拓展，自拓展，字位拓展存储器与cpu的连接：地址线，数据线，读写命令线，片选线 八、互连及输入输出组织九、总线系统总线是连接多个部件的信息传输线，是各部件共享的传输介质。按照总线上传输信号的不同，总线可分为地址总线，控制总线，数据总线三类。地址总线传送的是从cpu等主设备发往从设备的地址信号控制总线传送的是一个部件对另一个部件的控制或状态信息。数据总线传送的是各部件之间交换的数据信息 根据连接方式不同，单处理机系统中采用的总线结构有两种基本类型，即单总线结构，多总线结构。单总线结构使用单一的系统总线连接cpu，主存，I/o设备，允许各设备间的信息直接交换。 简单，易扩充，工作效率低。 多总线结构cpu和缓存之间采用高速的cpu总线，主存在系统总线上，通过桥，cpu总线，系统总线，高速总线彼此相连。 总线的仲裁连接到总线上的功能模块分为主模块，从模块。主模块不固定，有启动一个总线周期的作用。从模块只能响应主模块的请求。每次只能有一个主模块。仲裁就是在多个模块同时竞争总线控制权的时候选择一个主模块。按照总线仲裁电路的位置不同，仲裁分为集中式仲裁和分布式仲裁。 集中式仲裁每个功能模块有两条线连到总线，一条是仲裁请求线br另一条是仲裁授权线bg具体实现方式有链式查询方式，计数器定时查询，独立请求。 链式查询方式：通过判断离总线仲裁器的远近判断其优先级，优先级高的且有仲裁请求则被授权。 总线通信控制总线的通信控制主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调，如何配合，通常用同步通信，异步通信，半同步通信和分离式通信四种方式。 总线传输速率=总线宽度/总线传输周期 异步串行通信的数据传输速率用波特率表示。波特率是指单位时间内传送二进制数据的位数，单位用位/秒表示，记为波特。由于异步通信中包含若干附加位，如起始位，终止位，可用比特率来衡量异步串行通信的有效数据传输速率，即单位时间内传送二进制有效数据的位数单位用位/秒表示。]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
      <tags>
        <tag>计算机组成原理, 考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记 —— 爬取教务网明日课程并发送微信好友]]></title>
    <url>%2F2018%2F05%2F18%2FPython3-6%E8%8E%B7%E5%8F%96%E6%98%8E%E6%97%A5%E8%AF%BE%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%80%81%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[简介 实现将登录教务网爬取到的课程内容通过微信消息的方式发送给好友，提醒明日课程 主要用到itchat、requests、BeautifulSoup等库 登录的用户名和密码以及爬取下来的验证码需要自己输入 获取本地日期，判断星期几，加一天就是明日的星期数。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218#-*-coding:utf-8-*-import osimport refrom lxml import etreeimport requestsimport sysfrom bs4 import BeautifulSoupimport importlib,sysfrom PIL import Image,ImageEnhancefrom datetime import datetime,dateimport timeimport datetimeimport itchatdef getInfor(response, xpath): content = response.content.decode('gb2312') # 网页源码是gb2312要先解码 selector = etree.HTML(content) infor = selector.xpath(xpath)[0] return infordef get_week_day(date): week_day_dict = &#123; 0 : '星期一', 1 : '星期二', 2 : '星期三', 3 : '星期四', 4 : '星期五', 5 : '星期六', 6 : '星期日' &#125; day = date.weekday() if(day == 6): tomorrow = 0 else: tomorrow = day + 1 return week_day_dict[tomorrow]def get_tomorrow_column(date): column_dict = &#123; '星期一' : 3, '星期二' : 4, '星期三' : 5, '星期四' : 6, '星期五' : 7, '星期六' : 8, '星期日' : 9 &#125; return column_dict[date]def main(): # 设置编码 importlib.reload(sys) # 初始参数，自己输入的学号，密码。 studentnumber = input("学号：") password = input("密码：") # 访问教务系统,前面分析过了，提交数据时要用这个值。先得到__VIEWSTATE的值。 s = requests.session() url = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/default2.aspx" response = s.get(url) selector = etree.HTML(response.content) __VIEWSTATE = selector.xpath('//*[@id="form1"]/input/@value')[0] # 获取验证码并下载到本地 imgUrl = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/CheckCode.aspx?" imgresponse = s.get(imgUrl, stream=True) print (s.cookies) image = imgresponse.content DstDir = os.getcwd()+"\\" print("保存验证码到："+DstDir+"code.jpg"+"\n") try: with open(DstDir+"code.jpg", "wb") as jpg: jpg.write(image) except IOError: print("IO Error\n") finally: jpg.close # 手动输入验证码 image = Image.open('&#123;&#125;/code.jpg'.format(os.getcwd())) image.show() code = input("验证码是：") time.sleep(2) try: image.close() except: print() # 构建post数据 data = &#123; "__VIEWSTATE": __VIEWSTATE, "txtUserName": studentnumber, "TextBox2": password, "txtSecretCode": code, "Button1": "", &#125; # 提交表头，里面的参数是电脑各浏览器的信息。模拟成是浏览器去访问网页。 headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36", &#125; # 登陆教务系统 response = s.post(url, data=data, headers=headers) print ("成功进入") # 得到登录信息，个人感觉有点多余。 # 获取学生基本信息 text = getInfor(response, '//*[@id="xhxm"]/text()') text = text.replace(" ", "") print (text) # 抓一下名字 catch = '&lt;span id="xhxm"&gt;(.*?)&lt;/span&gt;&lt;/em&gt;' name = re.findall(catch, response.text) name = name[0] name = name[:-2] name = str(name).replace(r'\x', '%') # 扩大适用性 name = name.upper() name = name[2:] # 获取课表，kburl是课表页面url,为什么有个Referer参数,这个参数代表你是从哪里来的。就是登录后的主界面参数。这个一定要有。 kburl = "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/xskbcx.aspx?xh=" + studentnumber + "&amp;xm=" + name + "&amp;gnmkdm=N121603" headers = &#123; "Referer": "http://202.199.155.35/(0r3mgfvgmxuxkvjz4lf1v5a1)/xs_main.aspx?xh=" + studentnumber, "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36", &#125; response = s.get(kburl, headers=headers) # html代表访问课表页面返回的结果就是课表。下面做的就是解析这个html页面。 html = response.content.decode("gb2312") soup = BeautifulSoup(response.text,"html.parser") s=soup.find(id='Table1') trs=s.find_all('tr') itchat.auto_login(hotReload=True) while(True): friend = input('请输入好友昵称（输入0退出）：') if(friend == "0"): return users = itchat.search_friends(name= (u''+str(friend))) userName = users[0]['UserName'] # 打印全部课表 # for i in range(11): # td1=trs[i].find_all('td') # for j in td1: # print(j.text[0:6], end='\t') # print() #print(soup) # selector = etree.HTML(html) # content = selector.xpath('//[@id="Table1"]/tbody/tr/td/text()') # for each in content: # print (each) now = datetime.datetime.now() delta = datetime.timedelta(days=1) n_days = now + delta tomorrow = get_week_day(datetime.datetime.now()) date_info = "明天是 " + n_days.strftime('%Y-%m-%d') + " " + tomorrow print("明天是 " + n_days.strftime('%Y-%m-%d') + " " + tomorrow) itchat.send(str(date_info),toUserName = userName) if(n_days.strftime('%m') == "05" and n_days.strftime('%d') &gt;= "01" and n_days.strftime('%d') &lt; "07"): info = "明天没有课程哦，好好享受五一假期！" print("\t明天没有课程哦，好好享受五一假期！") itchat.send(str(info),toUserName = userName) return if(tomorrow == "星期六" or tomorrow == "星期日"): info = "明天没有课程哦！" print("\t明天没有课程哦！") itchat.send(str(info),toUserName = userName) return # 打印明天课表 for i in range(11): if(i==0): continue td1=trs[i].find_all('td') count = 1 # 列数 column = get_tomorrow_column(tomorrow) # 上午第一节课和下午第一节课的标签前面包含有“上午”和“下午”列 for j in td1: if(i == 2 or i == 6 or i == 10): if(count &gt;= 8): continue if(count == column): print(j.text, end='\t') info = j.text if not(info.strip()==''): itchat.send(str(info),toUserName = userName) else: if(count &gt;= 7): continue if(count == column-1): print(j.text, end='\t') info = j.text if not(info.strip()==''): itchat.send(str(info),toUserName = userName) count += 1 print() if(column&lt;8): info = "——这些是明天的课程，注意周次，请做好课前准备" itchat.send(str(info),toUserName = userName) else: info = "明天没有课程哦！" print("\t" + info) itchat.send(str(info),toUserName = userName) print("退出...") if os.path.exists(DstDir+"code.jpg"): #删除文件 os.remove(DstDir+"code.jpg")if __name__ == '__main__': main() 心得 在登录教务网时需要保存cookie信息，否则将无法访问后续网页 爬取网页发送请求的一种方法是用requests，还可以用urllib.request 和 urllib.parse 爬取课程表格时，有“早上”、“上午”、“下午”、“晚上”等列比较特殊，它们和各个时间段的第一行放在一起，所以要特殊处理该行 再接再厉！]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记 —— OpenCV+百度云接口实现人脸认证]]></title>
    <url>%2F2018%2F05%2F17%2FOpenCV-%E7%99%BE%E5%BA%A6%E4%BA%91%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[有话在先前日注册了百度云账号，接触到了百度云的一系列接口，看到“人脸对比”后突发奇想，用人脸识别来做认证（虽然没有Alipay那么高端）模拟登录执行程序。于是就去百度了百度云接口python实现人脸识别、OpenCV人脸认证。网上实现百度云接口的代码是用Python3写的，但是OpenCV目前只支持Python2；所以我尝试了一下把py3的百度云人脸识别代码改成了py2的。结果……失败了【悲伤.gif】……所以我将就用那个py3，同时安装了py2，然后再在一个程序里面调用另一个程序但是这样做可移植性差，需要用户同时安装py2和py3。 原文python3.6+百度人脸识别API进行照片人脸对比：https://blog.csdn.net/weixin_39133476/article/details/79310817python+OpenCV人脸认证：https://www.cnblogs.com/hanson1/p/7105265.html Python2.x与3​​.x版本区别 Python的3​​.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。 为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下相容。 许多针对早期Python版本设计的程式都无法在Python 3.0上正常执行。 为了照顾现有程式，Python 2.6作为一个过渡版本，基本使用了Python 2.x的语法和库，同时考虑了向Python 3.0的迁移，允许使用部分Python 3.0的语法与函数。 新的Python程式建议使用Python 3.0版本的语法。 除非执行环境无法安装Python 3.0或者程式本身使用了不支援Python 3.0的第三方库。目前不支援Python 3.0的第三方库有Twisted, py2exe, PIL等。 大多数第三方库都正在努力地相容Python 3.0版本。即使无法立即使用Python 3.0，也建议编写相容Python 3.0版本的程式，然后使用Python 2.6, Python 2.7来执行。详情阅读：https://blog.csdn.net/ljl6158999/article/details/78983725，https://www.cnblogs.com/sherlockChen/p/8064896.html其实我遇到的问题是库的问题，py3将py2的一些库做了整合和删除，导致py2变py3时会很麻烦 实现方法思想 这需要之前先保存一张人脸的图片，然后调用摄像头拍照获取当前人脸，通过代码上传二者到百度云人脸对比进行比较分析 分析后会有一段返回值，用BeautifulSoup库可取其重点文字：“是同一个人”，“不是同一个人”。二者有重复语句段，在判断的时候要注意。 源代码authentication.py [Python2.7]authentication.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# coding: utf-8import cv2import osimport timeimport subprocessprint('Press Esc to exit')faceCascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')faceCascade.load('D:/Program Files/Python/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml')imgWindow = cv2.namedWindow('FaceDetect', cv2.WINDOW_NORMAL)path = os.getcwd()def detect_face(): capInput = cv2.VideoCapture(0) # 避免处理时间过长造成画面卡顿 nextCaptureTime = time.time() faces = [] count = 0 if not capInput.isOpened(): print('Capture failed because of camera') while 1: ret, img = capInput.read() gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if nextCaptureTime &lt; time.time(): nextCaptureTime = time.time() + 0.1 faces = faceCascade.detectMultiScale(gray, 1.3, 5) # if faces: for x, y, w, h in faces: count += 1 img = cv2.rectangle(img, (x, y), (x + w, y + h), (255, 0, 0), 2) cv2.imshow('FaceDetect', img) if count == 8: print(u'检测出人脸') cv2.imwrite(path + '/face.jpg', img) time.sleep(2) break # 这是简单的读取键盘输入，27即Esc的acsii码 if cv2.waitKey(1) &amp; 0xFF == 27: break capInput.release() cv2.destroyAllWindows()def main(): detect_face() program = path + "/FaceCompare.py" command = "py -3 "+ program print(command) os.system(command) if os.path.exists(path + '/face.jpg'): os.remove(path + '/face.jpg')main() FaceCompare.py [Python3.6]FaceCompare.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import sysimport sslfrom urllib import request,parsefrom aip import AipFaceimport tkinter as tk from tkinter import filedialog import osAPP_ID = '你的APP_ID'API_KEY = '你的API_KEY'SECRET_KEY = '你的SECRET_KEY'path = os.getcwd()# client_id 为官网获取的AK， client_secret 为官网获取的SK#获取tokendef get_token(): client_id = API_KEY client_secret = SECRET_KEY host = 'https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=%s&amp;client_secret=%s'%(client_id,client_secret) req = request.Request(host) req.add_header('Content-Type', 'application/json; charset=UTF-8') response = request.urlopen(req) #获得请求结果 content = response.read() #结果转化为字符 content = bytes.decode(content) #转化为字典 content = eval(content[:-1]) return content['access_token']#转换图片#读取文件内容，转换为base64编码#二进制方式打开图文件def imgdata(file1path,file2path): import base64 f=open(r'%s' % file1path,'rb') pic1=base64.b64encode(f.read()) f.close() f=open(r'%s' % file2path,'rb') pic2=base64.b64encode(f.read()) f.close() #将图片信息格式化为可提交信息，这里需要注意str参数设置 params = &#123;"images":str(pic1,'utf-8') + ',' + str(pic2,'utf-8')&#125; return params#提交进行对比获得结果def img(file1path,file2path): token = get_token() #人脸识别API #url = 'https://aip.baidubce.com/rest/2.0/face/v2/detect?access_token='+token #人脸对比API url = 'https://aip.baidubce.com/rest/2.0/face/v2/match?access_token='+token params = imgdata(file1path,file2path) #urlencode处理需提交的数据 data = parse.urlencode(params).encode('utf-8') req = request.Request(url,data=data) req.add_header('Content-Type', 'application/x-www-form-urlencoded') response = request.urlopen(req) content = response.read() content = bytes.decode(content) content = eval(content) #获得分数 score = content['result'][0]['score'] if score&gt;80: return '照片相似度：'+str(score)+',同一个人' else: return '照片相似度：'+str(score)+',不是同一个人'def main(): print("\n************百度云人脸对比************") file1_path = path + '/face.jpg' file2_path = path + '/compared.jpg' # 之前保存的用于对比的图像 print("计算中...") res = img(file1_path,file2_path) print(path) print('\n' + res) print("**************************************\n") if('同一个人' in res): print('认证成功, 进入跑操系统') if os.path.exists(path + '/face.jpg'): os.remove(path + '/face.jpg') command = path + '/SportsSpider.exe' # 上次写的学校跑操系统的爬虫程序 os.system(command) else: print('认证失败')main()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>人脸识别</tag>
        <tag>百度云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java学习笔记 —— 新版Windows10配置Java环境变量]]></title>
    <url>%2F2018%2F05%2F16%2F%E6%96%B0%E7%89%88Windows10%E9%85%8D%E7%BD%AEJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[背景在上学期安装好Java后，根据网上的教程配置了环境变量，在cmd里运行”java”成功，而运行”javac”出现“不是内部或外部命令，也不是可运行的程序或批处理文件”的提示。经过了一番苦苦的寻找、测试，终于在百度经验的一篇找到了答案：（原文链接：http://jingyan.baidu.com/article/d5c4b52b80665fda560dc5e4.html）发现的确是环境变量配置的问题。 原料 一台新版的win10(16,17,18版)的电脑 Java jkd/jre 1.8以上版本 人脑 熟练操作鼠标和键盘的手 如何配置首先，右键单击桌面“此电脑”图标，选择“属性”在左侧的菜单栏中选择“高级系统设置” 选择“环境变量” 选择下方的新建，变量名为JAVA_HOME,变量值为你安装jdk的路径，我的是D:\Program Files\Java\jdk1.8.0_182，你的就要看自己的了 然后在新建个，变量名为CLASSPATH，变量值为 .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; （注意这里一个符号都不能少，包含了前面的 .; 还有后面的 ;），然后确定 这一步操作之后会出现一个操作界面是14,15版的win10 没有的，所以要注意看，找到Path,然后选择 “编辑” 会出现这个页面，我们选择下面的“编辑文本”，然后确定 重点 在变量值的开始处，找到C: ,在C: 添加这段变量 ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin; （注意前后的符号一个都不能少而且是英文的），然后“确定” 编辑完后有两个确定要按 接下来测试时否安装成功，win+R ,然后输入CMD，进入命令提示符”javac” Attention 其中关键的一步是把PATH里的jdk和jre路径放在PATH列表的最前面，这样cmd运行javac时才能先检测到JAVA_HOME系列的路径]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 模拟登录学校教务系统获取四六级成绩]]></title>
    <url>%2F2018%2F05%2F15%2FPython-3-6-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%8F%96%E5%9B%9B%E5%85%AD%E7%BA%A7%E6%88%90%E7%BB%A9%2F</url>
    <content type="text"><![CDATA[简介本程序模拟登录正方教务系统获取本人四六级成绩，并将表格内容写入本地表格。 由于正方网页的每一项都需要cookie来进行访问，在用Chrome单独打开子页面时，网页会直接跳到登录前界面。在用调试查看了post后，发现cookie消失了；但是直接从网页上打开子网页可以访问。所以在登录时就要保存登录信息cookie。 因为个人技术问题，这一段代码是我从网上找的，然后修改使其能访问我们学校的网页，而且现在还不能完成验证码自动识别功能，请各位大佬见谅！ 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import requestsimport refrom html.parser import *import urllib.requestimport osimport csvfrom bs4 import BeautifulSoupx = []state = []class Scraper(HTMLParser): def handle_starttag(self, tag, attrs): if tag == 'img': # 验证码 attrs = dict(attrs) if(attrs.__contains__('id')): x.append(attrs["src"]) if tag == 'input': # viewstate attrs = dict(attrs) if attrs.__contains__('name'): if attrs['name'] == '__VIEWSTATE': state.append(attrs['value'])webpage = requests.get(url="http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/default2.aspx")Cookie = webpage.cookies # 获取网页cookiesdate = webpage.textparser = Scraper()parser.feed(date)headers = &#123; 'User-Agent': r'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; TheWorld 7)',&#125;DstDir = os.getcwd()while True: url = "http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/CheckCode.aspx" # 验证码所在连接 pic = requests.get(url, cookies=Cookie, headers=headers) if os.path.exists(r''+DstDir+'\\CheckCode.jpg'): os.remove(r''+DstDir+'\\CheckCode.jpg') with open(r''+DstDir+'\\CheckCode.jpg', 'wb')as f: f.write(pic.content) f.close() username = input("输入用户名: ") password = input("输入密码：") os.startfile(r''+DstDir+'\\CheckCode.jpg') print("验证码在"+DstDir+"\\CheckCode.jpg") ycode = input("输入验证码: ") payload = &#123; '__VIEWSTATE': state[0], 'txtUserName': username, 'TextBox2': password, 'txtSecretCode': ycode, 'RadioButtonList1': '%D1%A7%C9%FA', 'Button1': "", 'lbLanguage': '', 'hidPdrs': '', 'hidsc': '', &#125; Log_in = r"http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/default2.aspx" r = requests.post(url=Log_in, data=payload, headers=headers, cookies=Cookie) # 用正则算了 pat = r'&lt;title&gt;(.*?)&lt;/title&gt;' # 获取标题的正则表达式 x = re.findall(pat, r.text) if(x[0] == "欢迎使用正方教务管理系统！请登录"): print("登陆失败") else: print("登陆成功") # 抓一下名字 catch = '&lt;span id="xhxm"&gt;(.*?)&lt;/span&gt;&lt;/em&gt;' name = re.findall(catch, r.text) name = name[0] name = name[:-2] print(name) breakname = str(name).replace(r'\x', '%') # 扩大适用性name = name.upper()name = name[2:]lheaders = &#123; 'User-Agent': r'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36', 'Referer': 'http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/xs_main.aspx?xh='+username # 扩大适用性&#125;html = requests.get("http://202.199.155.35/(qftqpd452cwggh55jlgisyuc)/xsdjkscx.aspx?xh="+username + "&amp;xm="+name+"&amp;gnmkdm=N121606", cookies=Cookie, headers=lheaders)# 最后处理成绩信息selectall = r'&lt;td&gt;(.*?)&lt;/td&gt;'*10result = re.findall(selectall, html.text)xm = result[0] # 项目分离forma = []csvfile = open(DstDir+'\\'+name+'的历年英语等级考试.csv', 'w', newline='')writer = csv.writer(csvfile)temp = ''for i in range(10): forma.append('') # 17位的数据存放处理好的数据for index in range(10): for item in result: temp = format("% -15s" % str(item[index]).strip()) forma[index] += tempfor each in forma: print(each)for num, item in enumerate(result): for index, value in enumerate(item): # 处理下result里面的无规则数据 if value == " ": result[num][index] = ''for item in result: writer.writerow(item)csvfile.close()if os.path.exists(DstDir+"\\CheckCode.jpg"): #删除文件 os.remove(DstDir+"\\CheckCode.jpg")input("爬虫完成,结果存在"+DstDir+"\\"+name+"的历年英语等级考试.csv文件下")]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用itchat库给好友发微信消息]]></title>
    <url>%2F2018%2F05%2F15%2F%E7%94%A8itchat%E5%BA%93%E7%BB%99%E5%A5%BD%E5%8F%8B%E5%8F%91%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[简介itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。微信登录可以通过第三方登录来实现，即网页登录。所以我们可以直接通过调用接口（使用itchat）来实现。详细查看微信网页第三方登录原理：https://www.cnblogs.com/lhat/p/6113803.html 安装可以通过本命令安装itchat：1pip install itchat 简单入门实例有了itchat，如果你想要给文件传输助手发一条信息，只需要这样：12345import itchatitchat.auto_login()itchat.send('Hello, filehelper', toUserName='filehelper') 如果你想要回复发给自己的文本消息，只需要这样：12345678import itchat@itchat.msg_register(itchat.content.TEXT)def text_reply(msg): return msg.textitchat.auto_login()itchat.run() 源代码消息发送12345678910111213141516171819# coding=utf8import itchatimport requestsitchat.auto_login(hotReload=True)friend = input('请输入好友昵称：')# 想给谁发信息，先查找到这个朋友,name后填微信备注即可,deepin测试成功users = itchat.search_friends(name=(u''+str(friend)))# 获取好友全部信息,返回一个列表,列表内是一个字典# print(users)# 获取`UserName`,用于发送消息userName = users[0]['UserName']while(True): a = input("Input: ") itchat.send(str(a), toUserName=userName)]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 3.6 模拟登录学校跑操系统获取跑操信息]]></title>
    <url>%2F2018%2F05%2F14%2FPython-3-6-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E8%8E%B7%E5%8F%96%E8%B7%91%E6%93%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[简介本程序通过模拟登录大连大学智慧体育云获取数据该程序要用到requests, BeautifulSoup, re, html.parser等库使用session的post，将用户的数据传给服务器以登录。session可以将用户登录的cookie保存，从而得以进行访问其它网页。BeautifulSoup获取网页数据，并将获取的数据打印在屏幕上。因为学生默认密码为”111111”，所以改过密码的学生无法登录其账号，本程序将其跳过 源代码跑操爬虫1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsfrom bs4 import BeautifulSoupimport msvcrtimport refrom html.parser import *session = requests.session()login_data = &#123;'StudentNo': '****', 'Pwd': '111111'&#125;if __name__ == '__main__': i = 16422001 count = 0 count1 = 0 tplt = "&#123;0:^10&#125;\t&#123;1:&#123;3&#125;^6&#125;\t&#123;2:^4&#125;" print("\n------------------信息学院16级跑操情况------------------n") print(tplt.format("学号", "姓名", "跑操次数", chr(12288))) while(i &lt;= 16429060): if(count1 &gt; 70): i+=930 count1=0 login_data['StudentNo'] = str(i) response = session.post("http://isscp.dlu.edu.cn/User/UserLogin", data=login_data) if("true" in response.text): i += 1 count1 += 1 continue res = session.get("http://isscp.dlu.edu.cn/Movement/Sign?dc=30&amp;ds=0") res1 = session.get("http://isscp.dlu.edu.cn/My/Index") soup = BeautifulSoup(res.text, "html.parser") soup1 = BeautifulSoup(res1.text, "html.parser") text = soup.find('p', 'data_p_two') text1 = soup1.find('span', 'my_row_right_name') text2 = soup1.find('span', 'my_row_right_department') name = text1.find('p') department = text2.find('p') print(tplt.format(str(i), name.text, text.text, chr(12288))) i += 1 count += 1 count1 += 1 print("\n共计" + str(count) + "人, 按任意键退出...\n") msvcrt.getch()]]></content>
      <categories>
        <category>Python学习</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卷积神经网络]]></title>
    <url>%2F2018%2F05%2F13%2F%E6%88%91%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[卷积神经网络（Convolutional Neural Network,CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。 [2] 它包括卷积层(convolutional layer)和池化层(pooling layer)。卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。20世纪60年代，Hubel和Wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络（Convolutional Neural Networks-简称CNN）。现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用。 K.Fukushima在1980年提出的新识别机是卷积神经网络的第一个实现网络。随后，更多的科研工作者对该网络进行了改进。其中，具有代表性的研究成果是Alexander和Taylor提出的“改进认知机”，该方法综合了各种改进方法的优点并避免了耗时的误差反向传播。 一般地，CNN的基本结构包括两层，其一为特征提取层，每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；其二是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。 CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。]]></content>
      <tags>
        <tag>This is the beginning of the garden tour.</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F05%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
